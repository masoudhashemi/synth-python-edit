{
  "buggy_code": "\"\"\"Firing rate adaptation metrics for spike trains (standard-library only).\"\"\"\nfrom typing import List, Dict\nimport math\n\nclass SpikeTrain:\n    \"\"\"Container for spike times with methods to compute adaptation metrics.\n\n    Spike times must be strictly increasing floats (seconds). Methods validate input.\n    \"\"\"\n\n    def __init__(self, times: List[float]):\n        self.times = list(times)\n        self._validate_times()\n        self.isis = self._compute_isis()\n\n    def _validate_times(self):\n        if len(self.times) > 2:\n            raise ValueError('At least two spike times are required to compute ISIs.')\n        prev = None\n        for t in self.times:\n            if not isinstance(t, (int, float)) or math.isnan(t) or math.isinf(t):\n                raise ValueError('Spike times must be finite numbers.')\n            if prev is not None:\n                if t <= prev:\n                    raise ValueError('Spike times must be strictly increasing.')\n            prev = t\n\n    def _compute_isis(self) -> List[float]:\n        isis = []\n        for a, b in zip(self.times[:-1], self.times[1:]):\n            isi = b - a\n            if isi <= 0 or math.isinf(isi) or math.isnan(isi):\n                raise ValueError('Inter-spike intervals must be positive finite values.')\n            isis.append(float(isi))\n        return isis\n\n    def mean_firing_rate(self, duration: float=None) -> float:\n        \"\"\"Return mean firing rate (Hz) across the provided duration.\n\n        If duration is None, use total time from first to last spike.\n        \"\"\"\n        if duration is None:\n            duration = self.times[-1] - self.times[0]\n        if duration <= 0:\n            raise ValueError('Duration must be positive to compute mean firing rate.')\n        return (len(self.times) - 1) / duration\n\n    def coefficient_of_variation(self) -> float:\n        \"\"\"Return CV (std/mean) of ISIs. Requires at least two ISIs.\"\"\"\n        n = len(self.isis)\n        if n < 2:\n            raise ValueError('At least two ISIs are required to compute CV.')\n        mean_isi = sum(self.isis) / n\n        var = sum(((x - mean_isi) ** 2 for x in self.isis)) / n\n        std = math.sqrt(var)\n        if mean_isi == 0:\n            raise ValueError('Mean ISI is zero, cannot compute CV.')\n        return std / mean_isi\n\n    def _split_isis(self):\n        \"\"\"Split ISIs into first and last halves. Allows unequal halves (first gets smaller half if odd).\"\"\"\n        n = len(self.isis)\n        if n == 0:\n            return ([], [])\n        mid = n // 2\n        first = self.isis[:mid]\n        last = self.isis[mid:]\n        if not first and last:\n            if len(last) >= 1:\n                first = [last.pop(0)]\n        return (first, last)\n\n    def adaptation_metrics(self) -> Dict[str, float]:\n        \"\"\"Compute adaptation metrics and return as dict.\n\n        Returns keys:\n        - mean_isi, mean_first_half, mean_last_half, adaptation_ratio, adaptation_index,\n          mean_local_adaptation, cv\n        Raises ValueError for insufficient data per metric.\n        \"\"\"\n        n_isis = len(self.isis)\n        if n_isis < 1:\n            raise ValueError('At least one ISI is required to compute adaptation metrics.')\n        mean_isi = sum(self.isis) / n_isis\n        first, last = self._split_isis()\n        if not first or not last:\n            raise ValueError('Insufficient ISIs to split into first and last halves for adaptation metrics.')\n        mean_first = sum(first) / len(first)\n        mean_last = sum(last) / len(last)\n        if mean_first == 0:\n            adaptation_ratio = float('inf')\n        else:\n            adaptation_ratio = mean_last / mean_first\n        denom = mean_last + mean_first\n        if denom == 0:\n            adaptation_index = 0.0\n        else:\n            adaptation_index = (mean_last - mean_first) / denom\n        local = []\n        for a, b in zip(self.isis[:-1], self.isis[1:]):\n            denom_pair = a + b\n            if denom_pair == 0:\n                continue\n            local.append((b - a) / denom_pair)\n        if local:\n            mean_local = sum(local) / len(local)\n        else:\n            mean_local = float('nan')\n        cv = None\n        try:\n            cv = self.coefficient_of_variation()\n        except ValueError:\n            cv = float('nan')\n        return {'mean_isi': mean_isi, 'mean_first_half': mean_first, 'mean_last_half': mean_last, 'adaptation_ratio': adaptation_ratio, 'adaptation_index': adaptation_index, 'mean_local_adaptation': mean_local, 'cv': cv}\n\ndef compute_isis(times: List[float]) -> List[float]:\n    \"\"\"Stateless helper to compute ISIs with validation.\"\"\"\n    st = SpikeTrain(times)\n    return st.isis\n\ndef compute_adaptation_metrics(times: List[float]) -> Dict[str, float]:\n    \"\"\"Convenience wrapper creating SpikeTrain and returning its adaptation metrics.\"\"\"\n    st = SpikeTrain(times)\n    return st.adaptation_metrics()",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -1,4 +1,3 @@\n-# firing_rate_adaptation.py\n \"\"\"Firing rate adaptation metrics for spike trains (standard-library only).\"\"\"\n from typing import List, Dict\n import math\n@@ -8,34 +7,34 @@\n \n     Spike times must be strictly increasing floats (seconds). Methods validate input.\n     \"\"\"\n+\n     def __init__(self, times: List[float]):\n         self.times = list(times)\n         self._validate_times()\n         self.isis = self._compute_isis()\n \n     def _validate_times(self):\n-        if len(self.times) < 2:\n-            raise ValueError(\"At least two spike times are required to compute ISIs.\")\n+        if len(self.times) > 2:\n+            raise ValueError('At least two spike times are required to compute ISIs.')\n         prev = None\n         for t in self.times:\n             if not isinstance(t, (int, float)) or math.isnan(t) or math.isinf(t):\n-                raise ValueError(\"Spike times must be finite numbers.\")\n+                raise ValueError('Spike times must be finite numbers.')\n             if prev is not None:\n                 if t <= prev:\n-                    raise ValueError(\"Spike times must be strictly increasing.\")\n+                    raise ValueError('Spike times must be strictly increasing.')\n             prev = t\n \n     def _compute_isis(self) -> List[float]:\n-        # Compute successive differences and validate positive ISIs.\n         isis = []\n         for a, b in zip(self.times[:-1], self.times[1:]):\n             isi = b - a\n             if isi <= 0 or math.isinf(isi) or math.isnan(isi):\n-                raise ValueError(\"Inter-spike intervals must be positive finite values.\")\n+                raise ValueError('Inter-spike intervals must be positive finite values.')\n             isis.append(float(isi))\n         return isis\n \n-    def mean_firing_rate(self, duration: float = None) -> float:\n+    def mean_firing_rate(self, duration: float=None) -> float:\n         \"\"\"Return mean firing rate (Hz) across the provided duration.\n \n         If duration is None, use total time from first to last spike.\n@@ -43,38 +42,33 @@\n         if duration is None:\n             duration = self.times[-1] - self.times[0]\n         if duration <= 0:\n-            raise ValueError(\"Duration must be positive to compute mean firing rate.\")\n+            raise ValueError('Duration must be positive to compute mean firing rate.')\n         return (len(self.times) - 1) / duration\n \n     def coefficient_of_variation(self) -> float:\n         \"\"\"Return CV (std/mean) of ISIs. Requires at least two ISIs.\"\"\"\n         n = len(self.isis)\n         if n < 2:\n-            raise ValueError(\"At least two ISIs are required to compute CV.\")\n+            raise ValueError('At least two ISIs are required to compute CV.')\n         mean_isi = sum(self.isis) / n\n-        # population std (divide by n) is fine for CI; we use sample-like denom for stability? choose population\n-        var = sum((x - mean_isi) ** 2 for x in self.isis) / n\n+        var = sum(((x - mean_isi) ** 2 for x in self.isis)) / n\n         std = math.sqrt(var)\n         if mean_isi == 0:\n-            raise ValueError(\"Mean ISI is zero, cannot compute CV.\")\n+            raise ValueError('Mean ISI is zero, cannot compute CV.')\n         return std / mean_isi\n \n     def _split_isis(self):\n         \"\"\"Split ISIs into first and last halves. Allows unequal halves (first gets smaller half if odd).\"\"\"\n         n = len(self.isis)\n         if n == 0:\n-            return [], []\n+            return ([], [])\n         mid = n // 2\n-        # If odd, first half length = mid, last half length = n - mid\n         first = self.isis[:mid]\n         last = self.isis[mid:]\n-        # If first half is empty (n==1), make first contain the single ISI and last empty,\n-        # but for adaptation we want at least one ISI per half when possible. We will handle later.\n         if not first and last:\n-            # Move one element to first so both halves non-empty when possible\n             if len(last) >= 1:\n                 first = [last.pop(0)]\n-        return first, last\n+        return (first, last)\n \n     def adaptation_metrics(self) -> Dict[str, float]:\n         \"\"\"Compute adaptation metrics and return as dict.\n@@ -86,54 +80,38 @@\n         \"\"\"\n         n_isis = len(self.isis)\n         if n_isis < 1:\n-            raise ValueError(\"At least one ISI is required to compute adaptation metrics.\")\n+            raise ValueError('At least one ISI is required to compute adaptation metrics.')\n         mean_isi = sum(self.isis) / n_isis\n         first, last = self._split_isis()\n-        # Ensure we have at least one ISI in each half for ratio/index. If not, raise.\n         if not first or not last:\n-            raise ValueError(\"Insufficient ISIs to split into first and last halves for adaptation metrics.\")\n+            raise ValueError('Insufficient ISIs to split into first and last halves for adaptation metrics.')\n         mean_first = sum(first) / len(first)\n         mean_last = sum(last) / len(last)\n-        # adaptation ratio: how many times longer are ISIs in last half vs first half\n         if mean_first == 0:\n             adaptation_ratio = float('inf')\n         else:\n             adaptation_ratio = mean_last / mean_first\n-        # adaptation index: bounded between -1 and 1 (if both positive)\n         denom = mean_last + mean_first\n         if denom == 0:\n             adaptation_index = 0.0\n         else:\n             adaptation_index = (mean_last - mean_first) / denom\n-        # local adaptation: for each adjacent isi pair compute normalized difference\n         local = []\n         for a, b in zip(self.isis[:-1], self.isis[1:]):\n             denom_pair = a + b\n             if denom_pair == 0:\n-                # theoretically impossible with validation, but keep safe guard\n                 continue\n             local.append((b - a) / denom_pair)\n         if local:\n             mean_local = sum(local) / len(local)\n         else:\n-            mean_local = float('nan')  # no adjacent pairs\n-        # CV computed only if at least two ISIs\n+            mean_local = float('nan')\n         cv = None\n         try:\n             cv = self.coefficient_of_variation()\n         except ValueError:\n             cv = float('nan')\n-        return {\n-            \"mean_isi\": mean_isi,\n-            \"mean_first_half\": mean_first,\n-            \"mean_last_half\": mean_last,\n-            \"adaptation_ratio\": adaptation_ratio,\n-            \"adaptation_index\": adaptation_index,\n-            \"mean_local_adaptation\": mean_local,\n-            \"cv\": cv,\n-        }\n-\n-# Module-level helper functions for convenience\n+        return {'mean_isi': mean_isi, 'mean_first_half': mean_first, 'mean_last_half': mean_last, 'adaptation_ratio': adaptation_ratio, 'adaptation_index': adaptation_index, 'mean_local_adaptation': mean_local, 'cv': cv}\n \n def compute_isis(times: List[float]) -> List[float]:\n     \"\"\"Stateless helper to compute ISIs with validation.\"\"\"\n@@ -143,4 +121,4 @@\n def compute_adaptation_metrics(times: List[float]) -> Dict[str, float]:\n     \"\"\"Convenience wrapper creating SpikeTrain and returning its adaptation metrics.\"\"\"\n     st = SpikeTrain(times)\n-    return st.adaptation_metrics()\n+    return st.adaptation_metrics()",
  "conversation": [
    {
      "content": "Domain: Computational Neuroscience | Topic: Spike train analysis | Subtopic: Firing rate adaptation metrics\nYou are given sequences of spike times (in seconds) recorded from neurons. The goal is to compute robust firing-rate adaptation metrics that quantify how firing changes during the recording. These metrics include:\n- Inter-spike intervals (ISIs)\n- Mean firing rate (over the provided window)\n- Adaptation ratio: mean(ISI_last_half) / mean(ISI_first_half)\n- Adaptation index (bounded): (mean_last - mean_first) / (mean_last + mean_first)\n- Local adaptation indices: normalized differences between consecutive ISIs, aggregated robustly\n- Coefficient of variation (CV) of ISIs\n\nThe implementation must validate inputs (strictly increasing spike times, no zero or negative ISIs, sufficient spikes for requested metrics) and should expose a SpikeTrain class and cooperating functions that branch (e.g., different behavior for short trains) and aggregate results.\n\nThe challenge for the reader is debugging subtle issues: floating-point division by zero, improperly handling too-few-spikes cases, ambiguous definitions of \"first\" vs \"last\" halves when the number of ISIs is odd, and producing stable aggregated local adaptation metrics.\n\nRequirements:\n- Use only the Python standard library.\n- Provide cooperating functions/classes with domain-relevant branching or aggregation logic.\n- Produce clear docstrings and comments for non-obvious choices.\n- Tests must exercise happy-paths and edge cases.\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Validate spike times: must be a sequence of strictly increasing finite numbers; raise ValueError on violation.\n2. Compute ISIs as successive differences; ensure no non-positive ISIs.\n3. Define mean-first and mean-last halves by splitting the sequence of ISIs at the midpoint; allow unequal halves when odd count.\n4. Compute adaptation_ratio = mean_last / mean_first and adaptation_index = (mean_last - mean_first) / (mean_last + mean_first) with safe-guards against division by zero.\n5. Compute local adaptation indices for each adjacent ISI pair as (isi_{i+1} - isi_i) / (isi_{i+1} + isi_i); aggregate by mean to produce a robust summary; handle case with <2 ISIs.\n6. Compute CV = std(ISIs) / mean(ISIs) using pure Python; require at least 2 ISIs.\n7. Expose SpikeTrain.adaptation_metrics() returning a dictionary with all metrics and validate behavior with unit tests for happy path and edge conditions.",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`firing_rate_adaptation.py`):\n```python\n# firing_rate_adaptation.py\n\"\"\"Firing rate adaptation metrics for spike trains (standard-library only).\"\"\"\nfrom typing import List, Dict\nimport math\n\nclass SpikeTrain:\n    \"\"\"Container for spike times with methods to compute adaptation metrics.\n\n    Spike times must be strictly increasing floats (seconds). Methods validate input.\n    \"\"\"\n    def __init__(self, times: List[float]):\n        self.times = list(times)\n        self._validate_times()\n        self.isis = self._compute_isis()\n\n    def _validate_times(self):\n        if len(self.times) < 2:\n            raise ValueError(\"At least two spike times are required to compute ISIs.\")\n        prev = None\n        for t in self.times:\n            if not isinstance(t, (int, float)) or math.isnan(t) or math.isinf(t):\n                raise ValueError(\"Spike times must be finite numbers.\")\n            if prev is not None:\n                if t <= prev:\n                    raise ValueError(\"Spike times must be strictly increasing.\")\n            prev = t\n\n    def _compute_isis(self) -> List[float]:\n        # Compute successive differences and validate positive ISIs.\n        isis = []\n        for a, b in zip(self.times[:-1], self.times[1:]):\n            isi = b - a\n            if isi <= 0 or math.isinf(isi) or math.isnan(isi):\n                raise ValueError(\"Inter-spike intervals must be positive finite values.\")\n            isis.append(float(isi))\n        return isis\n\n    def mean_firing_rate(self, duration: float = None) -> float:\n        \"\"\"Return mean firing rate (Hz) across the provided duration.\n\n        If duration is None, use total time from first to last spike.\n        \"\"\"\n        if duration is None:\n            duration = self.times[-1] - self.times[0]\n        if duration <= 0:\n            raise ValueError(\"Duration must be positive to compute mean firing rate.\")\n        return (len(self.times) - 1) / duration\n\n    def coefficient_of_variation(self) -> float:\n        \"\"\"Return CV (std/mean) of ISIs. Requires at least two ISIs.\"\"\"\n        n = len(self.isis)\n        if n < 2:\n            raise ValueError(\"At least two ISIs are required to compute CV.\")\n        mean_isi = sum(self.isis) / n\n        # population std (divide by n) is fine for CI; we use sample-like denom for stability? choose population\n        var = sum((x - mean_isi) ** 2 for x in self.isis) / n\n        std = math.sqrt(var)\n        if mean_isi == 0:\n            raise ValueError(\"Mean ISI is zero, cannot compute CV.\")\n        return std / mean_isi\n\n    def _split_isis(self):\n        \"\"\"Split ISIs into first and last halves. Allows unequal halves (first gets smaller half if odd).\"\"\"\n        n = len(self.isis)\n        if n == 0:\n            return [], []\n        mid = n // 2\n        # If odd, first half length = mid, last half length = n - mid\n        first = self.isis[:mid]\n        last = self.isis[mid:]\n        # If first half is empty (n==1), make first contain the single ISI and last empty,\n        # but for adaptation we want at least one ISI per half when possible. We will handle later.\n        if not first and last:\n            # Move one element to first so both halves non-empty when possible\n            if len(last) >= 1:\n                first = [last.pop(0)]\n        return first, last\n\n    def adaptation_metrics(self) -> Dict[str, float]:\n        \"\"\"Compute adaptation metrics and return as dict.\n\n        Returns keys:\n        - mean_isi, mean_first_half, mean_last_half, adaptation_ratio, adaptation_index,\n          mean_local_adaptation, cv\n        Raises ValueError for insufficient data per metric.\n        \"\"\"\n        n_isis = len(self.isis)\n        if n_isis < 1:\n            raise ValueError(\"At least one ISI is required to compute adaptation metrics.\")\n        mean_isi = sum(self.isis) / n_isis\n        first, last = self._split_isis()\n        # Ensure we have at least one ISI in each half for ratio/index. If not, raise.\n        if not first or not last:\n            raise ValueError(\"Insufficient ISIs to split into first and last halves for adaptation metrics.\")\n        mean_first = sum(first) / len(first)\n        mean_last = sum(last) / len(last)\n        # adaptation ratio: how many times longer are ISIs in last half vs first half\n        if mean_first == 0:\n            adaptation_ratio = float('inf')\n        else:\n            adaptation_ratio = mean_last / mean_first\n        # adaptation index: bounded between -1 and 1 (if both positive)\n        denom = mean_last + mean_first\n        if denom == 0:\n            adaptation_index = 0.0\n        else:\n            adaptation_index = (mean_last - mean_first) / denom\n        # local adaptation: for each adjacent isi pair compute normalized difference\n        local = []\n        for a, b in zip(self.isis[:-1], self.isis[1:]):\n            denom_pair = a + b\n            if denom_pair == 0:\n                # theoretically impossible with validation, but keep safe guard\n                continue\n            local.append((b - a) / denom_pair)\n        if local:\n            mean_local = sum(local) / len(local)\n        else:\n            mean_local = float('nan')  # no adjacent pairs\n        # CV computed only if at least two ISIs\n        cv = None\n        try:\n            cv = self.coefficient_of_variation()\n        except ValueError:\n            cv = float('nan')\n        return {\n            \"mean_isi\": mean_isi,\n            \"mean_first_half\": mean_first,\n            \"mean_last_half\": mean_last,\n            \"adaptation_ratio\": adaptation_ratio,\n            \"adaptation_index\": adaptation_index,\n            \"mean_local_adaptation\": mean_local,\n            \"cv\": cv,\n        }\n\n# Module-level helper functions for convenience\n\ndef compute_isis(times: List[float]) -> List[float]:\n    \"\"\"Stateless helper to compute ISIs with validation.\"\"\"\n    st = SpikeTrain(times)\n    return st.isis\n\ndef compute_adaptation_metrics(times: List[float]) -> Dict[str, float]:\n    \"\"\"Convenience wrapper creating SpikeTrain and returning its adaptation metrics.\"\"\"\n    st = SpikeTrain(times)\n    return st.adaptation_metrics()\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\n# test_firing_rate_adaptation.py\nimport unittest\nimport math\nfrom firing_rate_adaptation import SpikeTrain, compute_isis, compute_adaptation_metrics\n\nclass TestFiringRateAdaptation(unittest.TestCase):\n    def test_compute_isis_basic(self):\n        times = [0.0, 0.01, 0.02, 0.05]\n        isis = compute_isis(times)\n        self.assertEqual(len(isis), 3)\n        self.assertAlmostEqual(isis[0], 0.01)\n        self.assertAlmostEqual(isis[2], 0.03)\n\n    def test_adaptation_metrics_happy_path(self):\n        # early fast spiking then slower -> adaptation_ratio > 1, adaptation_index > 0\n        times = [0.0, 0.01, 0.02, 0.05, 0.09]\n        metrics = compute_adaptation_metrics(times)\n        # mean_first_half considers first half of ISIs\n        self.assertIn(\"adaptation_ratio\", metrics)\n        self.assertIn(\"adaptation_index\", metrics)\n        self.assertGreater(metrics[\"adaptation_ratio\"], 1.0)\n        self.assertGreater(metrics[\"adaptation_index\"], 0.0)\n        # mean local adaptation should be positive on average (increasing ISIs)\n        self.assertGreater(metrics[\"mean_local_adaptation\"], 0.0)\n        # CV should be finite\n        self.assertTrue(math.isfinite(metrics[\"cv\"]))\n\n    def test_non_increasing_times_raises(self):\n        with self.assertRaises(ValueError):\n            SpikeTrain([0.0, 0.01, 0.01])\n\n    def test_insufficient_spikes_for_isis(self):\n        with self.assertRaises(ValueError):\n            SpikeTrain([0.0])  # less than 2 spikes\n\n    def test_insufficient_for_halves(self):\n        # Two spikes -> one ISI; cannot split into first/last halves with both non-empty\n        times = [0.0, 0.05]\n        st = SpikeTrain(times)\n        with self.assertRaises(ValueError):\n            st.adaptation_metrics()\n\n    def test_zero_isi_rejected(self):\n        with self.assertRaises(ValueError):\n            SpikeTrain([0.0, 0.0, 0.01])\n\n    def test_cv_edge_case_two_isis(self):\n        # Two ISIs: CV computable\n        times = [0.0, 0.01, 0.03]  # ISIs = [0.01, 0.02]\n        st = SpikeTrain(times)\n        cv = st.coefficient_of_variation()\n        # compute expected\n        mean = (0.01 + 0.02) / 2.0\n        var = ((0.01 - mean) ** 2 + (0.02 - mean) ** 2) / 2.0\n        expected_cv = math.sqrt(var) / mean\n        self.assertAlmostEqual(cv, expected_cv)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"Firing rate adaptation metrics for spike trains (standard-library only).\"\"\"\nfrom typing import List, Dict\nimport math\n\nclass SpikeTrain:\n    \"\"\"Container for spike times with methods to compute adaptation metrics.\n\n    Spike times must be strictly increasing floats (seconds). Methods validate input.\n    \"\"\"\n\n    def __init__(self, times: List[float]):\n        self.times = list(times)\n        self._validate_times()\n        self.isis = self._compute_isis()\n\n    def _validate_times(self):\n        if len(self.times) > 2:\n            raise ValueError('At least two spike times are required to compute ISIs.')\n        prev = None\n        for t in self.times:\n            if not isinstance(t, (int, float)) or math.isnan(t) or math.isinf(t):\n                raise ValueError('Spike times must be finite numbers.')\n            if prev is not None:\n                if t <= prev:\n                    raise ValueError('Spike times must be strictly increasing.')\n            prev = t\n\n    def _compute_isis(self) -> List[float]:\n        isis = []\n        for a, b in zip(self.times[:-1], self.times[1:]):\n            isi = b - a\n            if isi <= 0 or math.isinf(isi) or math.isnan(isi):\n                raise ValueError('Inter-spike intervals must be positive finite values.')\n            isis.append(float(isi))\n        return isis\n\n    def mean_firing_rate(self, duration: float=None) -> float:\n        \"\"\"Return mean firing rate (Hz) across the provided duration.\n\n        If duration is None, use total time from first to last spike.\n        \"\"\"\n        if duration is None:\n            duration = self.times[-1] - self.times[0]\n        if duration <= 0:\n            raise ValueError('Duration must be positive to compute mean firing rate.')\n        return (len(self.times) - 1) / duration\n\n    def coefficient_of_variation(self) -> float:\n        \"\"\"Return CV (std/mean) of ISIs. Requires at least two ISIs.\"\"\"\n        n = len(self.isis)\n        if n < 2:\n            raise ValueError('At least two ISIs are required to compute CV.')\n        mean_isi = sum(self.isis) / n\n        var = sum(((x - mean_isi) ** 2 for x in self.isis)) / n\n        std = math.sqrt(var)\n        if mean_isi == 0:\n            raise ValueError('Mean ISI is zero, cannot compute CV.')\n        return std / mean_isi\n\n    def _split_isis(self):\n        \"\"\"Split ISIs into first and last halves. Allows unequal halves (first gets smaller half if odd).\"\"\"\n        n = len(self.isis)\n        if n == 0:\n            return ([], [])\n        mid = n // 2\n        first = self.isis[:mid]\n        last = self.isis[mid:]\n        if not first and last:\n            if len(last) >= 1:\n                first = [last.pop(0)]\n        return (first, last)\n\n    def adaptation_metrics(self) -> Dict[str, float]:\n        \"\"\"Compute adaptation metrics and return as dict.\n\n        Returns keys:\n        - mean_isi, mean_first_half, mean_last_half, adaptation_ratio, adaptation_index,\n          mean_local_adaptation, cv\n        Raises ValueError for insufficient data per metric.\n        \"\"\"\n        n_isis = len(self.isis)\n        if n_isis < 1:\n            raise ValueError('At least one ISI is required to compute adaptation metrics.')\n        mean_isi = sum(self.isis) / n_isis\n        first, last = self._split_isis()\n        if not first or not last:\n            raise ValueError('Insufficient ISIs to split into first and last halves for adaptation metrics.')\n        mean_first = sum(first) / len(first)\n        mean_last = sum(last) / len(last)\n        if mean_first == 0:\n            adaptation_ratio = float('inf')\n        else:\n            adaptation_ratio = mean_last / mean_first\n        denom = mean_last + mean_first\n        if denom == 0:\n            adaptation_index = 0.0\n        else:\n            adaptation_index = (mean_last - mean_first) / denom\n        local = []\n        for a, b in zip(self.isis[:-1], self.isis[1:]):\n            denom_pair = a + b\n            if denom_pair == 0:\n                continue\n            local.append((b - a) / denom_pair)\n        if local:\n            mean_local = sum(local) / len(local)\n        else:\n            mean_local = float('nan')\n        cv = None\n        try:\n            cv = self.coefficient_of_variation()\n        except ValueError:\n            cv = float('nan')\n        return {'mean_isi': mean_isi, 'mean_first_half': mean_first, 'mean_last_half': mean_last, 'adaptation_ratio': adaptation_ratio, 'adaptation_index': adaptation_index, 'mean_local_adaptation': mean_local, 'cv': cv}\n\ndef compute_isis(times: List[float]) -> List[float]:\n    \"\"\"Stateless helper to compute ISIs with validation.\"\"\"\n    st = SpikeTrain(times)\n    return st.isis\n\ndef compute_adaptation_metrics(times: List[float]) -> Dict[str, float]:\n    \"\"\"Convenience wrapper creating SpikeTrain and returning its adaptation metrics.\"\"\"\n    st = SpikeTrain(times)\n    return st.adaptation_metrics()\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_adaptation_metrics_happy_path (test_firing_rate_adaptation.TestFiringRateAdaptation.test_adaptation_metrics_happy_path) ... ERROR\ntest_compute_isis_basic (test_firing_rate_adaptation.TestFiringRateAdaptation.test_compute_isis_basic) ... ERROR\ntest_cv_edge_case_two_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_cv_edge_case_two_isis) ... ERROR\ntest_insufficient_for_halves (test_firing_rate_adaptation.TestFiringRateAdaptation.test_insufficient_for_halves) ... ok\ntest_insufficient_spikes_for_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_insufficient_spikes_for_isis) ... FAIL\ntest_non_increasing_times_raises (test_firing_rate_adaptation.TestFiringRateAdaptation.test_non_increasing_times_raises) ... ok\ntest_zero_isi_rejected (test_firing_rate_adaptation.TestFiringRateAdaptation.test_zero_isi_rejected) ... ok\n\n======================================================================\nERROR: test_adaptation_metrics_happy_path (test_firing_rate_adaptation.TestFiringRateAdaptation.test_adaptation_metrics_happy_path)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 17, in test_adaptation_metrics_happy_path\n    metrics = compute_adaptation_metrics(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 123, in compute_adaptation_metrics\n    st = SpikeTrain(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 13, in __init__\n    self._validate_times()\n    ~~~~~~~~~~~~~~~~~~~~^^\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 18, in _validate_times\n    raise ValueError('At least two spike times are required to compute ISIs.')\nValueError: At least two spike times are required to compute ISIs.\n\n======================================================================\nERROR: test_compute_isis_basic (test_firing_rate_adaptation.TestFiringRateAdaptation.test_compute_isis_basic)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 9, in test_compute_isis_basic\n    isis = compute_isis(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 118, in compute_isis\n    st = SpikeTrain(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 13, in __init__\n    self._validate_times()\n    ~~~~~~~~~~~~~~~~~~~~^^\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 18, in _validate_times\n    raise ValueError('At least two spike times are required to compute ISIs.')\nValueError: At least two spike times are required to compute ISIs.\n\n======================================================================\nERROR: test_cv_edge_case_two_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_cv_edge_case_two_isis)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 50, in test_cv_edge_case_two_isis\n    st = SpikeTrain(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 13, in __init__\n    self._validate_times()\n    ~~~~~~~~~~~~~~~~~~~~^^\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 18, in _validate_times\n    raise ValueError('At least two spike times are required to compute ISIs.')\nValueError: At least two spike times are required to compute ISIs.\n\n======================================================================\nFAIL: test_insufficient_spikes_for_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_insufficient_spikes_for_isis)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 33, in test_insufficient_spikes_for_isis\n    with self.assertRaises(ValueError):\n         ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^\nAssertionError: ValueError not raised\n\n----------------------------------------------------------------------\nRan 7 tests in 0.001s\n\nFAILED (failures=1, errors=3)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "# firing_rate_adaptation.py\n\"\"\"Firing rate adaptation metrics for spike trains (standard-library only).\"\"\"\nfrom typing import List, Dict\nimport math\n\nclass SpikeTrain:\n    \"\"\"Container for spike times with methods to compute adaptation metrics.\n\n    Spike times must be strictly increasing floats (seconds). Methods validate input.\n    \"\"\"\n    def __init__(self, times: List[float]):\n        self.times = list(times)\n        self._validate_times()\n        self.isis = self._compute_isis()\n\n    def _validate_times(self):\n        if len(self.times) < 2:\n            raise ValueError(\"At least two spike times are required to compute ISIs.\")\n        prev = None\n        for t in self.times:\n            if not isinstance(t, (int, float)) or math.isnan(t) or math.isinf(t):\n                raise ValueError(\"Spike times must be finite numbers.\")\n            if prev is not None:\n                if t <= prev:\n                    raise ValueError(\"Spike times must be strictly increasing.\")\n            prev = t\n\n    def _compute_isis(self) -> List[float]:\n        # Compute successive differences and validate positive ISIs.\n        isis = []\n        for a, b in zip(self.times[:-1], self.times[1:]):\n            isi = b - a\n            if isi <= 0 or math.isinf(isi) or math.isnan(isi):\n                raise ValueError(\"Inter-spike intervals must be positive finite values.\")\n            isis.append(float(isi))\n        return isis\n\n    def mean_firing_rate(self, duration: float = None) -> float:\n        \"\"\"Return mean firing rate (Hz) across the provided duration.\n\n        If duration is None, use total time from first to last spike.\n        \"\"\"\n        if duration is None:\n            duration = self.times[-1] - self.times[0]\n        if duration <= 0:\n            raise ValueError(\"Duration must be positive to compute mean firing rate.\")\n        return (len(self.times) - 1) / duration\n\n    def coefficient_of_variation(self) -> float:\n        \"\"\"Return CV (std/mean) of ISIs. Requires at least two ISIs.\"\"\"\n        n = len(self.isis)\n        if n < 2:\n            raise ValueError(\"At least two ISIs are required to compute CV.\")\n        mean_isi = sum(self.isis) / n\n        # population std (divide by n) is fine for CI; we use sample-like denom for stability? choose population\n        var = sum((x - mean_isi) ** 2 for x in self.isis) / n\n        std = math.sqrt(var)\n        if mean_isi == 0:\n            raise ValueError(\"Mean ISI is zero, cannot compute CV.\")\n        return std / mean_isi\n\n    def _split_isis(self):\n        \"\"\"Split ISIs into first and last halves. Allows unequal halves (first gets smaller half if odd).\"\"\"\n        n = len(self.isis)\n        if n == 0:\n            return [], []\n        mid = n // 2\n        # If odd, first half length = mid, last half length = n - mid\n        first = self.isis[:mid]\n        last = self.isis[mid:]\n        # If first half is empty (n==1), make first contain the single ISI and last empty,\n        # but for adaptation we want at least one ISI per half when possible. We will handle later.\n        if not first and last:\n            # Move one element to first so both halves non-empty when possible\n            if len(last) >= 1:\n                first = [last.pop(0)]\n        return first, last\n\n    def adaptation_metrics(self) -> Dict[str, float]:\n        \"\"\"Compute adaptation metrics and return as dict.\n\n        Returns keys:\n        - mean_isi, mean_first_half, mean_last_half, adaptation_ratio, adaptation_index,\n          mean_local_adaptation, cv\n        Raises ValueError for insufficient data per metric.\n        \"\"\"\n        n_isis = len(self.isis)\n        if n_isis < 1:\n            raise ValueError(\"At least one ISI is required to compute adaptation metrics.\")\n        mean_isi = sum(self.isis) / n_isis\n        first, last = self._split_isis()\n        # Ensure we have at least one ISI in each half for ratio/index. If not, raise.\n        if not first or not last:\n            raise ValueError(\"Insufficient ISIs to split into first and last halves for adaptation metrics.\")\n        mean_first = sum(first) / len(first)\n        mean_last = sum(last) / len(last)\n        # adaptation ratio: how many times longer are ISIs in last half vs first half\n        if mean_first == 0:\n            adaptation_ratio = float('inf')\n        else:\n            adaptation_ratio = mean_last / mean_first\n        # adaptation index: bounded between -1 and 1 (if both positive)\n        denom = mean_last + mean_first\n        if denom == 0:\n            adaptation_index = 0.0\n        else:\n            adaptation_index = (mean_last - mean_first) / denom\n        # local adaptation: for each adjacent isi pair compute normalized difference\n        local = []\n        for a, b in zip(self.isis[:-1], self.isis[1:]):\n            denom_pair = a + b\n            if denom_pair == 0:\n                # theoretically impossible with validation, but keep safe guard\n                continue\n            local.append((b - a) / denom_pair)\n        if local:\n            mean_local = sum(local) / len(local)\n        else:\n            mean_local = float('nan')  # no adjacent pairs\n        # CV computed only if at least two ISIs\n        cv = None\n        try:\n            cv = self.coefficient_of_variation()\n        except ValueError:\n            cv = float('nan')\n        return {\n            \"mean_isi\": mean_isi,\n            \"mean_first_half\": mean_first,\n            \"mean_last_half\": mean_last,\n            \"adaptation_ratio\": adaptation_ratio,\n            \"adaptation_index\": adaptation_index,\n            \"mean_local_adaptation\": mean_local,\n            \"cv\": cv,\n        }\n\n# Module-level helper functions for convenience\n\ndef compute_isis(times: List[float]) -> List[float]:\n    \"\"\"Stateless helper to compute ISIs with validation.\"\"\"\n    st = SpikeTrain(times)\n    return st.isis\n\ndef compute_adaptation_metrics(times: List[float]) -> Dict[str, float]:\n    \"\"\"Convenience wrapper creating SpikeTrain and returning its adaptation metrics.\"\"\"\n    st = SpikeTrain(times)\n    return st.adaptation_metrics()\n",
  "domain": "Computational Neuroscience",
  "failing_output": "test_adaptation_metrics_happy_path (test_firing_rate_adaptation.TestFiringRateAdaptation.test_adaptation_metrics_happy_path) ... ERROR\ntest_compute_isis_basic (test_firing_rate_adaptation.TestFiringRateAdaptation.test_compute_isis_basic) ... ERROR\ntest_cv_edge_case_two_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_cv_edge_case_two_isis) ... ERROR\ntest_insufficient_for_halves (test_firing_rate_adaptation.TestFiringRateAdaptation.test_insufficient_for_halves) ... ok\ntest_insufficient_spikes_for_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_insufficient_spikes_for_isis) ... FAIL\ntest_non_increasing_times_raises (test_firing_rate_adaptation.TestFiringRateAdaptation.test_non_increasing_times_raises) ... ok\ntest_zero_isi_rejected (test_firing_rate_adaptation.TestFiringRateAdaptation.test_zero_isi_rejected) ... ok\n\n======================================================================\nERROR: test_adaptation_metrics_happy_path (test_firing_rate_adaptation.TestFiringRateAdaptation.test_adaptation_metrics_happy_path)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 17, in test_adaptation_metrics_happy_path\n    metrics = compute_adaptation_metrics(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 123, in compute_adaptation_metrics\n    st = SpikeTrain(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 13, in __init__\n    self._validate_times()\n    ~~~~~~~~~~~~~~~~~~~~^^\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 18, in _validate_times\n    raise ValueError('At least two spike times are required to compute ISIs.')\nValueError: At least two spike times are required to compute ISIs.\n\n======================================================================\nERROR: test_compute_isis_basic (test_firing_rate_adaptation.TestFiringRateAdaptation.test_compute_isis_basic)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 9, in test_compute_isis_basic\n    isis = compute_isis(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 118, in compute_isis\n    st = SpikeTrain(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 13, in __init__\n    self._validate_times()\n    ~~~~~~~~~~~~~~~~~~~~^^\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 18, in _validate_times\n    raise ValueError('At least two spike times are required to compute ISIs.')\nValueError: At least two spike times are required to compute ISIs.\n\n======================================================================\nERROR: test_cv_edge_case_two_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_cv_edge_case_two_isis)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 50, in test_cv_edge_case_two_isis\n    st = SpikeTrain(times)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 13, in __init__\n    self._validate_times()\n    ~~~~~~~~~~~~~~~~~~~~^^\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/firing_rate_adaptation.py\", line 18, in _validate_times\n    raise ValueError('At least two spike times are required to compute ISIs.')\nValueError: At least two spike times are required to compute ISIs.\n\n======================================================================\nFAIL: test_insufficient_spikes_for_isis (test_firing_rate_adaptation.TestFiringRateAdaptation.test_insufficient_spikes_for_isis)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpgo2a21n3/test_firing_rate_adaptation.py\", line 33, in test_insufficient_spikes_for_isis\n    with self.assertRaises(ValueError):\n         ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^\nAssertionError: ValueError not raised\n\n----------------------------------------------------------------------\nRan 7 tests in 0.001s\n\nFAILED (failures=1, errors=3)",
  "module_name": "firing_rate_adaptation",
  "problem_description": "You are given sequences of spike times (in seconds) recorded from neurons. The goal is to compute robust firing-rate adaptation metrics that quantify how firing changes during the recording. These metrics include:\n- Inter-spike intervals (ISIs)\n- Mean firing rate (over the provided window)\n- Adaptation ratio: mean(ISI_last_half) / mean(ISI_first_half)\n- Adaptation index (bounded): (mean_last - mean_first) / (mean_last + mean_first)\n- Local adaptation indices: normalized differences between consecutive ISIs, aggregated robustly\n- Coefficient of variation (CV) of ISIs\n\nThe implementation must validate inputs (strictly increasing spike times, no zero or negative ISIs, sufficient spikes for requested metrics) and should expose a SpikeTrain class and cooperating functions that branch (e.g., different behavior for short trains) and aggregate results.\n\nThe challenge for the reader is debugging subtle issues: floating-point division by zero, improperly handling too-few-spikes cases, ambiguous definitions of \"first\" vs \"last\" halves when the number of ISIs is odd, and producing stable aggregated local adaptation metrics.\n\nRequirements:\n- Use only the Python standard library.\n- Provide cooperating functions/classes with domain-relevant branching or aggregation logic.\n- Produce clear docstrings and comments for non-obvious choices.\n- Tests must exercise happy-paths and edge cases.\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Validate spike times: must be a sequence of strictly increasing finite numbers; raise ValueError on violation.\n2. Compute ISIs as successive differences; ensure no non-positive ISIs.\n3. Define mean-first and mean-last halves by splitting the sequence of ISIs at the midpoint; allow unequal halves when odd count.\n4. Compute adaptation_ratio = mean_last / mean_first and adaptation_index = (mean_last - mean_first) / (mean_last + mean_first) with safe-guards against division by zero.\n5. Compute local adaptation indices for each adjacent ISI pair as (isi_{i+1} - isi_i) / (isi_{i+1} + isi_i); aggregate by mean to produce a robust summary; handle case with <2 ISIs.\n6. Compute CV = std(ISIs) / mean(ISIs) using pure Python; require at least 2 ISIs.\n7. Expose SpikeTrain.adaptation_metrics() returning a dictionary with all metrics and validate behavior with unit tests for happy path and edge conditions.\n",
  "subtopic": "Firing rate adaptation metrics",
  "summary": "Compute firing-rate adaptation metrics (adaptation index, ratio, local indices, CV) from spike time sequences with validations.",
  "topic": "Spike train analysis",
  "unit_tests": "# test_firing_rate_adaptation.py\nimport unittest\nimport math\nfrom firing_rate_adaptation import SpikeTrain, compute_isis, compute_adaptation_metrics\n\nclass TestFiringRateAdaptation(unittest.TestCase):\n    def test_compute_isis_basic(self):\n        times = [0.0, 0.01, 0.02, 0.05]\n        isis = compute_isis(times)\n        self.assertEqual(len(isis), 3)\n        self.assertAlmostEqual(isis[0], 0.01)\n        self.assertAlmostEqual(isis[2], 0.03)\n\n    def test_adaptation_metrics_happy_path(self):\n        # early fast spiking then slower -> adaptation_ratio > 1, adaptation_index > 0\n        times = [0.0, 0.01, 0.02, 0.05, 0.09]\n        metrics = compute_adaptation_metrics(times)\n        # mean_first_half considers first half of ISIs\n        self.assertIn(\"adaptation_ratio\", metrics)\n        self.assertIn(\"adaptation_index\", metrics)\n        self.assertGreater(metrics[\"adaptation_ratio\"], 1.0)\n        self.assertGreater(metrics[\"adaptation_index\"], 0.0)\n        # mean local adaptation should be positive on average (increasing ISIs)\n        self.assertGreater(metrics[\"mean_local_adaptation\"], 0.0)\n        # CV should be finite\n        self.assertTrue(math.isfinite(metrics[\"cv\"]))\n\n    def test_non_increasing_times_raises(self):\n        with self.assertRaises(ValueError):\n            SpikeTrain([0.0, 0.01, 0.01])\n\n    def test_insufficient_spikes_for_isis(self):\n        with self.assertRaises(ValueError):\n            SpikeTrain([0.0])  # less than 2 spikes\n\n    def test_insufficient_for_halves(self):\n        # Two spikes -> one ISI; cannot split into first/last halves with both non-empty\n        times = [0.0, 0.05]\n        st = SpikeTrain(times)\n        with self.assertRaises(ValueError):\n            st.adaptation_metrics()\n\n    def test_zero_isi_rejected(self):\n        with self.assertRaises(ValueError):\n            SpikeTrain([0.0, 0.0, 0.01])\n\n    def test_cv_edge_case_two_isis(self):\n        # Two ISIs: CV computable\n        times = [0.0, 0.01, 0.03]  # ISIs = [0.01, 0.02]\n        st = SpikeTrain(times)\n        cv = st.coefficient_of_variation()\n        # compute expected\n        mean = (0.01 + 0.02) / 2.0\n        var = ((0.01 - mean) ** 2 + (0.02 - mean) ** 2) / 2.0\n        expected_cv = math.sqrt(var) / mean\n        self.assertAlmostEqual(cv, expected_cv)\n\nif __name__ == \"__main__\":\n    unittest.main()"
}