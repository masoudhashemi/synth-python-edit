{
  "buggy_code": "\"\"\"1D heat equation finite-difference solver with explicit and implicit time stepping.\n\nSupports homogeneous Dirichlet boundary conditions. Uses lists for arrays (stdlib only).\n\"\"\"\nfrom math import sin, pi, exp, sqrt\nfrom typing import List\n\nclass Heat1DSolver:\n\n    def __init__(self, alpha: float, length: float, nx: int, dt: float, method: str='explicit'):\n        if alpha <= 0:\n            raise ValueError('alpha must be positive')\n        if length <= 0:\n            raise ValueError('length must be positive')\n        if nx < 3:\n            raise ValueError('nx must be at least 3 (two boundaries + one interior point)')\n        if dt <= 0:\n            raise ValueError('dt must be positive')\n        method = method.lower()\n        if method not in ('explicit', 'implicit'):\n            raise ValueError(\"method must be 'explicit' or 'implicit'\")\n        self.alpha = float(alpha)\n        self.L = float(length)\n        self.nx = int(nx)\n        self.dt = float(dt)\n        self.method = method\n        self.dx = self.L / (self.nx + 1)\n        self.r = self.alpha * self.dt / (self.dx * self.dx)\n        self.u: List[float] = [0.0] * self.nx\n        if self.method == 'explicit' and self.r > 0.5 + 1e-15:\n            raise ValueError(f'Explicit method unstable: r = {self.r:.6g} > 0.5. Reduce dt or increase nx.')\n\n    def set_initial(self, u0: List[float]):\n        if len(u0) != self.nx:\n            raise ValueError('Initial condition length mismatch with nx')\n        if abs(u0[0]) > 1e-12 or abs(u0[-1]) > 1e-12:\n            raise ValueError('Initial condition must satisfy Dirichlet BCs (u=0 at boundaries)')\n        self.u = list(u0)\n\n    def step(self):\n        \"\"\"Advance solution by one timestep using chosen method.\"\"\"\n        if self.method == 'explicit':\n            return self._step_explicit()\n        else:\n            return self._step_implicit()\n\n    def _step_explicit(self):\n        new_u = [0.0] * self.nx\n        r = self.r\n        for i in range(1, self.nx - 1):\n            new_u[i] = self.u[i] + r * (self.u[i + 1] - 2.0 * self.u[i] + self.u[i - 1])\n        self.u = new_u\n        return self.u\n\n    def _step_implicit(self):\n        n = self.nx - 2\n        if n == 0:\n            return self.u\n        a = [-self.r] * (n - 1)\n        b = [1.0 + 2.0 * self.r] * n\n        c = [-self.r] * (n - 1)\n        d = [self.u[i] for i in range(1, self.nx - 1)]\n        for i in range(1, n):\n            w = a[i - 1] / b[i - 1]\n            b[i] = b[i] - w * c[i - 1]\n            d[i] = d[i] - w * d[i - 1]\n        x = [0.0] * n\n        x[-1] = d[-1] / b[-1]\n        for i in range(n - 2, -1, -1):\n            x[i] = (d[i] - c[i] * x[i + 1]) / b[i]\n        self.u = [0.0] + x + [0.0]\n        return self.u\n\n    def run(self, nsteps: int):\n        if nsteps < 0:\n            raise ValueError('nsteps must be non-negative')\n        for _ in range(nsteps):\n            self.step()\n        return self.u\n\n    def l2_norm(self) -> float:\n        s = 0.0\n        for val in self.u:\n            s += val * val\n        return sqrt(s * self.dx)\n\n    def max_abs_error(self, analytic_func) -> float:\n        maxerr = 0.0\n        for i, val in enumerate(self.u):\n            x = i * self.dx\n            err = abs(val - analytic_func(x))\n            if err > maxerr:\n                maxerr = err\n        return maxerr\n\ndef sin_mode_initial(nx: int, length: float, mode: int=1) -> List[float]:\n    \"\"\"Return u(x,0) = sin(mode*pi*x/L) sampled on grid with Dirichlet zeros.\"\"\"\n    dx = length / (nx - 1)\n    return [0.0 if i == 0 or i == nx - 1 else sin(mode * pi * (i * dx) / length) for i in range(nx)]\n\ndef sin_mode_analytic(x: float, t: float, alpha: float, length: float, mode: int=1) -> float:\n    \"\"\"Analytic solution for a single sine mode initial condition.\"\"\"\n    decay = exp(-alpha * (mode * pi / length) ** 2 * t)\n    return decay * sin(mode * pi * x / length)",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -1,4 +1,3 @@\n-# heat_fdm_solver.py\n \"\"\"1D heat equation finite-difference solver with explicit and implicit time stepping.\n \n Supports homogeneous Dirichlet boundary conditions. Uses lists for arrays (stdlib only).\n@@ -7,42 +6,35 @@\n from typing import List\n \n class Heat1DSolver:\n-    def __init__(self, alpha: float, length: float, nx: int, dt: float, method: str = 'explicit'):\n+\n+    def __init__(self, alpha: float, length: float, nx: int, dt: float, method: str='explicit'):\n         if alpha <= 0:\n-            raise ValueError(\"alpha must be positive\")\n+            raise ValueError('alpha must be positive')\n         if length <= 0:\n-            raise ValueError(\"length must be positive\")\n+            raise ValueError('length must be positive')\n         if nx < 3:\n-            raise ValueError(\"nx must be at least 3 (two boundaries + one interior point)\")\n+            raise ValueError('nx must be at least 3 (two boundaries + one interior point)')\n         if dt <= 0:\n-            raise ValueError(\"dt must be positive\")\n+            raise ValueError('dt must be positive')\n         method = method.lower()\n         if method not in ('explicit', 'implicit'):\n             raise ValueError(\"method must be 'explicit' or 'implicit'\")\n-\n         self.alpha = float(alpha)\n         self.L = float(length)\n         self.nx = int(nx)\n         self.dt = float(dt)\n         self.method = method\n-        self.dx = self.L / (self.nx - 1)\n-        # r = alpha * dt / dx^2\n+        self.dx = self.L / (self.nx + 1)\n         self.r = self.alpha * self.dt / (self.dx * self.dx)\n-\n-        # allocate solution vector including boundary points\n         self.u: List[float] = [0.0] * self.nx\n-\n-        # Check stability for explicit\n         if self.method == 'explicit' and self.r > 0.5 + 1e-15:\n-            # Slight tolerance allowed for floating point\n-            raise ValueError(f\"Explicit method unstable: r = {self.r:.6g} > 0.5. Reduce dt or increase nx.\")\n+            raise ValueError(f'Explicit method unstable: r = {self.r:.6g} > 0.5. Reduce dt or increase nx.')\n \n     def set_initial(self, u0: List[float]):\n         if len(u0) != self.nx:\n-            raise ValueError(\"Initial condition length mismatch with nx\")\n-        # enforce Dirichlet BCs: endpoints must be zero\n+            raise ValueError('Initial condition length mismatch with nx')\n         if abs(u0[0]) > 1e-12 or abs(u0[-1]) > 1e-12:\n-            raise ValueError(\"Initial condition must satisfy Dirichlet BCs (u=0 at boundaries)\")\n+            raise ValueError('Initial condition must satisfy Dirichlet BCs (u=0 at boundaries)')\n         self.u = list(u0)\n \n     def step(self):\n@@ -53,57 +45,46 @@\n             return self._step_implicit()\n \n     def _step_explicit(self):\n-        # FTCS update for interior points; boundaries remain zero\n         new_u = [0.0] * self.nx\n         r = self.r\n         for i in range(1, self.nx - 1):\n-            new_u[i] = self.u[i] + r * (self.u[i+1] - 2.0*self.u[i] + self.u[i-1])\n+            new_u[i] = self.u[i] + r * (self.u[i + 1] - 2.0 * self.u[i] + self.u[i - 1])\n         self.u = new_u\n         return self.u\n \n     def _step_implicit(self):\n-        # Backward Euler: solve tridiagonal system A u^{n+1} = u^n\n-        n = self.nx - 2  # number of interior unknowns\n+        n = self.nx - 2\n         if n == 0:\n             return self.u\n-        # Tridiagonal coefficients: a lower, b diag, c upper\n         a = [-self.r] * (n - 1)\n-        b = [1.0 + 2.0*self.r] * n\n+        b = [1.0 + 2.0 * self.r] * n\n         c = [-self.r] * (n - 1)\n-        # Right-hand side is interior values of self.u\n         d = [self.u[i] for i in range(1, self.nx - 1)]\n-\n-        # Thomas algorithm (tridiagonal solver)\n-        # Forward elimination\n         for i in range(1, n):\n-            w = a[i-1] / b[i-1]\n-            b[i] = b[i] - w * c[i-1]\n-            d[i] = d[i] - w * d[i-1]\n-        # Back substitution\n+            w = a[i - 1] / b[i - 1]\n+            b[i] = b[i] - w * c[i - 1]\n+            d[i] = d[i] - w * d[i - 1]\n         x = [0.0] * n\n         x[-1] = d[-1] / b[-1]\n-        for i in range(n-2, -1, -1):\n-            x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n-        # Reassemble full solution with Dirichlet zeros at boundaries\n+        for i in range(n - 2, -1, -1):\n+            x[i] = (d[i] - c[i] * x[i + 1]) / b[i]\n         self.u = [0.0] + x + [0.0]\n         return self.u\n \n     def run(self, nsteps: int):\n         if nsteps < 0:\n-            raise ValueError(\"nsteps must be non-negative\")\n+            raise ValueError('nsteps must be non-negative')\n         for _ in range(nsteps):\n             self.step()\n         return self.u\n \n     def l2_norm(self) -> float:\n-        # discrete L2 norm on grid with spacing dx (including boundaries)\n         s = 0.0\n         for val in self.u:\n-            s += val*val\n+            s += val * val\n         return sqrt(s * self.dx)\n \n     def max_abs_error(self, analytic_func) -> float:\n-        # analytic_func(x) returns expected value at current time; here no time dependence\n         maxerr = 0.0\n         for i, val in enumerate(self.u):\n             x = i * self.dx\n@@ -112,13 +93,12 @@\n                 maxerr = err\n         return maxerr\n \n-def sin_mode_initial(nx: int, length: float, mode: int = 1) -> List[float]:\n+def sin_mode_initial(nx: int, length: float, mode: int=1) -> List[float]:\n     \"\"\"Return u(x,0) = sin(mode*pi*x/L) sampled on grid with Dirichlet zeros.\"\"\"\n     dx = length / (nx - 1)\n-    return [0.0 if (i == 0 or i == nx-1) else sin(mode * pi * (i*dx) / length)\n-            for i in range(nx)]\n+    return [0.0 if i == 0 or i == nx - 1 else sin(mode * pi * (i * dx) / length) for i in range(nx)]\n \n-def sin_mode_analytic(x: float, t: float, alpha: float, length: float, mode: int = 1) -> float:\n+def sin_mode_analytic(x: float, t: float, alpha: float, length: float, mode: int=1) -> float:\n     \"\"\"Analytic solution for a single sine mode initial condition.\"\"\"\n-    decay = exp(-alpha * (mode*pi/length)**2 * t)\n-    return decay * sin(mode * pi * x / length)\n+    decay = exp(-alpha * (mode * pi / length) ** 2 * t)\n+    return decay * sin(mode * pi * x / length)",
  "conversation": [
    {
      "content": "Domain: Applied Mathematics | Topic: Partial differential equations | Subtopic: Finite difference solver for heat diffusion\nYou are given the task of implementing a 1D finite-difference solver for the heat (diffusion) equation u_t = alpha * u_xx on a rod of length L with homogeneous Dirichlet boundary conditions (u=0 at x=0 and x=L).\n\nThe solver should support two time-stepping methods:\n- explicit (forward-time centered-space, FTCS), which requires enforcing a stability condition on the time step (r = alpha*dt/dx^2 <= 0.5);\n- implicit (backward Euler), which is unconditionally stable and solved via a tridiagonal (Thomas) algorithm.\n\nThe module must provide a class-based solver that:\n- validates inputs and raises informative errors for misuse (e.g., unstable explicit dt);\n- allows stepping for a specified number of timesteps and returning diagnostics;\n- exposes utilities to compute L2 norm and pointwise errors against a known analytic solution for the sinusoidal initial condition.\n\nThis debugging challenge asks you to implement correct, well-documented, and testable code that a senior scientist would use to validate finite-difference implementations. Tests will verify correct behaviour on stable explicit runs, that explicit instability is detected, that implicit runs can use larger dt, and that the L2 norm decreases as heat diffuses.\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Define a Heat1DSolver class that initializes grid parameters, method choice, and performs basic validation.\n2. Implement stability check for the explicit scheme and raise ValueError when violated.\n3. Provide an explicit time-step method implementing the FTCS update for interior points.\n4. Implement an implicit step using a Thomas algorithm to solve the tridiagonal system for the backward Euler scheme.\n5. Offer run(), step(), and diagnostic methods (l2_norm, max_abs_error) plus a factory initial-condition function for the sine mode with analytic solution.\n6. Write unittests that exercise stable explicit run vs analytic solution, explicit instability detection, implicit large-dt correctness, and monotonic decrease of L2 norm.",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`heat_fdm_solver.py`):\n```python\n# heat_fdm_solver.py\n\"\"\"1D heat equation finite-difference solver with explicit and implicit time stepping.\n\nSupports homogeneous Dirichlet boundary conditions. Uses lists for arrays (stdlib only).\n\"\"\"\nfrom math import sin, pi, exp, sqrt\nfrom typing import List\n\nclass Heat1DSolver:\n    def __init__(self, alpha: float, length: float, nx: int, dt: float, method: str = 'explicit'):\n        if alpha <= 0:\n            raise ValueError(\"alpha must be positive\")\n        if length <= 0:\n            raise ValueError(\"length must be positive\")\n        if nx < 3:\n            raise ValueError(\"nx must be at least 3 (two boundaries + one interior point)\")\n        if dt <= 0:\n            raise ValueError(\"dt must be positive\")\n        method = method.lower()\n        if method not in ('explicit', 'implicit'):\n            raise ValueError(\"method must be 'explicit' or 'implicit'\")\n\n        self.alpha = float(alpha)\n        self.L = float(length)\n        self.nx = int(nx)\n        self.dt = float(dt)\n        self.method = method\n        self.dx = self.L / (self.nx - 1)\n        # r = alpha * dt / dx^2\n        self.r = self.alpha * self.dt / (self.dx * self.dx)\n\n        # allocate solution vector including boundary points\n        self.u: List[float] = [0.0] * self.nx\n\n        # Check stability for explicit\n        if self.method == 'explicit' and self.r > 0.5 + 1e-15:\n            # Slight tolerance allowed for floating point\n            raise ValueError(f\"Explicit method unstable: r = {self.r:.6g} > 0.5. Reduce dt or increase nx.\")\n\n    def set_initial(self, u0: List[float]):\n        if len(u0) != self.nx:\n            raise ValueError(\"Initial condition length mismatch with nx\")\n        # enforce Dirichlet BCs: endpoints must be zero\n        if abs(u0[0]) > 1e-12 or abs(u0[-1]) > 1e-12:\n            raise ValueError(\"Initial condition must satisfy Dirichlet BCs (u=0 at boundaries)\")\n        self.u = list(u0)\n\n    def step(self):\n        \"\"\"Advance solution by one timestep using chosen method.\"\"\"\n        if self.method == 'explicit':\n            return self._step_explicit()\n        else:\n            return self._step_implicit()\n\n    def _step_explicit(self):\n        # FTCS update for interior points; boundaries remain zero\n        new_u = [0.0] * self.nx\n        r = self.r\n        for i in range(1, self.nx - 1):\n            new_u[i] = self.u[i] + r * (self.u[i+1] - 2.0*self.u[i] + self.u[i-1])\n        self.u = new_u\n        return self.u\n\n    def _step_implicit(self):\n        # Backward Euler: solve tridiagonal system A u^{n+1} = u^n\n        n = self.nx - 2  # number of interior unknowns\n        if n == 0:\n            return self.u\n        # Tridiagonal coefficients: a lower, b diag, c upper\n        a = [-self.r] * (n - 1)\n        b = [1.0 + 2.0*self.r] * n\n        c = [-self.r] * (n - 1)\n        # Right-hand side is interior values of self.u\n        d = [self.u[i] for i in range(1, self.nx - 1)]\n\n        # Thomas algorithm (tridiagonal solver)\n        # Forward elimination\n        for i in range(1, n):\n            w = a[i-1] / b[i-1]\n            b[i] = b[i] - w * c[i-1]\n            d[i] = d[i] - w * d[i-1]\n        # Back substitution\n        x = [0.0] * n\n        x[-1] = d[-1] / b[-1]\n        for i in range(n-2, -1, -1):\n            x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n        # Reassemble full solution with Dirichlet zeros at boundaries\n        self.u = [0.0] + x + [0.0]\n        return self.u\n\n    def run(self, nsteps: int):\n        if nsteps < 0:\n            raise ValueError(\"nsteps must be non-negative\")\n        for _ in range(nsteps):\n            self.step()\n        return self.u\n\n    def l2_norm(self) -> float:\n        # discrete L2 norm on grid with spacing dx (including boundaries)\n        s = 0.0\n        for val in self.u:\n            s += val*val\n        return sqrt(s * self.dx)\n\n    def max_abs_error(self, analytic_func) -> float:\n        # analytic_func(x) returns expected value at current time; here no time dependence\n        maxerr = 0.0\n        for i, val in enumerate(self.u):\n            x = i * self.dx\n            err = abs(val - analytic_func(x))\n            if err > maxerr:\n                maxerr = err\n        return maxerr\n\ndef sin_mode_initial(nx: int, length: float, mode: int = 1) -> List[float]:\n    \"\"\"Return u(x,0) = sin(mode*pi*x/L) sampled on grid with Dirichlet zeros.\"\"\"\n    dx = length / (nx - 1)\n    return [0.0 if (i == 0 or i == nx-1) else sin(mode * pi * (i*dx) / length)\n            for i in range(nx)]\n\ndef sin_mode_analytic(x: float, t: float, alpha: float, length: float, mode: int = 1) -> float:\n    \"\"\"Analytic solution for a single sine mode initial condition.\"\"\"\n    decay = exp(-alpha * (mode*pi/length)**2 * t)\n    return decay * sin(mode * pi * x / length)\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\n# test_heat_fdm_solver.py\nimport unittest\nfrom math import isclose\nimport math\nimport time\nimport types\nimport sys\n# Import the solver module (assumes saved as heat_fdm_solver.py in the same directory)\nimport heat_fdm_solver as solver\n\nclass TestHeatFDM(unittest.TestCase):\n    def test_explicit_stable_matches_analytic(self):\n        alpha = 1.0\n        L = 1.0\n        nx = 51\n        dx = L / (nx - 1)\n        # choose r = 0.4 < 0.5\n        r = 0.4\n        dt = r * dx * dx / alpha\n        t_final = 0.05\n        nsteps = int(round(t_final / dt))\n        dt = t_final / nsteps  # adjust to hit exactly t_final\n        solver_obj = solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='explicit')\n        u0 = solver.sin_mode_initial(nx=nx, length=L, mode=1)\n        solver_obj.set_initial(u0)\n        solver_obj.run(nsteps)\n        # analytic at t_final\n        analytic = lambda x: solver.sin_mode_analytic(x, nsteps*dt, alpha, L, mode=1)\n        maxerr = solver_obj.max_abs_error(analytic)\n        self.assertLess(maxerr, 1e-3, f\"Explicit stable run deviates too much: {maxerr}\")\n\n    def test_explicit_unstable_raises(self):\n        alpha = 1.0\n        L = 1.0\n        nx = 21\n        dx = L / (nx - 1)\n        # choose r > 0.5 to trigger instability detection\n        r = 0.8\n        dt = r * dx * dx / alpha\n        with self.assertRaises(ValueError):\n            solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='explicit')\n\n    def test_implicit_allows_large_dt_and_matches(self):\n        alpha = 1.0\n        L = 1.0\n        nx = 51\n        dx = L / (nx - 1)\n        # choose large r that would be unstable for explicit\n        r = 4.0\n        dt = r * dx * dx / alpha\n        t_final = 0.1\n        nsteps = int(round(t_final / dt))\n        if nsteps < 1:\n            nsteps = 1\n            dt = t_final\n        solver_obj = solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='implicit')\n        u0 = solver.sin_mode_initial(nx=nx, length=L, mode=1)\n        solver_obj.set_initial(u0)\n        solver_obj.run(nsteps)\n        analytic = lambda x: solver.sin_mode_analytic(x, nsteps*dt, alpha, L, mode=1)\n        # implicit second-order-in-time is not used (backward Euler), so allow looser tolerance\n        maxerr = solver_obj.max_abs_error(analytic)\n        self.assertLess(maxerr, 5e-3, f\"Implicit run deviates too much: {maxerr}\")\n\n    def test_l2_norm_decreases_with_time(self):\n        alpha = 0.5\n        L = 1.0\n        nx = 31\n        dx = L / (nx - 1)\n        r = 0.3\n        dt = r * dx * dx / alpha\n        solver_obj = solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='explicit')\n        u0 = solver.sin_mode_initial(nx=nx, length=L, mode=1)\n        solver_obj.set_initial(u0)\n        norm0 = solver_obj.l2_norm()\n        solver_obj.run(10)\n        norm1 = solver_obj.l2_norm()\n        self.assertLess(norm1, norm0, \"L2 norm should decrease due to diffusion\")\n\nif __name__ == '__main__':\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"1D heat equation finite-difference solver with explicit and implicit time stepping.\n\nSupports homogeneous Dirichlet boundary conditions. Uses lists for arrays (stdlib only).\n\"\"\"\nfrom math import sin, pi, exp, sqrt\nfrom typing import List\n\nclass Heat1DSolver:\n\n    def __init__(self, alpha: float, length: float, nx: int, dt: float, method: str='explicit'):\n        if alpha <= 0:\n            raise ValueError('alpha must be positive')\n        if length <= 0:\n            raise ValueError('length must be positive')\n        if nx < 3:\n            raise ValueError('nx must be at least 3 (two boundaries + one interior point)')\n        if dt <= 0:\n            raise ValueError('dt must be positive')\n        method = method.lower()\n        if method not in ('explicit', 'implicit'):\n            raise ValueError(\"method must be 'explicit' or 'implicit'\")\n        self.alpha = float(alpha)\n        self.L = float(length)\n        self.nx = int(nx)\n        self.dt = float(dt)\n        self.method = method\n        self.dx = self.L / (self.nx + 1)\n        self.r = self.alpha * self.dt / (self.dx * self.dx)\n        self.u: List[float] = [0.0] * self.nx\n        if self.method == 'explicit' and self.r > 0.5 + 1e-15:\n            raise ValueError(f'Explicit method unstable: r = {self.r:.6g} > 0.5. Reduce dt or increase nx.')\n\n    def set_initial(self, u0: List[float]):\n        if len(u0) != self.nx:\n            raise ValueError('Initial condition length mismatch with nx')\n        if abs(u0[0]) > 1e-12 or abs(u0[-1]) > 1e-12:\n            raise ValueError('Initial condition must satisfy Dirichlet BCs (u=0 at boundaries)')\n        self.u = list(u0)\n\n    def step(self):\n        \"\"\"Advance solution by one timestep using chosen method.\"\"\"\n        if self.method == 'explicit':\n            return self._step_explicit()\n        else:\n            return self._step_implicit()\n\n    def _step_explicit(self):\n        new_u = [0.0] * self.nx\n        r = self.r\n        for i in range(1, self.nx - 1):\n            new_u[i] = self.u[i] + r * (self.u[i + 1] - 2.0 * self.u[i] + self.u[i - 1])\n        self.u = new_u\n        return self.u\n\n    def _step_implicit(self):\n        n = self.nx - 2\n        if n == 0:\n            return self.u\n        a = [-self.r] * (n - 1)\n        b = [1.0 + 2.0 * self.r] * n\n        c = [-self.r] * (n - 1)\n        d = [self.u[i] for i in range(1, self.nx - 1)]\n        for i in range(1, n):\n            w = a[i - 1] / b[i - 1]\n            b[i] = b[i] - w * c[i - 1]\n            d[i] = d[i] - w * d[i - 1]\n        x = [0.0] * n\n        x[-1] = d[-1] / b[-1]\n        for i in range(n - 2, -1, -1):\n            x[i] = (d[i] - c[i] * x[i + 1]) / b[i]\n        self.u = [0.0] + x + [0.0]\n        return self.u\n\n    def run(self, nsteps: int):\n        if nsteps < 0:\n            raise ValueError('nsteps must be non-negative')\n        for _ in range(nsteps):\n            self.step()\n        return self.u\n\n    def l2_norm(self) -> float:\n        s = 0.0\n        for val in self.u:\n            s += val * val\n        return sqrt(s * self.dx)\n\n    def max_abs_error(self, analytic_func) -> float:\n        maxerr = 0.0\n        for i, val in enumerate(self.u):\n            x = i * self.dx\n            err = abs(val - analytic_func(x))\n            if err > maxerr:\n                maxerr = err\n        return maxerr\n\ndef sin_mode_initial(nx: int, length: float, mode: int=1) -> List[float]:\n    \"\"\"Return u(x,0) = sin(mode*pi*x/L) sampled on grid with Dirichlet zeros.\"\"\"\n    dx = length / (nx - 1)\n    return [0.0 if i == 0 or i == nx - 1 else sin(mode * pi * (i * dx) / length) for i in range(nx)]\n\ndef sin_mode_analytic(x: float, t: float, alpha: float, length: float, mode: int=1) -> float:\n    \"\"\"Analytic solution for a single sine mode initial condition.\"\"\"\n    decay = exp(-alpha * (mode * pi / length) ** 2 * t)\n    return decay * sin(mode * pi * x / length)\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_explicit_stable_matches_analytic (test_heat_fdm_solver.TestHeatFDM.test_explicit_stable_matches_analytic) ... FAIL\ntest_explicit_unstable_raises (test_heat_fdm_solver.TestHeatFDM.test_explicit_unstable_raises) ... ok\ntest_implicit_allows_large_dt_and_matches (test_heat_fdm_solver.TestHeatFDM.test_implicit_allows_large_dt_and_matches) ... FAIL\ntest_l2_norm_decreases_with_time (test_heat_fdm_solver.TestHeatFDM.test_l2_norm_decreases_with_time) ... ok\n\n======================================================================\nFAIL: test_explicit_stable_matches_analytic (test_heat_fdm_solver.TestHeatFDM.test_explicit_stable_matches_analytic)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpaa0tf1dk/test_heat_fdm_solver.py\", line 30, in test_explicit_stable_matches_analytic\n    self.assertLess(maxerr, 1e-3, f\"Explicit stable run deviates too much: {maxerr}\")\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.07358740526796954 not less than 0.001 : Explicit stable run deviates too much: 0.07358740526796954\n\n======================================================================\nFAIL: test_implicit_allows_large_dt_and_matches (test_heat_fdm_solver.TestHeatFDM.test_implicit_allows_large_dt_and_matches)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpaa0tf1dk/test_heat_fdm_solver.py\", line 63, in test_implicit_allows_large_dt_and_matches\n    self.assertLess(maxerr, 5e-3, f\"Implicit run deviates too much: {maxerr}\")\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.04616737712498731 not less than 0.005 : Implicit run deviates too much: 0.04616737712498731\n\n----------------------------------------------------------------------\nRan 4 tests in 0.002s\n\nFAILED (failures=2)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "# heat_fdm_solver.py\n\"\"\"1D heat equation finite-difference solver with explicit and implicit time stepping.\n\nSupports homogeneous Dirichlet boundary conditions. Uses lists for arrays (stdlib only).\n\"\"\"\nfrom math import sin, pi, exp, sqrt\nfrom typing import List\n\nclass Heat1DSolver:\n    def __init__(self, alpha: float, length: float, nx: int, dt: float, method: str = 'explicit'):\n        if alpha <= 0:\n            raise ValueError(\"alpha must be positive\")\n        if length <= 0:\n            raise ValueError(\"length must be positive\")\n        if nx < 3:\n            raise ValueError(\"nx must be at least 3 (two boundaries + one interior point)\")\n        if dt <= 0:\n            raise ValueError(\"dt must be positive\")\n        method = method.lower()\n        if method not in ('explicit', 'implicit'):\n            raise ValueError(\"method must be 'explicit' or 'implicit'\")\n\n        self.alpha = float(alpha)\n        self.L = float(length)\n        self.nx = int(nx)\n        self.dt = float(dt)\n        self.method = method\n        self.dx = self.L / (self.nx - 1)\n        # r = alpha * dt / dx^2\n        self.r = self.alpha * self.dt / (self.dx * self.dx)\n\n        # allocate solution vector including boundary points\n        self.u: List[float] = [0.0] * self.nx\n\n        # Check stability for explicit\n        if self.method == 'explicit' and self.r > 0.5 + 1e-15:\n            # Slight tolerance allowed for floating point\n            raise ValueError(f\"Explicit method unstable: r = {self.r:.6g} > 0.5. Reduce dt or increase nx.\")\n\n    def set_initial(self, u0: List[float]):\n        if len(u0) != self.nx:\n            raise ValueError(\"Initial condition length mismatch with nx\")\n        # enforce Dirichlet BCs: endpoints must be zero\n        if abs(u0[0]) > 1e-12 or abs(u0[-1]) > 1e-12:\n            raise ValueError(\"Initial condition must satisfy Dirichlet BCs (u=0 at boundaries)\")\n        self.u = list(u0)\n\n    def step(self):\n        \"\"\"Advance solution by one timestep using chosen method.\"\"\"\n        if self.method == 'explicit':\n            return self._step_explicit()\n        else:\n            return self._step_implicit()\n\n    def _step_explicit(self):\n        # FTCS update for interior points; boundaries remain zero\n        new_u = [0.0] * self.nx\n        r = self.r\n        for i in range(1, self.nx - 1):\n            new_u[i] = self.u[i] + r * (self.u[i+1] - 2.0*self.u[i] + self.u[i-1])\n        self.u = new_u\n        return self.u\n\n    def _step_implicit(self):\n        # Backward Euler: solve tridiagonal system A u^{n+1} = u^n\n        n = self.nx - 2  # number of interior unknowns\n        if n == 0:\n            return self.u\n        # Tridiagonal coefficients: a lower, b diag, c upper\n        a = [-self.r] * (n - 1)\n        b = [1.0 + 2.0*self.r] * n\n        c = [-self.r] * (n - 1)\n        # Right-hand side is interior values of self.u\n        d = [self.u[i] for i in range(1, self.nx - 1)]\n\n        # Thomas algorithm (tridiagonal solver)\n        # Forward elimination\n        for i in range(1, n):\n            w = a[i-1] / b[i-1]\n            b[i] = b[i] - w * c[i-1]\n            d[i] = d[i] - w * d[i-1]\n        # Back substitution\n        x = [0.0] * n\n        x[-1] = d[-1] / b[-1]\n        for i in range(n-2, -1, -1):\n            x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n        # Reassemble full solution with Dirichlet zeros at boundaries\n        self.u = [0.0] + x + [0.0]\n        return self.u\n\n    def run(self, nsteps: int):\n        if nsteps < 0:\n            raise ValueError(\"nsteps must be non-negative\")\n        for _ in range(nsteps):\n            self.step()\n        return self.u\n\n    def l2_norm(self) -> float:\n        # discrete L2 norm on grid with spacing dx (including boundaries)\n        s = 0.0\n        for val in self.u:\n            s += val*val\n        return sqrt(s * self.dx)\n\n    def max_abs_error(self, analytic_func) -> float:\n        # analytic_func(x) returns expected value at current time; here no time dependence\n        maxerr = 0.0\n        for i, val in enumerate(self.u):\n            x = i * self.dx\n            err = abs(val - analytic_func(x))\n            if err > maxerr:\n                maxerr = err\n        return maxerr\n\ndef sin_mode_initial(nx: int, length: float, mode: int = 1) -> List[float]:\n    \"\"\"Return u(x,0) = sin(mode*pi*x/L) sampled on grid with Dirichlet zeros.\"\"\"\n    dx = length / (nx - 1)\n    return [0.0 if (i == 0 or i == nx-1) else sin(mode * pi * (i*dx) / length)\n            for i in range(nx)]\n\ndef sin_mode_analytic(x: float, t: float, alpha: float, length: float, mode: int = 1) -> float:\n    \"\"\"Analytic solution for a single sine mode initial condition.\"\"\"\n    decay = exp(-alpha * (mode*pi/length)**2 * t)\n    return decay * sin(mode * pi * x / length)\n",
  "domain": "Applied Mathematics",
  "failing_output": "test_explicit_stable_matches_analytic (test_heat_fdm_solver.TestHeatFDM.test_explicit_stable_matches_analytic) ... FAIL\ntest_explicit_unstable_raises (test_heat_fdm_solver.TestHeatFDM.test_explicit_unstable_raises) ... ok\ntest_implicit_allows_large_dt_and_matches (test_heat_fdm_solver.TestHeatFDM.test_implicit_allows_large_dt_and_matches) ... FAIL\ntest_l2_norm_decreases_with_time (test_heat_fdm_solver.TestHeatFDM.test_l2_norm_decreases_with_time) ... ok\n\n======================================================================\nFAIL: test_explicit_stable_matches_analytic (test_heat_fdm_solver.TestHeatFDM.test_explicit_stable_matches_analytic)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpaa0tf1dk/test_heat_fdm_solver.py\", line 30, in test_explicit_stable_matches_analytic\n    self.assertLess(maxerr, 1e-3, f\"Explicit stable run deviates too much: {maxerr}\")\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.07358740526796954 not less than 0.001 : Explicit stable run deviates too much: 0.07358740526796954\n\n======================================================================\nFAIL: test_implicit_allows_large_dt_and_matches (test_heat_fdm_solver.TestHeatFDM.test_implicit_allows_large_dt_and_matches)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpaa0tf1dk/test_heat_fdm_solver.py\", line 63, in test_implicit_allows_large_dt_and_matches\n    self.assertLess(maxerr, 5e-3, f\"Implicit run deviates too much: {maxerr}\")\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.04616737712498731 not less than 0.005 : Implicit run deviates too much: 0.04616737712498731\n\n----------------------------------------------------------------------\nRan 4 tests in 0.002s\n\nFAILED (failures=2)",
  "module_name": "heat_fdm_solver",
  "problem_description": "You are given the task of implementing a 1D finite-difference solver for the heat (diffusion) equation u_t = alpha * u_xx on a rod of length L with homogeneous Dirichlet boundary conditions (u=0 at x=0 and x=L).\n\nThe solver should support two time-stepping methods:\n- explicit (forward-time centered-space, FTCS), which requires enforcing a stability condition on the time step (r = alpha*dt/dx^2 <= 0.5);\n- implicit (backward Euler), which is unconditionally stable and solved via a tridiagonal (Thomas) algorithm.\n\nThe module must provide a class-based solver that:\n- validates inputs and raises informative errors for misuse (e.g., unstable explicit dt);\n- allows stepping for a specified number of timesteps and returning diagnostics;\n- exposes utilities to compute L2 norm and pointwise errors against a known analytic solution for the sinusoidal initial condition.\n\nThis debugging challenge asks you to implement correct, well-documented, and testable code that a senior scientist would use to validate finite-difference implementations. Tests will verify correct behaviour on stable explicit runs, that explicit instability is detected, that implicit runs can use larger dt, and that the L2 norm decreases as heat diffuses.\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Define a Heat1DSolver class that initializes grid parameters, method choice, and performs basic validation.\n2. Implement stability check for the explicit scheme and raise ValueError when violated.\n3. Provide an explicit time-step method implementing the FTCS update for interior points.\n4. Implement an implicit step using a Thomas algorithm to solve the tridiagonal system for the backward Euler scheme.\n5. Offer run(), step(), and diagnostic methods (l2_norm, max_abs_error) plus a factory initial-condition function for the sine mode with analytic solution.\n6. Write unittests that exercise stable explicit run vs analytic solution, explicit instability detection, implicit large-dt correctness, and monotonic decrease of L2 norm.\n",
  "subtopic": "Finite difference solver for heat diffusion",
  "summary": "A 1D finite-difference heat equation solver with explicit and implicit methods, stability checks, and diagnostic utilities for debugging.",
  "topic": "Partial differential equations",
  "unit_tests": "# test_heat_fdm_solver.py\nimport unittest\nfrom math import isclose\nimport math\nimport time\nimport types\nimport sys\n# Import the solver module (assumes saved as heat_fdm_solver.py in the same directory)\nimport heat_fdm_solver as solver\n\nclass TestHeatFDM(unittest.TestCase):\n    def test_explicit_stable_matches_analytic(self):\n        alpha = 1.0\n        L = 1.0\n        nx = 51\n        dx = L / (nx - 1)\n        # choose r = 0.4 < 0.5\n        r = 0.4\n        dt = r * dx * dx / alpha\n        t_final = 0.05\n        nsteps = int(round(t_final / dt))\n        dt = t_final / nsteps  # adjust to hit exactly t_final\n        solver_obj = solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='explicit')\n        u0 = solver.sin_mode_initial(nx=nx, length=L, mode=1)\n        solver_obj.set_initial(u0)\n        solver_obj.run(nsteps)\n        # analytic at t_final\n        analytic = lambda x: solver.sin_mode_analytic(x, nsteps*dt, alpha, L, mode=1)\n        maxerr = solver_obj.max_abs_error(analytic)\n        self.assertLess(maxerr, 1e-3, f\"Explicit stable run deviates too much: {maxerr}\")\n\n    def test_explicit_unstable_raises(self):\n        alpha = 1.0\n        L = 1.0\n        nx = 21\n        dx = L / (nx - 1)\n        # choose r > 0.5 to trigger instability detection\n        r = 0.8\n        dt = r * dx * dx / alpha\n        with self.assertRaises(ValueError):\n            solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='explicit')\n\n    def test_implicit_allows_large_dt_and_matches(self):\n        alpha = 1.0\n        L = 1.0\n        nx = 51\n        dx = L / (nx - 1)\n        # choose large r that would be unstable for explicit\n        r = 4.0\n        dt = r * dx * dx / alpha\n        t_final = 0.1\n        nsteps = int(round(t_final / dt))\n        if nsteps < 1:\n            nsteps = 1\n            dt = t_final\n        solver_obj = solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='implicit')\n        u0 = solver.sin_mode_initial(nx=nx, length=L, mode=1)\n        solver_obj.set_initial(u0)\n        solver_obj.run(nsteps)\n        analytic = lambda x: solver.sin_mode_analytic(x, nsteps*dt, alpha, L, mode=1)\n        # implicit second-order-in-time is not used (backward Euler), so allow looser tolerance\n        maxerr = solver_obj.max_abs_error(analytic)\n        self.assertLess(maxerr, 5e-3, f\"Implicit run deviates too much: {maxerr}\")\n\n    def test_l2_norm_decreases_with_time(self):\n        alpha = 0.5\n        L = 1.0\n        nx = 31\n        dx = L / (nx - 1)\n        r = 0.3\n        dt = r * dx * dx / alpha\n        solver_obj = solver.Heat1DSolver(alpha=alpha, length=L, nx=nx, dt=dt, method='explicit')\n        u0 = solver.sin_mode_initial(nx=nx, length=L, mode=1)\n        solver_obj.set_initial(u0)\n        norm0 = solver_obj.l2_norm()\n        solver_obj.run(10)\n        norm1 = solver_obj.l2_norm()\n        self.assertLess(norm1, norm0, \"L2 norm should decrease due to diffusion\")\n\nif __name__ == '__main__':\n    unittest.main()"
}