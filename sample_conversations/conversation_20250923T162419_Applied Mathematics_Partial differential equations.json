{
  "buggy_code": "\"\"\"\n1D explicit finite-difference heat equation solver.\nSupports Dirichlet and Neumann BCs, stability checks, and small-grid edge cases.\n\"\"\"\nfrom math import inf\n\nclass BoundaryConditionError(ValueError):\n    pass\n\nclass HeatSolver1D:\n\n    def __init__(self, length, nx, alpha, bc_left=('dirichlet', 0.0), bc_right=('dirichlet', 0.0)):\n        if nx < 1:\n            raise ValueError('nx must be >= 1')\n        if length <= 0 and nx > 1:\n            raise ValueError('length must be > 0 for nx>1')\n        if alpha < 0:\n            raise ValueError('alpha must be non-negative')\n        self.L = float(length)\n        self.nx = int(nx)\n        self.alpha = float(alpha)\n        self.dx = None if self.nx == 1 else self.L / (self.nx + 1)\n        self._validate_bc_tuple(bc_left)\n        self._validate_bc_tuple(bc_right)\n        self.bc_left = bc_left\n        self.bc_right = bc_right\n        self.u = [0.0 for _ in range(self.nx)]\n\n    @staticmethod\n    def _validate_bc_tuple(bc):\n        if not (isinstance(bc, tuple) and len(bc) == 2 and (bc[0] in ('dirichlet', 'neumann'))):\n            raise BoundaryConditionError(\"BC must be ('dirichlet'|'neumann', value)\")\n\n    def set_initial(self, u0):\n        \"\"\"Set initial state. Accept list/tuple of length nx or callable x->T.\"\"\"\n        if callable(u0):\n            if self.nx == 1:\n                self.u[0] = float(u0(0.0))\n            else:\n                self.u = [float(u0(i * self.dx)) for i in range(self.nx)]\n        else:\n            if len(u0) != self.nx:\n                raise ValueError('Initial condition length mismatch')\n            self.u = [float(v) for v in u0]\n        if self.nx >= 1 and self.bc_left[0] == 'dirichlet':\n            self.u[0] = float(self.bc_left[1])\n        if self.nx >= 1 and self.bc_right[0] == 'dirichlet':\n            self.u[-1] = float(self.bc_right[1])\n\n    def compute_stable_dt(self):\n        \"\"\"Return maximum stable dt for explicit scheme: dx^2/(2*alpha).\"\"\"\n        if self.alpha == 0.0:\n            return inf\n        if self.nx == 1:\n            return inf\n        return self.dx * self.dx / (2.0 * self.alpha)\n\n    def _apply_one_step(self, dt):\n        n = self.nx\n        u = self.u\n        if n == 1:\n            if self.bc_left[0] == 'dirichlet':\n                self.u[0] = float(self.bc_left[1])\n            return\n        dx = self.dx\n        alpha = self.alpha\n        u_new = [0.0] * n\n        if self.bc_left[0] == 'neumann':\n            ql = float(self.bc_left[1])\n            u_ghost_left = u[1] - 2.0 * dx * ql\n        else:\n            u_ghost_left = None\n        if self.bc_right[0] == 'neumann':\n            qr = float(self.bc_right[1])\n            u_ghost_right = u[-2] + 2.0 * dx * qr\n        else:\n            u_ghost_right = None\n        for i in range(n):\n            if i == 0:\n                if self.bc_left[0] == 'dirichlet':\n                    u_new[0] = float(self.bc_left[1])\n                else:\n                    lap = (u[1] - 2.0 * u[0] + u_ghost_left) / (dx * dx)\n                    u_new[0] = u[0] + alpha * dt * lap\n            elif i == n - 1:\n                if self.bc_right[0] == 'dirichlet':\n                    u_new[-1] = float(self.bc_right[1])\n                else:\n                    lap = (u_ghost_right - 2.0 * u[-1] + u[-2]) / (dx * dx)\n                    u_new[-1] = u[-1] + alpha * dt * lap\n            else:\n                lap = (u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx)\n                u_new[i] = u[i] + alpha * dt * lap\n        self.u = u_new\n\n    def step(self, dt, enforce_stability=True):\n        \"\"\"Advance a single time step of size dt.\n           If enforce_stability True and dt > stable_dt, raise ValueError.\n        \"\"\"\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError('dt exceeds stable limit: {:.6e} > {:.6e}'.format(dt, stable))\n        if not enforce_stability and dt > stable:\n            dt = stable\n        self._apply_one_step(dt)\n\n    def run(self, total_time, dt, enforce_stability=True):\n        \"\"\"Run until total_time using time step dt.\n           If total_time is not an integer multiple of dt, use a final shorter step.\n        \"\"\"\n        if total_time < 0:\n            raise ValueError('total_time must be >= 0')\n        if total_time == 0:\n            return\n        t = 0.0\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError('dt exceeds stable limit: {:.6e} > {:.6e}'.format(dt, stable))\n        while t + 1e-15 < total_time:\n            step_dt = min(dt, total_time - t)\n            if not enforce_stability and step_dt > stable:\n                step_dt = stable\n            self._apply_one_step(step_dt)\n            t += step_dt\n\n    def state(self):\n        return list(self.u)",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -1,4 +1,3 @@\n-# heat_fd_solver.py\n \"\"\"\n 1D explicit finite-difference heat equation solver.\n Supports Dirichlet and Neumann BCs, stability checks, and small-grid edge cases.\n@@ -9,27 +8,27 @@\n     pass\n \n class HeatSolver1D:\n+\n     def __init__(self, length, nx, alpha, bc_left=('dirichlet', 0.0), bc_right=('dirichlet', 0.0)):\n         if nx < 1:\n-            raise ValueError(\"nx must be >= 1\")\n+            raise ValueError('nx must be >= 1')\n         if length <= 0 and nx > 1:\n-            raise ValueError(\"length must be > 0 for nx>1\")\n+            raise ValueError('length must be > 0 for nx>1')\n         if alpha < 0:\n-            raise ValueError(\"alpha must be non-negative\")\n+            raise ValueError('alpha must be non-negative')\n         self.L = float(length)\n         self.nx = int(nx)\n         self.alpha = float(alpha)\n-        self.dx = None if self.nx == 1 else (self.L / (self.nx - 1))\n+        self.dx = None if self.nx == 1 else self.L / (self.nx + 1)\n         self._validate_bc_tuple(bc_left)\n         self._validate_bc_tuple(bc_right)\n         self.bc_left = bc_left\n         self.bc_right = bc_right\n-        # Initialize state with zeros; user should call set_initial\n         self.u = [0.0 for _ in range(self.nx)]\n \n     @staticmethod\n     def _validate_bc_tuple(bc):\n-        if not (isinstance(bc, tuple) and len(bc) == 2 and bc[0] in ('dirichlet', 'neumann')):\n+        if not (isinstance(bc, tuple) and len(bc) == 2 and (bc[0] in ('dirichlet', 'neumann'))):\n             raise BoundaryConditionError(\"BC must be ('dirichlet'|'neumann', value)\")\n \n     def set_initial(self, u0):\n@@ -41,9 +40,8 @@\n                 self.u = [float(u0(i * self.dx)) for i in range(self.nx)]\n         else:\n             if len(u0) != self.nx:\n-                raise ValueError(\"Initial condition length mismatch\")\n+                raise ValueError('Initial condition length mismatch')\n             self.u = [float(v) for v in u0]\n-        # Enforce Dirichlet BCs on initial state\n         if self.nx >= 1 and self.bc_left[0] == 'dirichlet':\n             self.u[0] = float(self.bc_left[1])\n         if self.nx >= 1 and self.bc_right[0] == 'dirichlet':\n@@ -55,40 +53,33 @@\n             return inf\n         if self.nx == 1:\n             return inf\n-        return (self.dx * self.dx) / (2.0 * self.alpha)\n+        return self.dx * self.dx / (2.0 * self.alpha)\n \n     def _apply_one_step(self, dt):\n         n = self.nx\n         u = self.u\n         if n == 1:\n-            # No spatial second derivative; Dirichlet keeps the prescribed value,\n-            # Neumann has no interior to define curvature, so state remains unchanged.\n             if self.bc_left[0] == 'dirichlet':\n                 self.u[0] = float(self.bc_left[1])\n             return\n         dx = self.dx\n         alpha = self.alpha\n         u_new = [0.0] * n\n-        # Precompute ghost values for Neumann BCs if needed\n-        # Left ghost: (u1 - u_ghost)/(2dx) = q_left -> u_ghost = u1 - 2dx*q_left\n         if self.bc_left[0] == 'neumann':\n             ql = float(self.bc_left[1])\n             u_ghost_left = u[1] - 2.0 * dx * ql\n         else:\n             u_ghost_left = None\n-        # Right ghost: (u_ghost - u_{n-2})/(2dx) = q_right -> u_ghost = u_{n-2} + 2dx*q_right\n         if self.bc_right[0] == 'neumann':\n             qr = float(self.bc_right[1])\n             u_ghost_right = u[-2] + 2.0 * dx * qr\n         else:\n             u_ghost_right = None\n-        # Update each node, using boundary logic\n         for i in range(n):\n             if i == 0:\n                 if self.bc_left[0] == 'dirichlet':\n                     u_new[0] = float(self.bc_left[1])\n                 else:\n-                    # Use ghost value\n                     lap = (u[1] - 2.0 * u[0] + u_ghost_left) / (dx * dx)\n                     u_new[0] = u[0] + alpha * dt * lap\n             elif i == n - 1:\n@@ -108,8 +99,7 @@\n         \"\"\"\n         stable = self.compute_stable_dt()\n         if enforce_stability and dt > stable:\n-            raise ValueError(\"dt exceeds stable limit: {:.6e} > {:.6e}\".format(dt, stable))\n-        # If dt is larger than stable and we don't enforce, we still clamp to stable to avoid blowup\n+            raise ValueError('dt exceeds stable limit: {:.6e} > {:.6e}'.format(dt, stable))\n         if not enforce_stability and dt > stable:\n             dt = stable\n         self._apply_one_step(dt)\n@@ -119,19 +109,19 @@\n            If total_time is not an integer multiple of dt, use a final shorter step.\n         \"\"\"\n         if total_time < 0:\n-            raise ValueError(\"total_time must be >= 0\")\n+            raise ValueError('total_time must be >= 0')\n         if total_time == 0:\n             return\n         t = 0.0\n         stable = self.compute_stable_dt()\n         if enforce_stability and dt > stable:\n-            raise ValueError(\"dt exceeds stable limit: {:.6e} > {:.6e}\".format(dt, stable))\n-        # If not enforcing, we'll clamp each step to stable if needed\n+            raise ValueError('dt exceeds stable limit: {:.6e} > {:.6e}'.format(dt, stable))\n         while t + 1e-15 < total_time:\n             step_dt = min(dt, total_time - t)\n             if not enforce_stability and step_dt > stable:\n                 step_dt = stable\n             self._apply_one_step(step_dt)\n             t += step_dt\n+\n     def state(self):\n-        return list(self.u)\n+        return list(self.u)",
  "conversation": [
    {
      "content": "Domain: Applied Mathematics | Topic: Partial differential equations | Subtopic: Finite difference solver for heat diffusion\nYou are given a scientific code module that implements an explicit finite-difference solver for the 1D heat (diffusion) equation.\nThe scenario: simulate temperature evolution on a 1D rod using forward Euler in time and central differences in space.\nThe solver must support:\n- Dirichlet and Neumann boundary conditions at each end (independently).\n- Stability checks for the explicit scheme (CFL condition).\n- Reasonable behaviour for small grid sizes (including nx==1 and nx==2).\nThe debugging challenge: ensure the numerical implementation correctly applies Neumann BCs via ghost-point extrapolation, enforces (or adapts to) the stability limit dt <= dx^2/(2*alpha), and correctly treats edge grids. Provide a clean, tested implementation that documents non-obvious choices (e.g. single-point domain handling).\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Discretize x into nx grid points over domain length L and compute dx = L/(nx-1) (handle nx==1 specially).\n2. Implement explicit update: u_new[i] = u[i] + alpha*dt/dx^2*(u[i+1] - 2*u[i] + u[i-1]) for interior nodes.\n3. For Dirichlet BCs: enforce boundary nodes to fixed values each step.\n4. For Neumann BCs: use ghost-point technique to express the missing neighbor in terms of the specified derivative (flux) and adjacent interior node, then apply the same Laplacian stencil.\n5. Compute stable dt limit for explicit scheme: dt_max = dx^2/(2*alpha) (alpha>0). If dt > dt_max, either raise (enforce=True) or clamp/adapt dt to dt_max (enforce=False).\n6. Handle edge cases:\n   - nx==1: no spatial second derivative available; Dirichlet sets the single node; Neumann leaves the state unchanged (zero Laplacian).\n   - nx==2: boundary formulas still use ghost points and neighbor values consistently.\n7. Provide unit tests that check stability calculation, Dirichlet steady linear profile, Neumann insulated behaviour, enforcement/clamping of dt, and single-node handling.",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`heat_fd_solver.py`):\n```python\n# heat_fd_solver.py\n\"\"\"\n1D explicit finite-difference heat equation solver.\nSupports Dirichlet and Neumann BCs, stability checks, and small-grid edge cases.\n\"\"\"\nfrom math import inf\n\nclass BoundaryConditionError(ValueError):\n    pass\n\nclass HeatSolver1D:\n    def __init__(self, length, nx, alpha, bc_left=('dirichlet', 0.0), bc_right=('dirichlet', 0.0)):\n        if nx < 1:\n            raise ValueError(\"nx must be >= 1\")\n        if length <= 0 and nx > 1:\n            raise ValueError(\"length must be > 0 for nx>1\")\n        if alpha < 0:\n            raise ValueError(\"alpha must be non-negative\")\n        self.L = float(length)\n        self.nx = int(nx)\n        self.alpha = float(alpha)\n        self.dx = None if self.nx == 1 else (self.L / (self.nx - 1))\n        self._validate_bc_tuple(bc_left)\n        self._validate_bc_tuple(bc_right)\n        self.bc_left = bc_left\n        self.bc_right = bc_right\n        # Initialize state with zeros; user should call set_initial\n        self.u = [0.0 for _ in range(self.nx)]\n\n    @staticmethod\n    def _validate_bc_tuple(bc):\n        if not (isinstance(bc, tuple) and len(bc) == 2 and bc[0] in ('dirichlet', 'neumann')):\n            raise BoundaryConditionError(\"BC must be ('dirichlet'|'neumann', value)\")\n\n    def set_initial(self, u0):\n        \"\"\"Set initial state. Accept list/tuple of length nx or callable x->T.\"\"\"\n        if callable(u0):\n            if self.nx == 1:\n                self.u[0] = float(u0(0.0))\n            else:\n                self.u = [float(u0(i * self.dx)) for i in range(self.nx)]\n        else:\n            if len(u0) != self.nx:\n                raise ValueError(\"Initial condition length mismatch\")\n            self.u = [float(v) for v in u0]\n        # Enforce Dirichlet BCs on initial state\n        if self.nx >= 1 and self.bc_left[0] == 'dirichlet':\n            self.u[0] = float(self.bc_left[1])\n        if self.nx >= 1 and self.bc_right[0] == 'dirichlet':\n            self.u[-1] = float(self.bc_right[1])\n\n    def compute_stable_dt(self):\n        \"\"\"Return maximum stable dt for explicit scheme: dx^2/(2*alpha).\"\"\"\n        if self.alpha == 0.0:\n            return inf\n        if self.nx == 1:\n            return inf\n        return (self.dx * self.dx) / (2.0 * self.alpha)\n\n    def _apply_one_step(self, dt):\n        n = self.nx\n        u = self.u\n        if n == 1:\n            # No spatial second derivative; Dirichlet keeps the prescribed value,\n            # Neumann has no interior to define curvature, so state remains unchanged.\n            if self.bc_left[0] == 'dirichlet':\n                self.u[0] = float(self.bc_left[1])\n            return\n        dx = self.dx\n        alpha = self.alpha\n        u_new = [0.0] * n\n        # Precompute ghost values for Neumann BCs if needed\n        # Left ghost: (u1 - u_ghost)/(2dx) = q_left -> u_ghost = u1 - 2dx*q_left\n        if self.bc_left[0] == 'neumann':\n            ql = float(self.bc_left[1])\n            u_ghost_left = u[1] - 2.0 * dx * ql\n        else:\n            u_ghost_left = None\n        # Right ghost: (u_ghost - u_{n-2})/(2dx) = q_right -> u_ghost = u_{n-2} + 2dx*q_right\n        if self.bc_right[0] == 'neumann':\n            qr = float(self.bc_right[1])\n            u_ghost_right = u[-2] + 2.0 * dx * qr\n        else:\n            u_ghost_right = None\n        # Update each node, using boundary logic\n        for i in range(n):\n            if i == 0:\n                if self.bc_left[0] == 'dirichlet':\n                    u_new[0] = float(self.bc_left[1])\n                else:\n                    # Use ghost value\n                    lap = (u[1] - 2.0 * u[0] + u_ghost_left) / (dx * dx)\n                    u_new[0] = u[0] + alpha * dt * lap\n            elif i == n - 1:\n                if self.bc_right[0] == 'dirichlet':\n                    u_new[-1] = float(self.bc_right[1])\n                else:\n                    lap = (u_ghost_right - 2.0 * u[-1] + u[-2]) / (dx * dx)\n                    u_new[-1] = u[-1] + alpha * dt * lap\n            else:\n                lap = (u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx)\n                u_new[i] = u[i] + alpha * dt * lap\n        self.u = u_new\n\n    def step(self, dt, enforce_stability=True):\n        \"\"\"Advance a single time step of size dt.\n           If enforce_stability True and dt > stable_dt, raise ValueError.\n        \"\"\"\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError(\"dt exceeds stable limit: {:.6e} > {:.6e}\".format(dt, stable))\n        # If dt is larger than stable and we don't enforce, we still clamp to stable to avoid blowup\n        if not enforce_stability and dt > stable:\n            dt = stable\n        self._apply_one_step(dt)\n\n    def run(self, total_time, dt, enforce_stability=True):\n        \"\"\"Run until total_time using time step dt.\n           If total_time is not an integer multiple of dt, use a final shorter step.\n        \"\"\"\n        if total_time < 0:\n            raise ValueError(\"total_time must be >= 0\")\n        if total_time == 0:\n            return\n        t = 0.0\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError(\"dt exceeds stable limit: {:.6e} > {:.6e}\".format(dt, stable))\n        # If not enforcing, we'll clamp each step to stable if needed\n        while t + 1e-15 < total_time:\n            step_dt = min(dt, total_time - t)\n            if not enforce_stability and step_dt > stable:\n                step_dt = stable\n            self._apply_one_step(step_dt)\n            t += step_dt\n    def state(self):\n        return list(self.u)\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\n# test_heat_fd_solver.py\nimport unittest\nfrom math import isclose, inf\nimport heat_fd_solver as solver\n\nclass TestHeatFDSolver(unittest.TestCase):\n    def test_stability_calculation(self):\n        s = solver.HeatSolver1D(length=1.0, nx=11, alpha=0.5)\n        dx = s.dx\n        expected = dx*dx/(2.0*0.5)\n        self.assertAlmostEqual(s.compute_stable_dt(), expected)\n\n    def test_dirichlet_linear_steady(self):\n        # Linear profile between Dirichlet boundaries should be steady (zero Laplacian)\n        s = solver.HeatSolver1D(length=1.0, nx=5, alpha=1.0,\n                               bc_left=('dirichlet', 0.0), bc_right=('dirichlet', 1.0))\n        # linear initial\n        s.set_initial(lambda x: x)\n        stable = s.compute_stable_dt()\n        s.step(dt=stable/2.0, enforce_stability=True)\n        final = s.state()\n        # each interior point should remain close to initial linear values\n        expected = [i * (1.0/4.0) for i in range(5)]\n        for a, b in zip(final, expected):\n            self.assertTrue(isclose(a, b, rel_tol=1e-9, abs_tol=1e-9))\n\n    def test_neumann_insulated_preserves_uniform(self):\n        # Insulated (zero flux) both ends; uniform initial temperature should remain\n        s = solver.HeatSolver1D(length=1.0, nx=6, alpha=0.7,\n                               bc_left=('neumann', 0.0), bc_right=('neumann', 0.0))\n        s.set_initial([5.0] * 6)\n        s.run(total_time=0.1, dt=min(1e-3, s.compute_stable_dt()), enforce_stability=False)\n        self.assertTrue(all(isclose(val, 5.0, rel_tol=1e-9, abs_tol=1e-9) for val in s.state()))\n\n    def test_enforce_stability_behavior(self):\n        s = solver.HeatSolver1D(length=1.0, nx=10, alpha=1.0)\n        dt = s.compute_stable_dt() * 1.2\n        with self.assertRaises(ValueError):\n            s.step(dt=dt, enforce_stability=True)\n        # If not enforcing, step should clamp to stable and not raise\n        s.set_initial([0.0]*10)\n        s.step(dt=dt, enforce_stability=False)  # should not raise\n\n    def test_single_node_dirichlet(self):\n        # nx==1 with Dirichlet should set and keep the BC value\n        s = solver.HeatSolver1D(length=1.0, nx=1, alpha=1.0, bc_left=('dirichlet', 42.0), bc_right=('dirichlet', 42.0))\n        s.set_initial([0.0])\n        s.step(dt=0.1)\n        self.assertEqual(s.state(), [42.0])\n\nif __name__ == '__main__':\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"\n1D explicit finite-difference heat equation solver.\nSupports Dirichlet and Neumann BCs, stability checks, and small-grid edge cases.\n\"\"\"\nfrom math import inf\n\nclass BoundaryConditionError(ValueError):\n    pass\n\nclass HeatSolver1D:\n\n    def __init__(self, length, nx, alpha, bc_left=('dirichlet', 0.0), bc_right=('dirichlet', 0.0)):\n        if nx < 1:\n            raise ValueError('nx must be >= 1')\n        if length <= 0 and nx > 1:\n            raise ValueError('length must be > 0 for nx>1')\n        if alpha < 0:\n            raise ValueError('alpha must be non-negative')\n        self.L = float(length)\n        self.nx = int(nx)\n        self.alpha = float(alpha)\n        self.dx = None if self.nx == 1 else self.L / (self.nx + 1)\n        self._validate_bc_tuple(bc_left)\n        self._validate_bc_tuple(bc_right)\n        self.bc_left = bc_left\n        self.bc_right = bc_right\n        self.u = [0.0 for _ in range(self.nx)]\n\n    @staticmethod\n    def _validate_bc_tuple(bc):\n        if not (isinstance(bc, tuple) and len(bc) == 2 and (bc[0] in ('dirichlet', 'neumann'))):\n            raise BoundaryConditionError(\"BC must be ('dirichlet'|'neumann', value)\")\n\n    def set_initial(self, u0):\n        \"\"\"Set initial state. Accept list/tuple of length nx or callable x->T.\"\"\"\n        if callable(u0):\n            if self.nx == 1:\n                self.u[0] = float(u0(0.0))\n            else:\n                self.u = [float(u0(i * self.dx)) for i in range(self.nx)]\n        else:\n            if len(u0) != self.nx:\n                raise ValueError('Initial condition length mismatch')\n            self.u = [float(v) for v in u0]\n        if self.nx >= 1 and self.bc_left[0] == 'dirichlet':\n            self.u[0] = float(self.bc_left[1])\n        if self.nx >= 1 and self.bc_right[0] == 'dirichlet':\n            self.u[-1] = float(self.bc_right[1])\n\n    def compute_stable_dt(self):\n        \"\"\"Return maximum stable dt for explicit scheme: dx^2/(2*alpha).\"\"\"\n        if self.alpha == 0.0:\n            return inf\n        if self.nx == 1:\n            return inf\n        return self.dx * self.dx / (2.0 * self.alpha)\n\n    def _apply_one_step(self, dt):\n        n = self.nx\n        u = self.u\n        if n == 1:\n            if self.bc_left[0] == 'dirichlet':\n                self.u[0] = float(self.bc_left[1])\n            return\n        dx = self.dx\n        alpha = self.alpha\n        u_new = [0.0] * n\n        if self.bc_left[0] == 'neumann':\n            ql = float(self.bc_left[1])\n            u_ghost_left = u[1] - 2.0 * dx * ql\n        else:\n            u_ghost_left = None\n        if self.bc_right[0] == 'neumann':\n            qr = float(self.bc_right[1])\n            u_ghost_right = u[-2] + 2.0 * dx * qr\n        else:\n            u_ghost_right = None\n        for i in range(n):\n            if i == 0:\n                if self.bc_left[0] == 'dirichlet':\n                    u_new[0] = float(self.bc_left[1])\n                else:\n                    lap = (u[1] - 2.0 * u[0] + u_ghost_left) / (dx * dx)\n                    u_new[0] = u[0] + alpha * dt * lap\n            elif i == n - 1:\n                if self.bc_right[0] == 'dirichlet':\n                    u_new[-1] = float(self.bc_right[1])\n                else:\n                    lap = (u_ghost_right - 2.0 * u[-1] + u[-2]) / (dx * dx)\n                    u_new[-1] = u[-1] + alpha * dt * lap\n            else:\n                lap = (u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx)\n                u_new[i] = u[i] + alpha * dt * lap\n        self.u = u_new\n\n    def step(self, dt, enforce_stability=True):\n        \"\"\"Advance a single time step of size dt.\n           If enforce_stability True and dt > stable_dt, raise ValueError.\n        \"\"\"\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError('dt exceeds stable limit: {:.6e} > {:.6e}'.format(dt, stable))\n        if not enforce_stability and dt > stable:\n            dt = stable\n        self._apply_one_step(dt)\n\n    def run(self, total_time, dt, enforce_stability=True):\n        \"\"\"Run until total_time using time step dt.\n           If total_time is not an integer multiple of dt, use a final shorter step.\n        \"\"\"\n        if total_time < 0:\n            raise ValueError('total_time must be >= 0')\n        if total_time == 0:\n            return\n        t = 0.0\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError('dt exceeds stable limit: {:.6e} > {:.6e}'.format(dt, stable))\n        while t + 1e-15 < total_time:\n            step_dt = min(dt, total_time - t)\n            if not enforce_stability and step_dt > stable:\n                step_dt = stable\n            self._apply_one_step(step_dt)\n            t += step_dt\n\n    def state(self):\n        return list(self.u)\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_dirichlet_linear_steady (test_heat_fd_solver.TestHeatFDSolver.test_dirichlet_linear_steady) ... FAIL\ntest_enforce_stability_behavior (test_heat_fd_solver.TestHeatFDSolver.test_enforce_stability_behavior) ... ok\ntest_neumann_insulated_preserves_uniform (test_heat_fd_solver.TestHeatFDSolver.test_neumann_insulated_preserves_uniform) ... ok\ntest_single_node_dirichlet (test_heat_fd_solver.TestHeatFDSolver.test_single_node_dirichlet) ... ok\ntest_stability_calculation (test_heat_fd_solver.TestHeatFDSolver.test_stability_calculation) ... ok\n\n======================================================================\nFAIL: test_dirichlet_linear_steady (test_heat_fd_solver.TestHeatFDSolver.test_dirichlet_linear_steady)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwc07osh5/test_heat_fd_solver.py\", line 25, in test_dirichlet_linear_steady\n    self.assertTrue(isclose(a, b, rel_tol=1e-9, abs_tol=1e-9))\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 5 tests in 0.001s\n\nFAILED (failures=1)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "# heat_fd_solver.py\n\"\"\"\n1D explicit finite-difference heat equation solver.\nSupports Dirichlet and Neumann BCs, stability checks, and small-grid edge cases.\n\"\"\"\nfrom math import inf\n\nclass BoundaryConditionError(ValueError):\n    pass\n\nclass HeatSolver1D:\n    def __init__(self, length, nx, alpha, bc_left=('dirichlet', 0.0), bc_right=('dirichlet', 0.0)):\n        if nx < 1:\n            raise ValueError(\"nx must be >= 1\")\n        if length <= 0 and nx > 1:\n            raise ValueError(\"length must be > 0 for nx>1\")\n        if alpha < 0:\n            raise ValueError(\"alpha must be non-negative\")\n        self.L = float(length)\n        self.nx = int(nx)\n        self.alpha = float(alpha)\n        self.dx = None if self.nx == 1 else (self.L / (self.nx - 1))\n        self._validate_bc_tuple(bc_left)\n        self._validate_bc_tuple(bc_right)\n        self.bc_left = bc_left\n        self.bc_right = bc_right\n        # Initialize state with zeros; user should call set_initial\n        self.u = [0.0 for _ in range(self.nx)]\n\n    @staticmethod\n    def _validate_bc_tuple(bc):\n        if not (isinstance(bc, tuple) and len(bc) == 2 and bc[0] in ('dirichlet', 'neumann')):\n            raise BoundaryConditionError(\"BC must be ('dirichlet'|'neumann', value)\")\n\n    def set_initial(self, u0):\n        \"\"\"Set initial state. Accept list/tuple of length nx or callable x->T.\"\"\"\n        if callable(u0):\n            if self.nx == 1:\n                self.u[0] = float(u0(0.0))\n            else:\n                self.u = [float(u0(i * self.dx)) for i in range(self.nx)]\n        else:\n            if len(u0) != self.nx:\n                raise ValueError(\"Initial condition length mismatch\")\n            self.u = [float(v) for v in u0]\n        # Enforce Dirichlet BCs on initial state\n        if self.nx >= 1 and self.bc_left[0] == 'dirichlet':\n            self.u[0] = float(self.bc_left[1])\n        if self.nx >= 1 and self.bc_right[0] == 'dirichlet':\n            self.u[-1] = float(self.bc_right[1])\n\n    def compute_stable_dt(self):\n        \"\"\"Return maximum stable dt for explicit scheme: dx^2/(2*alpha).\"\"\"\n        if self.alpha == 0.0:\n            return inf\n        if self.nx == 1:\n            return inf\n        return (self.dx * self.dx) / (2.0 * self.alpha)\n\n    def _apply_one_step(self, dt):\n        n = self.nx\n        u = self.u\n        if n == 1:\n            # No spatial second derivative; Dirichlet keeps the prescribed value,\n            # Neumann has no interior to define curvature, so state remains unchanged.\n            if self.bc_left[0] == 'dirichlet':\n                self.u[0] = float(self.bc_left[1])\n            return\n        dx = self.dx\n        alpha = self.alpha\n        u_new = [0.0] * n\n        # Precompute ghost values for Neumann BCs if needed\n        # Left ghost: (u1 - u_ghost)/(2dx) = q_left -> u_ghost = u1 - 2dx*q_left\n        if self.bc_left[0] == 'neumann':\n            ql = float(self.bc_left[1])\n            u_ghost_left = u[1] - 2.0 * dx * ql\n        else:\n            u_ghost_left = None\n        # Right ghost: (u_ghost - u_{n-2})/(2dx) = q_right -> u_ghost = u_{n-2} + 2dx*q_right\n        if self.bc_right[0] == 'neumann':\n            qr = float(self.bc_right[1])\n            u_ghost_right = u[-2] + 2.0 * dx * qr\n        else:\n            u_ghost_right = None\n        # Update each node, using boundary logic\n        for i in range(n):\n            if i == 0:\n                if self.bc_left[0] == 'dirichlet':\n                    u_new[0] = float(self.bc_left[1])\n                else:\n                    # Use ghost value\n                    lap = (u[1] - 2.0 * u[0] + u_ghost_left) / (dx * dx)\n                    u_new[0] = u[0] + alpha * dt * lap\n            elif i == n - 1:\n                if self.bc_right[0] == 'dirichlet':\n                    u_new[-1] = float(self.bc_right[1])\n                else:\n                    lap = (u_ghost_right - 2.0 * u[-1] + u[-2]) / (dx * dx)\n                    u_new[-1] = u[-1] + alpha * dt * lap\n            else:\n                lap = (u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx)\n                u_new[i] = u[i] + alpha * dt * lap\n        self.u = u_new\n\n    def step(self, dt, enforce_stability=True):\n        \"\"\"Advance a single time step of size dt.\n           If enforce_stability True and dt > stable_dt, raise ValueError.\n        \"\"\"\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError(\"dt exceeds stable limit: {:.6e} > {:.6e}\".format(dt, stable))\n        # If dt is larger than stable and we don't enforce, we still clamp to stable to avoid blowup\n        if not enforce_stability and dt > stable:\n            dt = stable\n        self._apply_one_step(dt)\n\n    def run(self, total_time, dt, enforce_stability=True):\n        \"\"\"Run until total_time using time step dt.\n           If total_time is not an integer multiple of dt, use a final shorter step.\n        \"\"\"\n        if total_time < 0:\n            raise ValueError(\"total_time must be >= 0\")\n        if total_time == 0:\n            return\n        t = 0.0\n        stable = self.compute_stable_dt()\n        if enforce_stability and dt > stable:\n            raise ValueError(\"dt exceeds stable limit: {:.6e} > {:.6e}\".format(dt, stable))\n        # If not enforcing, we'll clamp each step to stable if needed\n        while t + 1e-15 < total_time:\n            step_dt = min(dt, total_time - t)\n            if not enforce_stability and step_dt > stable:\n                step_dt = stable\n            self._apply_one_step(step_dt)\n            t += step_dt\n    def state(self):\n        return list(self.u)\n",
  "domain": "Applied Mathematics",
  "failing_output": "test_dirichlet_linear_steady (test_heat_fd_solver.TestHeatFDSolver.test_dirichlet_linear_steady) ... FAIL\ntest_enforce_stability_behavior (test_heat_fd_solver.TestHeatFDSolver.test_enforce_stability_behavior) ... ok\ntest_neumann_insulated_preserves_uniform (test_heat_fd_solver.TestHeatFDSolver.test_neumann_insulated_preserves_uniform) ... ok\ntest_single_node_dirichlet (test_heat_fd_solver.TestHeatFDSolver.test_single_node_dirichlet) ... ok\ntest_stability_calculation (test_heat_fd_solver.TestHeatFDSolver.test_stability_calculation) ... ok\n\n======================================================================\nFAIL: test_dirichlet_linear_steady (test_heat_fd_solver.TestHeatFDSolver.test_dirichlet_linear_steady)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwc07osh5/test_heat_fd_solver.py\", line 25, in test_dirichlet_linear_steady\n    self.assertTrue(isclose(a, b, rel_tol=1e-9, abs_tol=1e-9))\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 5 tests in 0.001s\n\nFAILED (failures=1)",
  "module_name": "heat_fd_solver",
  "problem_description": "You are given a scientific code module that implements an explicit finite-difference solver for the 1D heat (diffusion) equation.\nThe scenario: simulate temperature evolution on a 1D rod using forward Euler in time and central differences in space.\nThe solver must support:\n- Dirichlet and Neumann boundary conditions at each end (independently).\n- Stability checks for the explicit scheme (CFL condition).\n- Reasonable behaviour for small grid sizes (including nx==1 and nx==2).\nThe debugging challenge: ensure the numerical implementation correctly applies Neumann BCs via ghost-point extrapolation, enforces (or adapts to) the stability limit dt <= dx^2/(2*alpha), and correctly treats edge grids. Provide a clean, tested implementation that documents non-obvious choices (e.g. single-point domain handling).\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Discretize x into nx grid points over domain length L and compute dx = L/(nx-1) (handle nx==1 specially).\n2. Implement explicit update: u_new[i] = u[i] + alpha*dt/dx^2*(u[i+1] - 2*u[i] + u[i-1]) for interior nodes.\n3. For Dirichlet BCs: enforce boundary nodes to fixed values each step.\n4. For Neumann BCs: use ghost-point technique to express the missing neighbor in terms of the specified derivative (flux) and adjacent interior node, then apply the same Laplacian stencil.\n5. Compute stable dt limit for explicit scheme: dt_max = dx^2/(2*alpha) (alpha>0). If dt > dt_max, either raise (enforce=True) or clamp/adapt dt to dt_max (enforce=False).\n6. Handle edge cases:\n   - nx==1: no spatial second derivative available; Dirichlet sets the single node; Neumann leaves the state unchanged (zero Laplacian).\n   - nx==2: boundary formulas still use ghost points and neighbor values consistently.\n7. Provide unit tests that check stability calculation, Dirichlet steady linear profile, Neumann insulated behaviour, enforcement/clamping of dt, and single-node handling.\n",
  "subtopic": "Finite difference solver for heat diffusion",
  "summary": "A 1D explicit finite-difference heat equation solver with Dirichlet/Neumann boundary handling and stability enforcement.",
  "topic": "Partial differential equations",
  "unit_tests": "# test_heat_fd_solver.py\nimport unittest\nfrom math import isclose, inf\nimport heat_fd_solver as solver\n\nclass TestHeatFDSolver(unittest.TestCase):\n    def test_stability_calculation(self):\n        s = solver.HeatSolver1D(length=1.0, nx=11, alpha=0.5)\n        dx = s.dx\n        expected = dx*dx/(2.0*0.5)\n        self.assertAlmostEqual(s.compute_stable_dt(), expected)\n\n    def test_dirichlet_linear_steady(self):\n        # Linear profile between Dirichlet boundaries should be steady (zero Laplacian)\n        s = solver.HeatSolver1D(length=1.0, nx=5, alpha=1.0,\n                               bc_left=('dirichlet', 0.0), bc_right=('dirichlet', 1.0))\n        # linear initial\n        s.set_initial(lambda x: x)\n        stable = s.compute_stable_dt()\n        s.step(dt=stable/2.0, enforce_stability=True)\n        final = s.state()\n        # each interior point should remain close to initial linear values\n        expected = [i * (1.0/4.0) for i in range(5)]\n        for a, b in zip(final, expected):\n            self.assertTrue(isclose(a, b, rel_tol=1e-9, abs_tol=1e-9))\n\n    def test_neumann_insulated_preserves_uniform(self):\n        # Insulated (zero flux) both ends; uniform initial temperature should remain\n        s = solver.HeatSolver1D(length=1.0, nx=6, alpha=0.7,\n                               bc_left=('neumann', 0.0), bc_right=('neumann', 0.0))\n        s.set_initial([5.0] * 6)\n        s.run(total_time=0.1, dt=min(1e-3, s.compute_stable_dt()), enforce_stability=False)\n        self.assertTrue(all(isclose(val, 5.0, rel_tol=1e-9, abs_tol=1e-9) for val in s.state()))\n\n    def test_enforce_stability_behavior(self):\n        s = solver.HeatSolver1D(length=1.0, nx=10, alpha=1.0)\n        dt = s.compute_stable_dt() * 1.2\n        with self.assertRaises(ValueError):\n            s.step(dt=dt, enforce_stability=True)\n        # If not enforcing, step should clamp to stable and not raise\n        s.set_initial([0.0]*10)\n        s.step(dt=dt, enforce_stability=False)  # should not raise\n\n    def test_single_node_dirichlet(self):\n        # nx==1 with Dirichlet should set and keep the BC value\n        s = solver.HeatSolver1D(length=1.0, nx=1, alpha=1.0, bc_left=('dirichlet', 42.0), bc_right=('dirichlet', 42.0))\n        s.set_initial([0.0])\n        s.step(dt=0.1)\n        self.assertEqual(s.state(), [42.0])\n\nif __name__ == '__main__':\n    unittest.main()"
}