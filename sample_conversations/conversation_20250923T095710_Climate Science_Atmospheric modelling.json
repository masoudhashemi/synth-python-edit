{
  "buggy_code": "\"\"\"\nradiative_forcing_aggregator.py\nSimple radiative forcing aggregation utilities for debugging and testing.\n\"\"\"\nfrom math import log\nfrom typing import Dict, Tuple, List\n\nclass ForcingComponent:\n    \"\"\"\n    Represents a single radiative forcing component.\n\n    gas_type: 'CO2', 'CH4', or 'N2O' (case-sensitive in this simple model)\n    concentration and baseline are in the same units (ppm for CO2, ppb for trace gases).\n    \"\"\"\n    TRACE_COEFFS = {'CH4': 0.0002, 'N2O': 0.0001}\n\n    def __init__(self, name: str, gas_type: str, concentration: float, baseline: float):\n        self.name = name\n        self.gas_type = gas_type\n        self.concentration = concentration\n        self.baseline = baseline\n\n    def compute_forcing(self) -> float:\n        \"\"\"\n        Compute radiative forcing for this component.\n\n        - CO2: Myhre approximation F = 5.35 * ln(C / C0). Baseline must be > 0.\n        - CH4, N2O: linear approx F = coeff * (C - C0).\n\n        Raises ValueError for invalid inputs (e.g., baseline <= 0 for CO2, negative concentrations).\n        \"\"\"\n        if self.concentration is None or self.baseline is None:\n            raise ValueError('Concentration and baseline must be provided')\n        if self.concentration < 0 or self.baseline < 0:\n            raise ValueError('Concentrations and baseline must be non-negative')\n        if self.gas_type == 'CO2':\n            if self.baseline <= 0:\n                raise ValueError('CO2 baseline must be > 0 for logarithmic formula')\n            return 5.35 * log(self.concentration / self.baseline)\n        elif self.gas_type in self.TRACE_COEFFS:\n            coeff = self.TRACE_COEFFS[self.gas_type]\n            return coeff * (self.concentration + self.baseline)\n        else:\n            raise ValueError(f'Unsupported gas_type: {self.gas_type}')\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates multiple ForcingComponent instances with optional pairwise overlaps.\n\n    overlap_map keys are frozenset({'name1','name2'}) -> fraction in [0,1].\n    The overlap model subtracts overlap_fraction * min(|F_i|, |F_j|) for each pair\n    when the two forcings have the same sign.\n    \"\"\"\n\n    def __init__(self):\n        self.components: Dict[str, ForcingComponent] = {}\n        self.overlaps: Dict[frozenset, float] = {}\n\n    def add_component(self, component: ForcingComponent):\n        if component.name in self.components:\n            raise ValueError(f'Component with name {component.name} already exists')\n        self.components[component.name] = component\n\n    def set_overlap(self, name1: str, name2: str, fraction: float):\n        if name1 == name2:\n            raise ValueError('Overlap must be between two distinct components')\n        if not 0.0 <= fraction <= 1.0:\n            raise ValueError('Overlap fraction must be between 0 and 1')\n        key = frozenset([name1, name2])\n        self.overlaps[key] = fraction\n\n    def _compute_individual_forcings(self) -> Dict[str, float]:\n        forcings = {}\n        for name, comp in self.components.items():\n            forcings[name] = comp.compute_forcing()\n        return forcings\n\n    def aggregate(self) -> float:\n        \"\"\"\n        Aggregate all components into a single net radiative forcing (W/m2).\n\n        Steps:\n        1. Sum individual forcings.\n        2. For each unordered pair with an overlap fraction, if they have the same sign,\n           subtract overlap_fraction * min(|F_i|, |F_j|).\n        \"\"\"\n        forcings = self._compute_individual_forcings()\n        total = sum(forcings.values())\n        seen = set()\n        for key, frac in self.overlaps.items():\n            names = tuple(key)\n            if len(names) != 2:\n                continue\n            a, b = names\n            if a not in forcings or b not in forcings:\n                continue\n            fi = forcings[a]\n            fj = forcings[b]\n            if fi == 0 or fj == 0:\n                continue\n            if fi > 0 and fj > 0 or (fi < 0 and fj < 0):\n                adjustment = frac * min(abs(fi), abs(fj))\n                total -= adjustment\n        return total\n\n    def aggregate_area_weighted(self, regional_components: Dict[str, List[ForcingComponent]], area_weights: Dict[str, float]) -> float:\n        \"\"\"\n        Compute area-weighted global mean forcing.\n\n        regional_components: mapping region_name -> list of ForcingComponent (names must be unique per region)\n        area_weights: mapping region_name -> area (units arbitrary); normalization is performed internally.\n\n        Returns the normalized area-weighted mean. Raises ValueError on zero total area.\n        \"\"\"\n        if not regional_components:\n            return 0.0\n        regional_results: Dict[str, float] = {}\n        for region, comps in regional_components.items():\n            agg = RadiativeForcingAggregator()\n            for i, comp in enumerate(comps):\n                qualified = ForcingComponent(f'{region}::{comp.name}', comp.gas_type, comp.concentration, comp.baseline)\n                agg.add_component(qualified)\n            regional_results[region] = agg.aggregate()\n        total_area = sum((area_weights.get(r, 0.0) for r in regional_results.keys()))\n        if total_area == 0:\n            raise ValueError('Total area must be > 0 for area-weighted aggregation')\n        weighted_sum = sum((regional_results[r] * area_weights.get(r, 0.0) for r in regional_results.keys()))\n        return weighted_sum / total_area",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -4,7 +4,6 @@\n \"\"\"\n from math import log\n from typing import Dict, Tuple, List\n-\n \n class ForcingComponent:\n     \"\"\"\n@@ -13,10 +12,7 @@\n     gas_type: 'CO2', 'CH4', or 'N2O' (case-sensitive in this simple model)\n     concentration and baseline are in the same units (ppm for CO2, ppb for trace gases).\n     \"\"\"\n-    TRACE_COEFFS = {\n-        'CH4': 0.0002,   # W/m2 per ppb (approximate linear sensitivity for exercise)\n-        'N2O': 0.0001,   # W/m2 per ppb (approximate)\n-    }\n+    TRACE_COEFFS = {'CH4': 0.0002, 'N2O': 0.0001}\n \n     def __init__(self, name: str, gas_type: str, concentration: float, baseline: float):\n         self.name = name\n@@ -34,21 +30,18 @@\n         Raises ValueError for invalid inputs (e.g., baseline <= 0 for CO2, negative concentrations).\n         \"\"\"\n         if self.concentration is None or self.baseline is None:\n-            raise ValueError(\"Concentration and baseline must be provided\")\n+            raise ValueError('Concentration and baseline must be provided')\n         if self.concentration < 0 or self.baseline < 0:\n-            raise ValueError(\"Concentrations and baseline must be non-negative\")\n-\n+            raise ValueError('Concentrations and baseline must be non-negative')\n         if self.gas_type == 'CO2':\n             if self.baseline <= 0:\n-                raise ValueError(\"CO2 baseline must be > 0 for logarithmic formula\")\n-            # Myhre et al. (simplified)\n+                raise ValueError('CO2 baseline must be > 0 for logarithmic formula')\n             return 5.35 * log(self.concentration / self.baseline)\n         elif self.gas_type in self.TRACE_COEFFS:\n             coeff = self.TRACE_COEFFS[self.gas_type]\n-            return coeff * (self.concentration - self.baseline)\n+            return coeff * (self.concentration + self.baseline)\n         else:\n-            raise ValueError(f\"Unsupported gas_type: {self.gas_type}\")\n-\n+            raise ValueError(f'Unsupported gas_type: {self.gas_type}')\n \n class RadiativeForcingAggregator:\n     \"\"\"\n@@ -58,20 +51,21 @@\n     The overlap model subtracts overlap_fraction * min(|F_i|, |F_j|) for each pair\n     when the two forcings have the same sign.\n     \"\"\"\n+\n     def __init__(self):\n         self.components: Dict[str, ForcingComponent] = {}\n         self.overlaps: Dict[frozenset, float] = {}\n \n     def add_component(self, component: ForcingComponent):\n         if component.name in self.components:\n-            raise ValueError(f\"Component with name {component.name} already exists\")\n+            raise ValueError(f'Component with name {component.name} already exists')\n         self.components[component.name] = component\n \n     def set_overlap(self, name1: str, name2: str, fraction: float):\n         if name1 == name2:\n-            raise ValueError(\"Overlap must be between two distinct components\")\n-        if not (0.0 <= fraction <= 1.0):\n-            raise ValueError(\"Overlap fraction must be between 0 and 1\")\n+            raise ValueError('Overlap must be between two distinct components')\n+        if not 0.0 <= fraction <= 1.0:\n+            raise ValueError('Overlap fraction must be between 0 and 1')\n         key = frozenset([name1, name2])\n         self.overlaps[key] = fraction\n \n@@ -92,8 +86,6 @@\n         \"\"\"\n         forcings = self._compute_individual_forcings()\n         total = sum(forcings.values())\n-\n-        # apply pairwise overlaps\n         seen = set()\n         for key, frac in self.overlaps.items():\n             names = tuple(key)\n@@ -101,21 +93,17 @@\n                 continue\n             a, b = names\n             if a not in forcings or b not in forcings:\n-                # ignore overlaps that reference missing components\n                 continue\n             fi = forcings[a]\n             fj = forcings[b]\n             if fi == 0 or fj == 0:\n                 continue\n-            # Only apply overlap adjustment when forcings have same sign\n-            if (fi > 0 and fj > 0) or (fi < 0 and fj < 0):\n+            if fi > 0 and fj > 0 or (fi < 0 and fj < 0):\n                 adjustment = frac * min(abs(fi), abs(fj))\n-                # subtract adjustment from total (overlap reduces double-counting)\n                 total -= adjustment\n         return total\n \n-    def aggregate_area_weighted(self, regional_components: Dict[str, List[ForcingComponent]],\n-                                area_weights: Dict[str, float]) -> float:\n+    def aggregate_area_weighted(self, regional_components: Dict[str, List[ForcingComponent]], area_weights: Dict[str, float]) -> float:\n         \"\"\"\n         Compute area-weighted global mean forcing.\n \n@@ -126,21 +114,15 @@\n         \"\"\"\n         if not regional_components:\n             return 0.0\n-        # compute per-region aggregates\n         regional_results: Dict[str, float] = {}\n         for region, comps in regional_components.items():\n             agg = RadiativeForcingAggregator()\n-            # add components with unique names qualified by region to avoid name collision with overlaps\n             for i, comp in enumerate(comps):\n-                # clone with region-qualified name; overlaps are assumed local to region in this method\n-                qualified = ForcingComponent(f\"{region}::{comp.name}\", comp.gas_type, comp.concentration, comp.baseline)\n+                qualified = ForcingComponent(f'{region}::{comp.name}', comp.gas_type, comp.concentration, comp.baseline)\n                 agg.add_component(qualified)\n-            # no overlaps across regions in this simple global routine\n             regional_results[region] = agg.aggregate()\n-\n-        total_area = sum(area_weights.get(r, 0.0) for r in regional_results.keys())\n+        total_area = sum((area_weights.get(r, 0.0) for r in regional_results.keys()))\n         if total_area == 0:\n-            raise ValueError(\"Total area must be > 0 for area-weighted aggregation\")\n-\n-        weighted_sum = sum(regional_results[r] * area_weights.get(r, 0.0) for r in regional_results.keys())\n-        return weighted_sum / total_area\n+            raise ValueError('Total area must be > 0 for area-weighted aggregation')\n+        weighted_sum = sum((regional_results[r] * area_weights.get(r, 0.0) for r in regional_results.keys()))\n+        return weighted_sum / total_area",
  "conversation": [
    {
      "content": "Domain: Climate Science | Topic: Atmospheric modelling | Subtopic: Radiative forcing aggregation\nYou are given a small radiative forcing aggregation library skeleton used in an atmospheric model. The library must compute per-component radiative forcing for common greenhouse gases, combine those components taking into account pairwise overlaps, and compute area-weighted global aggregates from regional contributions.\n\nRequirements and scientific context:\n- CO2 forcing should use the Myhre et al. logarithmic approximation: F = 5.35 * ln(C / C0).\n- Trace gases (e.g. CH4, N2O) are represented with linear approximations around contemporary concentrations: F = coeff * (C - C0). Coefficients are fixed, approximate sensitivities (documented in the code). This is acceptable for this debugging exercise.\n- Pairwise overlaps between components (e.g. spectral overlap between CH4 and N2O) reduce the naive sum of forcings. For simplicity, overlaps are represented by symmetric pairwise fractions in [0,1]. When two forcings have the same sign (both positive or both negative), the overlap reduces the total by overlap_fraction * min(|F_i|, |F_j|). If signs differ, overlaps are ignored (no cancellation assumed by overlap model).\n- Regional aggregation: compute a regional aggregate using the same overlap logic, then compute a global area-weighted mean across regions. Area weights need not be normalized \u2014 the routine must normalize internally and raise an error for zero total area.\n\nThe provided code must:\n- Provide cooperating classes/functions to represent components and perform aggregation.\n- Validate inputs (e.g., positive concentrations where required, non-zero baseline for logarithms).\n- Be deterministic and use only the standard library.\n- Include docstrings/comments explaining assumptions and non-obvious logic.\n\nYour task is to inspect and, if needed, fix or implement the module so that it correctly implements these behaviors and passes the unit tests that accompany it. The tests include happy paths (CO2 doubling, simple sums) and edge conditions (overlap handling, zero area, invalid baselines).\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Implement a ForcingComponent class that encapsulates a single gas/component, its concentration and baseline, and a method to compute its radiative forcing using gas-specific formulae (log for CO2, linear for trace gases).\n2. Implement a RadiativeForcingAggregator class that stores components and pairwise overlap fractions, validates inputs, and aggregates forcings by summing individual forcings and subtracting pairwise overlap adjustments following the stated rule (only when signs match).\n3. Provide an area-weighted aggregation method that computes regional aggregates then returns a normalized global mean; handle zero total-area as an error.\n4. Write robust unit tests that verify CO2 logarithmic forcing, simple aggregation without overlaps, aggregation with overlaps, mixed-sign behavior, area-weighted averaging, and error conditions (e.g., zero baseline for CO2, zero total area).",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`radiative_forcing_aggregator.py`):\n```python\n\"\"\"\nradiative_forcing_aggregator.py\nSimple radiative forcing aggregation utilities for debugging and testing.\n\"\"\"\nfrom math import log\nfrom typing import Dict, Tuple, List\n\n\nclass ForcingComponent:\n    \"\"\"\n    Represents a single radiative forcing component.\n\n    gas_type: 'CO2', 'CH4', or 'N2O' (case-sensitive in this simple model)\n    concentration and baseline are in the same units (ppm for CO2, ppb for trace gases).\n    \"\"\"\n    TRACE_COEFFS = {\n        'CH4': 0.0002,   # W/m2 per ppb (approximate linear sensitivity for exercise)\n        'N2O': 0.0001,   # W/m2 per ppb (approximate)\n    }\n\n    def __init__(self, name: str, gas_type: str, concentration: float, baseline: float):\n        self.name = name\n        self.gas_type = gas_type\n        self.concentration = concentration\n        self.baseline = baseline\n\n    def compute_forcing(self) -> float:\n        \"\"\"\n        Compute radiative forcing for this component.\n\n        - CO2: Myhre approximation F = 5.35 * ln(C / C0). Baseline must be > 0.\n        - CH4, N2O: linear approx F = coeff * (C - C0).\n\n        Raises ValueError for invalid inputs (e.g., baseline <= 0 for CO2, negative concentrations).\n        \"\"\"\n        if self.concentration is None or self.baseline is None:\n            raise ValueError(\"Concentration and baseline must be provided\")\n        if self.concentration < 0 or self.baseline < 0:\n            raise ValueError(\"Concentrations and baseline must be non-negative\")\n\n        if self.gas_type == 'CO2':\n            if self.baseline <= 0:\n                raise ValueError(\"CO2 baseline must be > 0 for logarithmic formula\")\n            # Myhre et al. (simplified)\n            return 5.35 * log(self.concentration / self.baseline)\n        elif self.gas_type in self.TRACE_COEFFS:\n            coeff = self.TRACE_COEFFS[self.gas_type]\n            return coeff * (self.concentration - self.baseline)\n        else:\n            raise ValueError(f\"Unsupported gas_type: {self.gas_type}\")\n\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates multiple ForcingComponent instances with optional pairwise overlaps.\n\n    overlap_map keys are frozenset({'name1','name2'}) -> fraction in [0,1].\n    The overlap model subtracts overlap_fraction * min(|F_i|, |F_j|) for each pair\n    when the two forcings have the same sign.\n    \"\"\"\n    def __init__(self):\n        self.components: Dict[str, ForcingComponent] = {}\n        self.overlaps: Dict[frozenset, float] = {}\n\n    def add_component(self, component: ForcingComponent):\n        if component.name in self.components:\n            raise ValueError(f\"Component with name {component.name} already exists\")\n        self.components[component.name] = component\n\n    def set_overlap(self, name1: str, name2: str, fraction: float):\n        if name1 == name2:\n            raise ValueError(\"Overlap must be between two distinct components\")\n        if not (0.0 <= fraction <= 1.0):\n            raise ValueError(\"Overlap fraction must be between 0 and 1\")\n        key = frozenset([name1, name2])\n        self.overlaps[key] = fraction\n\n    def _compute_individual_forcings(self) -> Dict[str, float]:\n        forcings = {}\n        for name, comp in self.components.items():\n            forcings[name] = comp.compute_forcing()\n        return forcings\n\n    def aggregate(self) -> float:\n        \"\"\"\n        Aggregate all components into a single net radiative forcing (W/m2).\n\n        Steps:\n        1. Sum individual forcings.\n        2. For each unordered pair with an overlap fraction, if they have the same sign,\n           subtract overlap_fraction * min(|F_i|, |F_j|).\n        \"\"\"\n        forcings = self._compute_individual_forcings()\n        total = sum(forcings.values())\n\n        # apply pairwise overlaps\n        seen = set()\n        for key, frac in self.overlaps.items():\n            names = tuple(key)\n            if len(names) != 2:\n                continue\n            a, b = names\n            if a not in forcings or b not in forcings:\n                # ignore overlaps that reference missing components\n                continue\n            fi = forcings[a]\n            fj = forcings[b]\n            if fi == 0 or fj == 0:\n                continue\n            # Only apply overlap adjustment when forcings have same sign\n            if (fi > 0 and fj > 0) or (fi < 0 and fj < 0):\n                adjustment = frac * min(abs(fi), abs(fj))\n                # subtract adjustment from total (overlap reduces double-counting)\n                total -= adjustment\n        return total\n\n    def aggregate_area_weighted(self, regional_components: Dict[str, List[ForcingComponent]],\n                                area_weights: Dict[str, float]) -> float:\n        \"\"\"\n        Compute area-weighted global mean forcing.\n\n        regional_components: mapping region_name -> list of ForcingComponent (names must be unique per region)\n        area_weights: mapping region_name -> area (units arbitrary); normalization is performed internally.\n\n        Returns the normalized area-weighted mean. Raises ValueError on zero total area.\n        \"\"\"\n        if not regional_components:\n            return 0.0\n        # compute per-region aggregates\n        regional_results: Dict[str, float] = {}\n        for region, comps in regional_components.items():\n            agg = RadiativeForcingAggregator()\n            # add components with unique names qualified by region to avoid name collision with overlaps\n            for i, comp in enumerate(comps):\n                # clone with region-qualified name; overlaps are assumed local to region in this method\n                qualified = ForcingComponent(f\"{region}::{comp.name}\", comp.gas_type, comp.concentration, comp.baseline)\n                agg.add_component(qualified)\n            # no overlaps across regions in this simple global routine\n            regional_results[region] = agg.aggregate()\n\n        total_area = sum(area_weights.get(r, 0.0) for r in regional_results.keys())\n        if total_area == 0:\n            raise ValueError(\"Total area must be > 0 for area-weighted aggregation\")\n\n        weighted_sum = sum(regional_results[r] * area_weights.get(r, 0.0) for r in regional_results.keys())\n        return weighted_sum / total_area\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\n\"\"\"\ntest_radiative_forcing_aggregator.py\nUnit tests for radiative_forcing_aggregator module.\n\"\"\"\nimport unittest\nfrom math import isclose\nimport radiative_forcing_aggregator as rfa\n\n\nclass TestRadiativeForcingAggregator(unittest.TestCase):\n\n    def test_co2_myhre_doubling(self):\n        # CO2 doubling from 280 to 560 ppm\n        comp = rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0)\n        f = comp.compute_forcing()\n        expected = 5.35 * 0.6931471805599453  # 5.35 * ln(2)\n        self.assertTrue(isclose(f, expected, rel_tol=1e-9))\n\n    def test_linear_trace_gas(self):\n        # CH4 with simple linear coefficient: coeff * delta_ppb\n        comp = rfa.ForcingComponent('ch4', 'CH4', 1800.0, 1700.0)\n        f = comp.compute_forcing()\n        expected = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * (1800.0 - 1700.0)\n        self.assertEqual(f, expected)\n\n    def test_aggregation_no_overlap(self):\n        agg = rfa.RadiativeForcingAggregator()\n        agg.add_component(rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0))\n        agg.add_component(rfa.ForcingComponent('ch4', 'CH4', 1800.0, 1700.0))\n        total = agg.aggregate()\n        expected = (5.35 * 0.6931471805599453) + (rfa.ForcingComponent.TRACE_COEFFS['CH4'] * 100.0)\n        self.assertTrue(isclose(total, expected, rel_tol=1e-9))\n\n    def test_overlap_subtraction(self):\n        agg = rfa.RadiativeForcingAggregator()\n        agg.add_component(rfa.ForcingComponent('a', 'CH4', 2000.0, 1900.0))  # F_a = coeff * 100\n        agg.add_component(rfa.ForcingComponent('b', 'N2O', 330.0, 300.0))    # F_b = coeff * 30\n        # set 50% overlap between a and b\n        agg.set_overlap('a', 'b', 0.5)\n        fa = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * 100.0\n        fb = rfa.ForcingComponent.TRACE_COEFFS['N2O'] * 30.0\n        expected = fa + fb - 0.5 * min(abs(fa), abs(fb))\n        self.assertTrue(isclose(agg.aggregate(), expected, rel_tol=1e-12))\n\n    def test_mixed_sign_overlap_ignored(self):\n        # One positive forcing and one negative forcing with an overlap -> overlap ignored\n        agg = rfa.RadiativeForcingAggregator()\n        agg.add_component(rfa.ForcingComponent('pos', 'CH4', 2000.0, 1900.0))  # positive\n        # represent an artificial negative forcing (e.g., volcanic aerosol) using CH4 formula but reversed\n        agg.add_component(rfa.ForcingComponent('neg', 'CH4', 1800.0, 1900.0))  # negative\n        agg.set_overlap('pos', 'neg', 1.0)  # would fully overlap, but signs differ -> ignored\n        total = agg.aggregate()\n        # simple arithmetic sum expected\n        fpos = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * 100.0\n        fneg = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * (-100.0)\n        self.assertEqual(total, fpos + fneg)\n\n    def test_area_weighted_global_mean(self):\n        # Two regions with different area weights\n        region1 = [rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0)]\n        region2 = [rfa.ForcingComponent('co2', 'CO2', 420.0, 280.0)]\n        regional = {'north': region1, 'south': region2}\n        areas = {'north': 2.0, 'south': 1.0}\n        agg = rfa.RadiativeForcingAggregator()\n        gm = agg.aggregate_area_weighted(regional, areas)\n        f1 = rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0).compute_forcing()\n        f2 = rfa.ForcingComponent('co2', 'CO2', 420.0, 280.0).compute_forcing()\n        expected = (f1 * 2.0 + f2 * 1.0) / 3.0\n        self.assertTrue(isclose(gm, expected, rel_tol=1e-12))\n\n    def test_zero_area_error(self):\n        regional = {'r': [rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0)]}\n        areas = {'r': 0.0}\n        agg = rfa.RadiativeForcingAggregator()\n        with self.assertRaises(ValueError):\n            agg.aggregate_area_weighted(regional, areas)\n\n    def test_invalid_baseline_for_co2(self):\n        # baseline zero should raise error for CO2 logarithmic formula\n        comp = rfa.ForcingComponent('co2', 'CO2', 560.0, 0.0)\n        with self.assertRaises(ValueError):\n            comp.compute_forcing()\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"\nradiative_forcing_aggregator.py\nSimple radiative forcing aggregation utilities for debugging and testing.\n\"\"\"\nfrom math import log\nfrom typing import Dict, Tuple, List\n\nclass ForcingComponent:\n    \"\"\"\n    Represents a single radiative forcing component.\n\n    gas_type: 'CO2', 'CH4', or 'N2O' (case-sensitive in this simple model)\n    concentration and baseline are in the same units (ppm for CO2, ppb for trace gases).\n    \"\"\"\n    TRACE_COEFFS = {'CH4': 0.0002, 'N2O': 0.0001}\n\n    def __init__(self, name: str, gas_type: str, concentration: float, baseline: float):\n        self.name = name\n        self.gas_type = gas_type\n        self.concentration = concentration\n        self.baseline = baseline\n\n    def compute_forcing(self) -> float:\n        \"\"\"\n        Compute radiative forcing for this component.\n\n        - CO2: Myhre approximation F = 5.35 * ln(C / C0). Baseline must be > 0.\n        - CH4, N2O: linear approx F = coeff * (C - C0).\n\n        Raises ValueError for invalid inputs (e.g., baseline <= 0 for CO2, negative concentrations).\n        \"\"\"\n        if self.concentration is None or self.baseline is None:\n            raise ValueError('Concentration and baseline must be provided')\n        if self.concentration < 0 or self.baseline < 0:\n            raise ValueError('Concentrations and baseline must be non-negative')\n        if self.gas_type == 'CO2':\n            if self.baseline <= 0:\n                raise ValueError('CO2 baseline must be > 0 for logarithmic formula')\n            return 5.35 * log(self.concentration / self.baseline)\n        elif self.gas_type in self.TRACE_COEFFS:\n            coeff = self.TRACE_COEFFS[self.gas_type]\n            return coeff * (self.concentration + self.baseline)\n        else:\n            raise ValueError(f'Unsupported gas_type: {self.gas_type}')\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates multiple ForcingComponent instances with optional pairwise overlaps.\n\n    overlap_map keys are frozenset({'name1','name2'}) -> fraction in [0,1].\n    The overlap model subtracts overlap_fraction * min(|F_i|, |F_j|) for each pair\n    when the two forcings have the same sign.\n    \"\"\"\n\n    def __init__(self):\n        self.components: Dict[str, ForcingComponent] = {}\n        self.overlaps: Dict[frozenset, float] = {}\n\n    def add_component(self, component: ForcingComponent):\n        if component.name in self.components:\n            raise ValueError(f'Component with name {component.name} already exists')\n        self.components[component.name] = component\n\n    def set_overlap(self, name1: str, name2: str, fraction: float):\n        if name1 == name2:\n            raise ValueError('Overlap must be between two distinct components')\n        if not 0.0 <= fraction <= 1.0:\n            raise ValueError('Overlap fraction must be between 0 and 1')\n        key = frozenset([name1, name2])\n        self.overlaps[key] = fraction\n\n    def _compute_individual_forcings(self) -> Dict[str, float]:\n        forcings = {}\n        for name, comp in self.components.items():\n            forcings[name] = comp.compute_forcing()\n        return forcings\n\n    def aggregate(self) -> float:\n        \"\"\"\n        Aggregate all components into a single net radiative forcing (W/m2).\n\n        Steps:\n        1. Sum individual forcings.\n        2. For each unordered pair with an overlap fraction, if they have the same sign,\n           subtract overlap_fraction * min(|F_i|, |F_j|).\n        \"\"\"\n        forcings = self._compute_individual_forcings()\n        total = sum(forcings.values())\n        seen = set()\n        for key, frac in self.overlaps.items():\n            names = tuple(key)\n            if len(names) != 2:\n                continue\n            a, b = names\n            if a not in forcings or b not in forcings:\n                continue\n            fi = forcings[a]\n            fj = forcings[b]\n            if fi == 0 or fj == 0:\n                continue\n            if fi > 0 and fj > 0 or (fi < 0 and fj < 0):\n                adjustment = frac * min(abs(fi), abs(fj))\n                total -= adjustment\n        return total\n\n    def aggregate_area_weighted(self, regional_components: Dict[str, List[ForcingComponent]], area_weights: Dict[str, float]) -> float:\n        \"\"\"\n        Compute area-weighted global mean forcing.\n\n        regional_components: mapping region_name -> list of ForcingComponent (names must be unique per region)\n        area_weights: mapping region_name -> area (units arbitrary); normalization is performed internally.\n\n        Returns the normalized area-weighted mean. Raises ValueError on zero total area.\n        \"\"\"\n        if not regional_components:\n            return 0.0\n        regional_results: Dict[str, float] = {}\n        for region, comps in regional_components.items():\n            agg = RadiativeForcingAggregator()\n            for i, comp in enumerate(comps):\n                qualified = ForcingComponent(f'{region}::{comp.name}', comp.gas_type, comp.concentration, comp.baseline)\n                agg.add_component(qualified)\n            regional_results[region] = agg.aggregate()\n        total_area = sum((area_weights.get(r, 0.0) for r in regional_results.keys()))\n        if total_area == 0:\n            raise ValueError('Total area must be > 0 for area-weighted aggregation')\n        weighted_sum = sum((regional_results[r] * area_weights.get(r, 0.0) for r in regional_results.keys()))\n        return weighted_sum / total_area\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_aggregation_no_overlap (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_aggregation_no_overlap) ... FAIL\ntest_area_weighted_global_mean (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_area_weighted_global_mean) ... ok\ntest_co2_myhre_doubling (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_co2_myhre_doubling) ... ok\ntest_invalid_baseline_for_co2 (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_invalid_baseline_for_co2) ... ok\ntest_linear_trace_gas (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_linear_trace_gas) ... FAIL\ntest_mixed_sign_overlap_ignored (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_mixed_sign_overlap_ignored) ... FAIL\ntest_overlap_subtraction (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_overlap_subtraction) ... FAIL\ntest_zero_area_error (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_zero_area_error) ... ok\n\n======================================================================\nFAIL: test_aggregation_no_overlap (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_aggregation_no_overlap)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 32, in test_aggregation_no_overlap\n    self.assertTrue(isclose(total, expected, rel_tol=1e-9))\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: False is not true\n\n======================================================================\nFAIL: test_linear_trace_gas (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_linear_trace_gas)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 24, in test_linear_trace_gas\n    self.assertEqual(f, expected)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^\nAssertionError: 0.7000000000000001 != 0.02\n\n======================================================================\nFAIL: test_mixed_sign_overlap_ignored (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_mixed_sign_overlap_ignored)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 56, in test_mixed_sign_overlap_ignored\n    self.assertEqual(total, fpos + fneg)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.78 != 0.0\n\n======================================================================\nFAIL: test_overlap_subtraction (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_overlap_subtraction)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 43, in test_overlap_subtraction\n    self.assertTrue(isclose(agg.aggregate(), expected, rel_tol=1e-12))\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 8 tests in 0.001s\n\nFAILED (failures=4)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "\"\"\"\nradiative_forcing_aggregator.py\nSimple radiative forcing aggregation utilities for debugging and testing.\n\"\"\"\nfrom math import log\nfrom typing import Dict, Tuple, List\n\n\nclass ForcingComponent:\n    \"\"\"\n    Represents a single radiative forcing component.\n\n    gas_type: 'CO2', 'CH4', or 'N2O' (case-sensitive in this simple model)\n    concentration and baseline are in the same units (ppm for CO2, ppb for trace gases).\n    \"\"\"\n    TRACE_COEFFS = {\n        'CH4': 0.0002,   # W/m2 per ppb (approximate linear sensitivity for exercise)\n        'N2O': 0.0001,   # W/m2 per ppb (approximate)\n    }\n\n    def __init__(self, name: str, gas_type: str, concentration: float, baseline: float):\n        self.name = name\n        self.gas_type = gas_type\n        self.concentration = concentration\n        self.baseline = baseline\n\n    def compute_forcing(self) -> float:\n        \"\"\"\n        Compute radiative forcing for this component.\n\n        - CO2: Myhre approximation F = 5.35 * ln(C / C0). Baseline must be > 0.\n        - CH4, N2O: linear approx F = coeff * (C - C0).\n\n        Raises ValueError for invalid inputs (e.g., baseline <= 0 for CO2, negative concentrations).\n        \"\"\"\n        if self.concentration is None or self.baseline is None:\n            raise ValueError(\"Concentration and baseline must be provided\")\n        if self.concentration < 0 or self.baseline < 0:\n            raise ValueError(\"Concentrations and baseline must be non-negative\")\n\n        if self.gas_type == 'CO2':\n            if self.baseline <= 0:\n                raise ValueError(\"CO2 baseline must be > 0 for logarithmic formula\")\n            # Myhre et al. (simplified)\n            return 5.35 * log(self.concentration / self.baseline)\n        elif self.gas_type in self.TRACE_COEFFS:\n            coeff = self.TRACE_COEFFS[self.gas_type]\n            return coeff * (self.concentration - self.baseline)\n        else:\n            raise ValueError(f\"Unsupported gas_type: {self.gas_type}\")\n\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates multiple ForcingComponent instances with optional pairwise overlaps.\n\n    overlap_map keys are frozenset({'name1','name2'}) -> fraction in [0,1].\n    The overlap model subtracts overlap_fraction * min(|F_i|, |F_j|) for each pair\n    when the two forcings have the same sign.\n    \"\"\"\n    def __init__(self):\n        self.components: Dict[str, ForcingComponent] = {}\n        self.overlaps: Dict[frozenset, float] = {}\n\n    def add_component(self, component: ForcingComponent):\n        if component.name in self.components:\n            raise ValueError(f\"Component with name {component.name} already exists\")\n        self.components[component.name] = component\n\n    def set_overlap(self, name1: str, name2: str, fraction: float):\n        if name1 == name2:\n            raise ValueError(\"Overlap must be between two distinct components\")\n        if not (0.0 <= fraction <= 1.0):\n            raise ValueError(\"Overlap fraction must be between 0 and 1\")\n        key = frozenset([name1, name2])\n        self.overlaps[key] = fraction\n\n    def _compute_individual_forcings(self) -> Dict[str, float]:\n        forcings = {}\n        for name, comp in self.components.items():\n            forcings[name] = comp.compute_forcing()\n        return forcings\n\n    def aggregate(self) -> float:\n        \"\"\"\n        Aggregate all components into a single net radiative forcing (W/m2).\n\n        Steps:\n        1. Sum individual forcings.\n        2. For each unordered pair with an overlap fraction, if they have the same sign,\n           subtract overlap_fraction * min(|F_i|, |F_j|).\n        \"\"\"\n        forcings = self._compute_individual_forcings()\n        total = sum(forcings.values())\n\n        # apply pairwise overlaps\n        seen = set()\n        for key, frac in self.overlaps.items():\n            names = tuple(key)\n            if len(names) != 2:\n                continue\n            a, b = names\n            if a not in forcings or b not in forcings:\n                # ignore overlaps that reference missing components\n                continue\n            fi = forcings[a]\n            fj = forcings[b]\n            if fi == 0 or fj == 0:\n                continue\n            # Only apply overlap adjustment when forcings have same sign\n            if (fi > 0 and fj > 0) or (fi < 0 and fj < 0):\n                adjustment = frac * min(abs(fi), abs(fj))\n                # subtract adjustment from total (overlap reduces double-counting)\n                total -= adjustment\n        return total\n\n    def aggregate_area_weighted(self, regional_components: Dict[str, List[ForcingComponent]],\n                                area_weights: Dict[str, float]) -> float:\n        \"\"\"\n        Compute area-weighted global mean forcing.\n\n        regional_components: mapping region_name -> list of ForcingComponent (names must be unique per region)\n        area_weights: mapping region_name -> area (units arbitrary); normalization is performed internally.\n\n        Returns the normalized area-weighted mean. Raises ValueError on zero total area.\n        \"\"\"\n        if not regional_components:\n            return 0.0\n        # compute per-region aggregates\n        regional_results: Dict[str, float] = {}\n        for region, comps in regional_components.items():\n            agg = RadiativeForcingAggregator()\n            # add components with unique names qualified by region to avoid name collision with overlaps\n            for i, comp in enumerate(comps):\n                # clone with region-qualified name; overlaps are assumed local to region in this method\n                qualified = ForcingComponent(f\"{region}::{comp.name}\", comp.gas_type, comp.concentration, comp.baseline)\n                agg.add_component(qualified)\n            # no overlaps across regions in this simple global routine\n            regional_results[region] = agg.aggregate()\n\n        total_area = sum(area_weights.get(r, 0.0) for r in regional_results.keys())\n        if total_area == 0:\n            raise ValueError(\"Total area must be > 0 for area-weighted aggregation\")\n\n        weighted_sum = sum(regional_results[r] * area_weights.get(r, 0.0) for r in regional_results.keys())\n        return weighted_sum / total_area\n",
  "domain": "Climate Science",
  "failing_output": "test_aggregation_no_overlap (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_aggregation_no_overlap) ... FAIL\ntest_area_weighted_global_mean (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_area_weighted_global_mean) ... ok\ntest_co2_myhre_doubling (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_co2_myhre_doubling) ... ok\ntest_invalid_baseline_for_co2 (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_invalid_baseline_for_co2) ... ok\ntest_linear_trace_gas (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_linear_trace_gas) ... FAIL\ntest_mixed_sign_overlap_ignored (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_mixed_sign_overlap_ignored) ... FAIL\ntest_overlap_subtraction (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_overlap_subtraction) ... FAIL\ntest_zero_area_error (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_zero_area_error) ... ok\n\n======================================================================\nFAIL: test_aggregation_no_overlap (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_aggregation_no_overlap)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 32, in test_aggregation_no_overlap\n    self.assertTrue(isclose(total, expected, rel_tol=1e-9))\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: False is not true\n\n======================================================================\nFAIL: test_linear_trace_gas (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_linear_trace_gas)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 24, in test_linear_trace_gas\n    self.assertEqual(f, expected)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^\nAssertionError: 0.7000000000000001 != 0.02\n\n======================================================================\nFAIL: test_mixed_sign_overlap_ignored (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_mixed_sign_overlap_ignored)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 56, in test_mixed_sign_overlap_ignored\n    self.assertEqual(total, fpos + fneg)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.78 != 0.0\n\n======================================================================\nFAIL: test_overlap_subtraction (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_overlap_subtraction)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpp95vg19p/test_radiative_forcing_aggregator.py\", line 43, in test_overlap_subtraction\n    self.assertTrue(isclose(agg.aggregate(), expected, rel_tol=1e-12))\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 8 tests in 0.001s\n\nFAILED (failures=4)",
  "module_name": "radiative_forcing_aggregator",
  "problem_description": "You are given a small radiative forcing aggregation library skeleton used in an atmospheric model. The library must compute per-component radiative forcing for common greenhouse gases, combine those components taking into account pairwise overlaps, and compute area-weighted global aggregates from regional contributions.\n\nRequirements and scientific context:\n- CO2 forcing should use the Myhre et al. logarithmic approximation: F = 5.35 * ln(C / C0).\n- Trace gases (e.g. CH4, N2O) are represented with linear approximations around contemporary concentrations: F = coeff * (C - C0). Coefficients are fixed, approximate sensitivities (documented in the code). This is acceptable for this debugging exercise.\n- Pairwise overlaps between components (e.g. spectral overlap between CH4 and N2O) reduce the naive sum of forcings. For simplicity, overlaps are represented by symmetric pairwise fractions in [0,1]. When two forcings have the same sign (both positive or both negative), the overlap reduces the total by overlap_fraction * min(|F_i|, |F_j|). If signs differ, overlaps are ignored (no cancellation assumed by overlap model).\n- Regional aggregation: compute a regional aggregate using the same overlap logic, then compute a global area-weighted mean across regions. Area weights need not be normalized \u2014 the routine must normalize internally and raise an error for zero total area.\n\nThe provided code must:\n- Provide cooperating classes/functions to represent components and perform aggregation.\n- Validate inputs (e.g., positive concentrations where required, non-zero baseline for logarithms).\n- Be deterministic and use only the standard library.\n- Include docstrings/comments explaining assumptions and non-obvious logic.\n\nYour task is to inspect and, if needed, fix or implement the module so that it correctly implements these behaviors and passes the unit tests that accompany it. The tests include happy paths (CO2 doubling, simple sums) and edge conditions (overlap handling, zero area, invalid baselines).\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Implement a ForcingComponent class that encapsulates a single gas/component, its concentration and baseline, and a method to compute its radiative forcing using gas-specific formulae (log for CO2, linear for trace gases).\n2. Implement a RadiativeForcingAggregator class that stores components and pairwise overlap fractions, validates inputs, and aggregates forcings by summing individual forcings and subtracting pairwise overlap adjustments following the stated rule (only when signs match).\n3. Provide an area-weighted aggregation method that computes regional aggregates then returns a normalized global mean; handle zero total-area as an error.\n4. Write robust unit tests that verify CO2 logarithmic forcing, simple aggregation without overlaps, aggregation with overlaps, mixed-sign behavior, area-weighted averaging, and error conditions (e.g., zero baseline for CO2, zero total area).\n",
  "subtopic": "Radiative forcing aggregation",
  "summary": "A debugging challenge to implement a radiative forcing aggregator that computes gas-specific forcings, handles pairwise overlaps, and produces area-weighted global aggregates.",
  "topic": "Atmospheric modelling",
  "unit_tests": "\"\"\"\ntest_radiative_forcing_aggregator.py\nUnit tests for radiative_forcing_aggregator module.\n\"\"\"\nimport unittest\nfrom math import isclose\nimport radiative_forcing_aggregator as rfa\n\n\nclass TestRadiativeForcingAggregator(unittest.TestCase):\n\n    def test_co2_myhre_doubling(self):\n        # CO2 doubling from 280 to 560 ppm\n        comp = rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0)\n        f = comp.compute_forcing()\n        expected = 5.35 * 0.6931471805599453  # 5.35 * ln(2)\n        self.assertTrue(isclose(f, expected, rel_tol=1e-9))\n\n    def test_linear_trace_gas(self):\n        # CH4 with simple linear coefficient: coeff * delta_ppb\n        comp = rfa.ForcingComponent('ch4', 'CH4', 1800.0, 1700.0)\n        f = comp.compute_forcing()\n        expected = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * (1800.0 - 1700.0)\n        self.assertEqual(f, expected)\n\n    def test_aggregation_no_overlap(self):\n        agg = rfa.RadiativeForcingAggregator()\n        agg.add_component(rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0))\n        agg.add_component(rfa.ForcingComponent('ch4', 'CH4', 1800.0, 1700.0))\n        total = agg.aggregate()\n        expected = (5.35 * 0.6931471805599453) + (rfa.ForcingComponent.TRACE_COEFFS['CH4'] * 100.0)\n        self.assertTrue(isclose(total, expected, rel_tol=1e-9))\n\n    def test_overlap_subtraction(self):\n        agg = rfa.RadiativeForcingAggregator()\n        agg.add_component(rfa.ForcingComponent('a', 'CH4', 2000.0, 1900.0))  # F_a = coeff * 100\n        agg.add_component(rfa.ForcingComponent('b', 'N2O', 330.0, 300.0))    # F_b = coeff * 30\n        # set 50% overlap between a and b\n        agg.set_overlap('a', 'b', 0.5)\n        fa = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * 100.0\n        fb = rfa.ForcingComponent.TRACE_COEFFS['N2O'] * 30.0\n        expected = fa + fb - 0.5 * min(abs(fa), abs(fb))\n        self.assertTrue(isclose(agg.aggregate(), expected, rel_tol=1e-12))\n\n    def test_mixed_sign_overlap_ignored(self):\n        # One positive forcing and one negative forcing with an overlap -> overlap ignored\n        agg = rfa.RadiativeForcingAggregator()\n        agg.add_component(rfa.ForcingComponent('pos', 'CH4', 2000.0, 1900.0))  # positive\n        # represent an artificial negative forcing (e.g., volcanic aerosol) using CH4 formula but reversed\n        agg.add_component(rfa.ForcingComponent('neg', 'CH4', 1800.0, 1900.0))  # negative\n        agg.set_overlap('pos', 'neg', 1.0)  # would fully overlap, but signs differ -> ignored\n        total = agg.aggregate()\n        # simple arithmetic sum expected\n        fpos = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * 100.0\n        fneg = rfa.ForcingComponent.TRACE_COEFFS['CH4'] * (-100.0)\n        self.assertEqual(total, fpos + fneg)\n\n    def test_area_weighted_global_mean(self):\n        # Two regions with different area weights\n        region1 = [rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0)]\n        region2 = [rfa.ForcingComponent('co2', 'CO2', 420.0, 280.0)]\n        regional = {'north': region1, 'south': region2}\n        areas = {'north': 2.0, 'south': 1.0}\n        agg = rfa.RadiativeForcingAggregator()\n        gm = agg.aggregate_area_weighted(regional, areas)\n        f1 = rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0).compute_forcing()\n        f2 = rfa.ForcingComponent('co2', 'CO2', 420.0, 280.0).compute_forcing()\n        expected = (f1 * 2.0 + f2 * 1.0) / 3.0\n        self.assertTrue(isclose(gm, expected, rel_tol=1e-12))\n\n    def test_zero_area_error(self):\n        regional = {'r': [rfa.ForcingComponent('co2', 'CO2', 560.0, 280.0)]}\n        areas = {'r': 0.0}\n        agg = rfa.RadiativeForcingAggregator()\n        with self.assertRaises(ValueError):\n            agg.aggregate_area_weighted(regional, areas)\n\n    def test_invalid_baseline_for_co2(self):\n        # baseline zero should raise error for CO2 logarithmic formula\n        comp = rfa.ForcingComponent('co2', 'CO2', 560.0, 0.0)\n        with self.assertRaises(ValueError):\n            comp.compute_forcing()\n\n\nif __name__ == '__main__':\n    unittest.main()"
}