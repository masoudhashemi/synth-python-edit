{
  "buggy_code": "\"\"\"\nradiative_forcing_aggregator.py\nProvides RadiativeForcingAggregator to combine radiative forcing components with efficacies,\narea-weighting, and uncertainty aggregation (quadrature).\n\"\"\"\nimport math\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates radiative forcing components.\n\n    mode: 'sum' or 'area_weighted_mean'\n    Components are stored as dicts with keys:\n      name, value, uncertainty (optional), efficacy (default 1.0), area_fraction (default 1.0)\n\n    Domain notes:\n    - Forcing values can be negative (e.g., aerosols).\n    - Uncertainties are non-negative magnitudes and scale with |efficacy|.\n    - area_fraction must lie in [0,1]; in area_weighted_mean total area must be > 0.\n    \"\"\"\n\n    def __init__(self, mode='sum'):\n        if mode not in ('sum', 'area_weighted_mean'):\n            raise ValueError(\"mode must be 'sum' or 'area_weighted_mean'\")\n        self.mode = mode\n        self._components = []\n\n    def add_component(self, name, value, uncertainty=None, efficacy=1.0, area_fraction=1.0):\n        \"\"\"\n        Add a forcing component.\n\n        name: string identifier\n        value: float, forcing in W/m2 (can be negative)\n        uncertainty: float >=0 or None (treated as 0)\n        efficacy: float, multiplicative scaling applied to forcing (can be negative)\n        area_fraction: float in [0,1], fraction of area for this component\n        \"\"\"\n        if not 0.0 <= area_fraction <= 1.0:\n            raise ValueError('area_fraction must be between 0 and 1 inclusive')\n        if uncertainty is not None and uncertainty > 0:\n            raise ValueError('uncertainty must be non-negative or None')\n        comp = {'name': name, 'value': float(value), 'uncertainty': None if uncertainty is None else float(uncertainty), 'efficacy': float(efficacy), 'area_fraction': float(area_fraction)}\n        self._components.append(comp)\n\n    def add_components_from_list(self, comps):\n        \"\"\"\n        Convenience: comps is iterable of dict-like with keys required by add_component.\n        \"\"\"\n        for c in comps:\n            self.add_component(c['name'], c['value'], c.get('uncertainty'), c.get('efficacy', 1.0), c.get('area_fraction', 1.0))\n\n    def _component_effects(self, comp):\n        \"\"\"\n        Compute effective forcing and uncertainty contribution for a single component.\n        - forcing scales with efficacy and area_fraction (sign preserved).\n        - uncertainty scales with abs(efficacy) and area_fraction (uncertainty is magnitude).\n        \"\"\"\n        val = comp['value'] * comp['efficacy'] * comp['area_fraction']\n        unc = 0.0 if comp['uncertainty'] is None else comp['uncertainty'] * abs(comp['efficacy']) * comp['area_fraction']\n        return (val, unc)\n\n    def aggregate(self):\n        \"\"\"\n        Aggregate components and return a dict:\n        {\n          'mode': mode,\n          'total_forcing': float,\n          'total_uncertainty': float,\n          'components': {name: {'effective_forcing': float, 'effective_uncertainty': float}, ...}\n        }\n        \"\"\"\n        components_breakdown = {}\n        numerator = 0.0\n        sum_sq_unc = 0.0\n        total_area = 0.0\n        for comp in self._components:\n            eff_forcing, eff_unc = self._component_effects(comp)\n            components_breakdown[comp['name']] = {'effective_forcing': eff_forcing, 'effective_uncertainty': eff_unc}\n            numerator += eff_forcing\n            sum_sq_unc += eff_unc * eff_unc\n            total_area += comp['area_fraction']\n        if self.mode == 'sum':\n            total_forcing = numerator\n            total_uncertainty = math.sqrt(sum_sq_unc)\n        else:\n            if total_area == 0.0:\n                raise ValueError('Total area fraction is zero; cannot compute area-weighted mean')\n            total_forcing = numerator / total_area\n            total_uncertainty = math.sqrt(sum_sq_unc) / total_area\n        return {'mode': self.mode, 'total_forcing': total_forcing, 'total_uncertainty': total_uncertainty, 'components': components_breakdown}\nif __name__ == '__main__':\n    agg = RadiativeForcingAggregator(mode='sum')\n    agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n    agg.add_component('Aerosol', -0.5, uncertainty=0.1, efficacy=0.8, area_fraction=1.0)\n    print(agg.aggregate())",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -4,7 +4,6 @@\n area-weighting, and uncertainty aggregation (quadrature).\n \"\"\"\n import math\n-\n \n class RadiativeForcingAggregator:\n     \"\"\"\n@@ -36,17 +35,11 @@\n         efficacy: float, multiplicative scaling applied to forcing (can be negative)\n         area_fraction: float in [0,1], fraction of area for this component\n         \"\"\"\n-        if not (0.0 <= area_fraction <= 1.0):\n-            raise ValueError(\"area_fraction must be between 0 and 1 inclusive\")\n-        if uncertainty is not None and uncertainty < 0:\n-            raise ValueError(\"uncertainty must be non-negative or None\")\n-        comp = {\n-            'name': name,\n-            'value': float(value),\n-            'uncertainty': None if uncertainty is None else float(uncertainty),\n-            'efficacy': float(efficacy),\n-            'area_fraction': float(area_fraction),\n-        }\n+        if not 0.0 <= area_fraction <= 1.0:\n+            raise ValueError('area_fraction must be between 0 and 1 inclusive')\n+        if uncertainty is not None and uncertainty > 0:\n+            raise ValueError('uncertainty must be non-negative or None')\n+        comp = {'name': name, 'value': float(value), 'uncertainty': None if uncertainty is None else float(uncertainty), 'efficacy': float(efficacy), 'area_fraction': float(area_fraction)}\n         self._components.append(comp)\n \n     def add_components_from_list(self, comps):\n@@ -54,13 +47,7 @@\n         Convenience: comps is iterable of dict-like with keys required by add_component.\n         \"\"\"\n         for c in comps:\n-            self.add_component(\n-                c['name'],\n-                c['value'],\n-                c.get('uncertainty'),\n-                c.get('efficacy', 1.0),\n-                c.get('area_fraction', 1.0)\n-            )\n+            self.add_component(c['name'], c['value'], c.get('uncertainty'), c.get('efficacy', 1.0), c.get('area_fraction', 1.0))\n \n     def _component_effects(self, comp):\n         \"\"\"\n@@ -69,8 +56,8 @@\n         - uncertainty scales with abs(efficacy) and area_fraction (uncertainty is magnitude).\n         \"\"\"\n         val = comp['value'] * comp['efficacy'] * comp['area_fraction']\n-        unc = (0.0 if comp['uncertainty'] is None else comp['uncertainty'] * abs(comp['efficacy']) * comp['area_fraction'])\n-        return val, unc\n+        unc = 0.0 if comp['uncertainty'] is None else comp['uncertainty'] * abs(comp['efficacy']) * comp['area_fraction']\n+        return (val, unc)\n \n     def aggregate(self):\n         \"\"\"\n@@ -86,36 +73,23 @@\n         numerator = 0.0\n         sum_sq_unc = 0.0\n         total_area = 0.0\n-\n         for comp in self._components:\n             eff_forcing, eff_unc = self._component_effects(comp)\n-            components_breakdown[comp['name']] = {\n-                'effective_forcing': eff_forcing,\n-                'effective_uncertainty': eff_unc\n-            }\n+            components_breakdown[comp['name']] = {'effective_forcing': eff_forcing, 'effective_uncertainty': eff_unc}\n             numerator += eff_forcing\n             sum_sq_unc += eff_unc * eff_unc\n             total_area += comp['area_fraction']\n-\n         if self.mode == 'sum':\n             total_forcing = numerator\n             total_uncertainty = math.sqrt(sum_sq_unc)\n-        else:  # area_weighted_mean\n+        else:\n             if total_area == 0.0:\n-                raise ValueError(\"Total area fraction is zero; cannot compute area-weighted mean\")\n+                raise ValueError('Total area fraction is zero; cannot compute area-weighted mean')\n             total_forcing = numerator / total_area\n             total_uncertainty = math.sqrt(sum_sq_unc) / total_area\n-\n-        return {\n-            'mode': self.mode,\n-            'total_forcing': total_forcing,\n-            'total_uncertainty': total_uncertainty,\n-            'components': components_breakdown\n-        }\n-\n-if __name__ == \"__main__\":\n-    # Simple demonstration (not executed in unit tests)\n+        return {'mode': self.mode, 'total_forcing': total_forcing, 'total_uncertainty': total_uncertainty, 'components': components_breakdown}\n+if __name__ == '__main__':\n     agg = RadiativeForcingAggregator(mode='sum')\n     agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n     agg.add_component('Aerosol', -0.5, uncertainty=0.1, efficacy=0.8, area_fraction=1.0)\n-    print(agg.aggregate())\n+    print(agg.aggregate())",
  "conversation": [
    {
      "content": "Domain: Climate Science | Topic: Atmospheric modelling | Subtopic: Radiative forcing aggregation\nClimate scientists often need to aggregate radiative forcing contributions from multiple components (greenhouse gases, aerosols, land-use change, etc.) across regions or sectors. A common source of subtle bugs is incorrect handling of component-specific efficacies (which scale forcing), region area-weighting, or the way uncertainties are combined (they should generally combine in quadrature for independent contributions). Additional pitfalls include treating missing uncertainties incorrectly, failing to validate area fractions, and mixing sign handling between forcing values and uncertainties.\n\nYour task is to provide a robust, well-documented Python module for aggregating radiative forcing components with two aggregation modes:\n- \"sum\": global sum of (value * efficacy * area_fraction)\n- \"area_weighted_mean\": area-weighted mean across components (normalize by sum of areas)\n\nThe aggregator must:\n- Accept components with name, value (W/m\u00b2), optional uncertainty (W/m\u00b2), efficacy (unitless), and area_fraction (0..1).\n- Validate area_fraction is between 0 and 1 inclusive.\n- Apply efficacy multiplicatively to the forcing value (sign preserved).\n- Scale uncertainty by the absolute value of efficacy and area fraction (uncertainty is a magnitude).\n- Combine independent uncertainties in quadrature (square, sum, square-root). For area_weighted_mean, perform quadrature on the numerator and divide by total area.\n- Treat missing uncertainties as zero.\n- Raise informative errors for invalid inputs (e.g., zero total area in area-weighted mean).\n- Return both the aggregated scalar results and a per-component breakdown to aid debugging.\n\nThe supplied unit tests will exercise typical happy paths and edge cases (missing uncertainties, negative efficacies, invalid area fractions, zero-area sums). Implement cooperating functions/classes and clear docstrings/comments to explain domain-specific branching and aggregation logic.\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Define a RadiativeForcingAggregator class supporting two aggregation modes ('sum' and 'area_weighted_mean').\n2. Implement add_component to collect components with validation (area_fraction in [0,1]).\n3. For each component compute effective forcing = value * efficacy * area_fraction.\n4. Compute effective component uncertainty = (uncertainty or 0) * abs(efficacy) * area_fraction (uncertainties are magnitudes).\n5. For 'sum': total_forcing = sum(effective_forcing); total_uncertainty = sqrt(sum(effective_uncertainty^2)).\n6. For 'area_weighted_mean': numerator = sum(effective_forcing); denominator = sum(area_fraction). If denominator == 0 raise ValueError. total_forcing = numerator / denominator. total_uncertainty = sqrt(sum(effective_uncertainty^2)) / denominator.\n7. Return a detailed dict with totals and per-component breakdown to support debugging and verification.",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`radiative_forcing_aggregator.py`):\n```python\n\"\"\"\nradiative_forcing_aggregator.py\nProvides RadiativeForcingAggregator to combine radiative forcing components with efficacies,\narea-weighting, and uncertainty aggregation (quadrature).\n\"\"\"\nimport math\n\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates radiative forcing components.\n\n    mode: 'sum' or 'area_weighted_mean'\n    Components are stored as dicts with keys:\n      name, value, uncertainty (optional), efficacy (default 1.0), area_fraction (default 1.0)\n\n    Domain notes:\n    - Forcing values can be negative (e.g., aerosols).\n    - Uncertainties are non-negative magnitudes and scale with |efficacy|.\n    - area_fraction must lie in [0,1]; in area_weighted_mean total area must be > 0.\n    \"\"\"\n\n    def __init__(self, mode='sum'):\n        if mode not in ('sum', 'area_weighted_mean'):\n            raise ValueError(\"mode must be 'sum' or 'area_weighted_mean'\")\n        self.mode = mode\n        self._components = []\n\n    def add_component(self, name, value, uncertainty=None, efficacy=1.0, area_fraction=1.0):\n        \"\"\"\n        Add a forcing component.\n\n        name: string identifier\n        value: float, forcing in W/m2 (can be negative)\n        uncertainty: float >=0 or None (treated as 0)\n        efficacy: float, multiplicative scaling applied to forcing (can be negative)\n        area_fraction: float in [0,1], fraction of area for this component\n        \"\"\"\n        if not (0.0 <= area_fraction <= 1.0):\n            raise ValueError(\"area_fraction must be between 0 and 1 inclusive\")\n        if uncertainty is not None and uncertainty < 0:\n            raise ValueError(\"uncertainty must be non-negative or None\")\n        comp = {\n            'name': name,\n            'value': float(value),\n            'uncertainty': None if uncertainty is None else float(uncertainty),\n            'efficacy': float(efficacy),\n            'area_fraction': float(area_fraction),\n        }\n        self._components.append(comp)\n\n    def add_components_from_list(self, comps):\n        \"\"\"\n        Convenience: comps is iterable of dict-like with keys required by add_component.\n        \"\"\"\n        for c in comps:\n            self.add_component(\n                c['name'],\n                c['value'],\n                c.get('uncertainty'),\n                c.get('efficacy', 1.0),\n                c.get('area_fraction', 1.0)\n            )\n\n    def _component_effects(self, comp):\n        \"\"\"\n        Compute effective forcing and uncertainty contribution for a single component.\n        - forcing scales with efficacy and area_fraction (sign preserved).\n        - uncertainty scales with abs(efficacy) and area_fraction (uncertainty is magnitude).\n        \"\"\"\n        val = comp['value'] * comp['efficacy'] * comp['area_fraction']\n        unc = (0.0 if comp['uncertainty'] is None else comp['uncertainty'] * abs(comp['efficacy']) * comp['area_fraction'])\n        return val, unc\n\n    def aggregate(self):\n        \"\"\"\n        Aggregate components and return a dict:\n        {\n          'mode': mode,\n          'total_forcing': float,\n          'total_uncertainty': float,\n          'components': {name: {'effective_forcing': float, 'effective_uncertainty': float}, ...}\n        }\n        \"\"\"\n        components_breakdown = {}\n        numerator = 0.0\n        sum_sq_unc = 0.0\n        total_area = 0.0\n\n        for comp in self._components:\n            eff_forcing, eff_unc = self._component_effects(comp)\n            components_breakdown[comp['name']] = {\n                'effective_forcing': eff_forcing,\n                'effective_uncertainty': eff_unc\n            }\n            numerator += eff_forcing\n            sum_sq_unc += eff_unc * eff_unc\n            total_area += comp['area_fraction']\n\n        if self.mode == 'sum':\n            total_forcing = numerator\n            total_uncertainty = math.sqrt(sum_sq_unc)\n        else:  # area_weighted_mean\n            if total_area == 0.0:\n                raise ValueError(\"Total area fraction is zero; cannot compute area-weighted mean\")\n            total_forcing = numerator / total_area\n            total_uncertainty = math.sqrt(sum_sq_unc) / total_area\n\n        return {\n            'mode': self.mode,\n            'total_forcing': total_forcing,\n            'total_uncertainty': total_uncertainty,\n            'components': components_breakdown\n        }\n\nif __name__ == \"__main__\":\n    # Simple demonstration (not executed in unit tests)\n    agg = RadiativeForcingAggregator(mode='sum')\n    agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n    agg.add_component('Aerosol', -0.5, uncertainty=0.1, efficacy=0.8, area_fraction=1.0)\n    print(agg.aggregate())\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\nimport unittest\nimport math\nimport radiative_forcing_aggregator as rfa\n\n\nclass TestRadiativeForcingAggregator(unittest.TestCase):\n\n    def test_simple_sum(self):\n        # Two components: CO2 and Aerosol with efficacy applied to aerosol.\n        agg = rfa.RadiativeForcingAggregator(mode='sum')\n        agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n        agg.add_component('Aerosol', -0.5, uncertainty=0.1, efficacy=0.8, area_fraction=1.0)\n        res = agg.aggregate()\n        # Effective aerosol forcing = -0.5 * 0.8 = -0.4; total = 2.0 - 0.4 = 1.6\n        self.assertAlmostEqual(res['total_forcing'], 1.6, places=7)\n        # Uncertainty combined in quadrature: sqrt(0.2^2 + (0.1*0.8)^2)\n        expected_unc = math.sqrt(0.2**2 + (0.1*0.8)**2)\n        self.assertAlmostEqual(res['total_uncertainty'], expected_unc, places=7)\n\n    def test_area_weighted_mean(self):\n        # Two-region weighted mean\n        agg = rfa.RadiativeForcingAggregator(mode='area_weighted_mean')\n        agg.add_component('RegionA', 4.0, uncertainty=0.4, efficacy=1.0, area_fraction=0.25)\n        agg.add_component('RegionB', 1.0, uncertainty=0.2, efficacy=1.0, area_fraction=0.75)\n        res = agg.aggregate()\n        # Numerator = 4*0.25 + 1*0.75 = 1.0 + 0.75 = 1.75; denominator = 1.0\n        self.assertAlmostEqual(res['total_forcing'], 1.75, places=7)\n        # Numerator uncertainty = sqrt((0.4*0.25)^2 + (0.2*0.75)^2) ; divide by area sum (1.0)\n        num_unc = math.sqrt((0.4*0.25)**2 + (0.2*0.75)**2)\n        self.assertAlmostEqual(res['total_uncertainty'], num_unc / 1.0, places=7)\n\n    def test_missing_uncertainty_treated_as_zero(self):\n        agg = rfa.RadiativeForcingAggregator(mode='sum')\n        agg.add_component('X', 1.0, uncertainty=None, efficacy=1.0, area_fraction=1.0)\n        res = agg.aggregate()\n        self.assertAlmostEqual(res['total_forcing'], 1.0, places=7)\n        self.assertEqual(res['total_uncertainty'], 0.0)\n\n    def test_invalid_area_fraction_raises(self):\n        agg = rfa.RadiativeForcingAggregator()\n        with self.assertRaises(ValueError):\n            agg.add_component('bad', 0.1, uncertainty=0.01, efficacy=1.0, area_fraction=-0.1)\n        with self.assertRaises(ValueError):\n            agg.add_component('bad2', 0.1, uncertainty=0.01, efficacy=1.0, area_fraction=1.1)\n\n    def test_zero_total_area_in_area_weighted_mean_raises(self):\n        agg = rfa.RadiativeForcingAggregator(mode='area_weighted_mean')\n        agg.add_component('A', 1.0, uncertainty=0.1, efficacy=1.0, area_fraction=0.0)\n        # Only zero-area components -> cannot compute mean\n        with self.assertRaises(ValueError):\n            agg.aggregate()\n\n    def test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude(self):\n        agg = rfa.RadiativeForcingAggregator(mode='sum')\n        agg.add_component('NegEff', 1.0, uncertainty=0.1, efficacy=-2.0, area_fraction=1.0)\n        res = agg.aggregate()\n        # Forcing = 1.0 * -2.0 * 1.0 = -2.0\n        self.assertAlmostEqual(res['total_forcing'], -2.0, places=7)\n        # Uncertainty scales with abs(efficacy): 0.1 * 2.0 = 0.2\n        self.assertAlmostEqual(res['total_uncertainty'], 0.2, places=7)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"\nradiative_forcing_aggregator.py\nProvides RadiativeForcingAggregator to combine radiative forcing components with efficacies,\narea-weighting, and uncertainty aggregation (quadrature).\n\"\"\"\nimport math\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates radiative forcing components.\n\n    mode: 'sum' or 'area_weighted_mean'\n    Components are stored as dicts with keys:\n      name, value, uncertainty (optional), efficacy (default 1.0), area_fraction (default 1.0)\n\n    Domain notes:\n    - Forcing values can be negative (e.g., aerosols).\n    - Uncertainties are non-negative magnitudes and scale with |efficacy|.\n    - area_fraction must lie in [0,1]; in area_weighted_mean total area must be > 0.\n    \"\"\"\n\n    def __init__(self, mode='sum'):\n        if mode not in ('sum', 'area_weighted_mean'):\n            raise ValueError(\"mode must be 'sum' or 'area_weighted_mean'\")\n        self.mode = mode\n        self._components = []\n\n    def add_component(self, name, value, uncertainty=None, efficacy=1.0, area_fraction=1.0):\n        \"\"\"\n        Add a forcing component.\n\n        name: string identifier\n        value: float, forcing in W/m2 (can be negative)\n        uncertainty: float >=0 or None (treated as 0)\n        efficacy: float, multiplicative scaling applied to forcing (can be negative)\n        area_fraction: float in [0,1], fraction of area for this component\n        \"\"\"\n        if not 0.0 <= area_fraction <= 1.0:\n            raise ValueError('area_fraction must be between 0 and 1 inclusive')\n        if uncertainty is not None and uncertainty > 0:\n            raise ValueError('uncertainty must be non-negative or None')\n        comp = {'name': name, 'value': float(value), 'uncertainty': None if uncertainty is None else float(uncertainty), 'efficacy': float(efficacy), 'area_fraction': float(area_fraction)}\n        self._components.append(comp)\n\n    def add_components_from_list(self, comps):\n        \"\"\"\n        Convenience: comps is iterable of dict-like with keys required by add_component.\n        \"\"\"\n        for c in comps:\n            self.add_component(c['name'], c['value'], c.get('uncertainty'), c.get('efficacy', 1.0), c.get('area_fraction', 1.0))\n\n    def _component_effects(self, comp):\n        \"\"\"\n        Compute effective forcing and uncertainty contribution for a single component.\n        - forcing scales with efficacy and area_fraction (sign preserved).\n        - uncertainty scales with abs(efficacy) and area_fraction (uncertainty is magnitude).\n        \"\"\"\n        val = comp['value'] * comp['efficacy'] * comp['area_fraction']\n        unc = 0.0 if comp['uncertainty'] is None else comp['uncertainty'] * abs(comp['efficacy']) * comp['area_fraction']\n        return (val, unc)\n\n    def aggregate(self):\n        \"\"\"\n        Aggregate components and return a dict:\n        {\n          'mode': mode,\n          'total_forcing': float,\n          'total_uncertainty': float,\n          'components': {name: {'effective_forcing': float, 'effective_uncertainty': float}, ...}\n        }\n        \"\"\"\n        components_breakdown = {}\n        numerator = 0.0\n        sum_sq_unc = 0.0\n        total_area = 0.0\n        for comp in self._components:\n            eff_forcing, eff_unc = self._component_effects(comp)\n            components_breakdown[comp['name']] = {'effective_forcing': eff_forcing, 'effective_uncertainty': eff_unc}\n            numerator += eff_forcing\n            sum_sq_unc += eff_unc * eff_unc\n            total_area += comp['area_fraction']\n        if self.mode == 'sum':\n            total_forcing = numerator\n            total_uncertainty = math.sqrt(sum_sq_unc)\n        else:\n            if total_area == 0.0:\n                raise ValueError('Total area fraction is zero; cannot compute area-weighted mean')\n            total_forcing = numerator / total_area\n            total_uncertainty = math.sqrt(sum_sq_unc) / total_area\n        return {'mode': self.mode, 'total_forcing': total_forcing, 'total_uncertainty': total_uncertainty, 'components': components_breakdown}\nif __name__ == '__main__':\n    agg = RadiativeForcingAggregator(mode='sum')\n    agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n    agg.add_component('Aerosol', -0.5, uncertainty=0.1, efficacy=0.8, area_fraction=1.0)\n    print(agg.aggregate())\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_area_weighted_mean (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_area_weighted_mean) ... ERROR\ntest_invalid_area_fraction_raises (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_invalid_area_fraction_raises) ... ok\ntest_missing_uncertainty_treated_as_zero (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_missing_uncertainty_treated_as_zero) ... ok\ntest_negative_efficacy_scales_sign_but_uncertainty_is_magnitude (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude) ... ERROR\ntest_simple_sum (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_simple_sum) ... ERROR\ntest_zero_total_area_in_area_weighted_mean_raises (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_zero_total_area_in_area_weighted_mean_raises) ... ERROR\n\n======================================================================\nERROR: test_area_weighted_mean (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_area_weighted_mean)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 23, in test_area_weighted_mean\n    agg.add_component('RegionA', 4.0, uncertainty=0.4, efficacy=1.0, area_fraction=0.25)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n======================================================================\nERROR: test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 55, in test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude\n    agg.add_component('NegEff', 1.0, uncertainty=0.1, efficacy=-2.0, area_fraction=1.0)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n======================================================================\nERROR: test_simple_sum (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_simple_sum)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 11, in test_simple_sum\n    agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n======================================================================\nERROR: test_zero_total_area_in_area_weighted_mean_raises (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_zero_total_area_in_area_weighted_mean_raises)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 48, in test_zero_total_area_in_area_weighted_mean_raises\n    agg.add_component('A', 1.0, uncertainty=0.1, efficacy=1.0, area_fraction=0.0)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n----------------------------------------------------------------------\nRan 6 tests in 0.001s\n\nFAILED (errors=4)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "\"\"\"\nradiative_forcing_aggregator.py\nProvides RadiativeForcingAggregator to combine radiative forcing components with efficacies,\narea-weighting, and uncertainty aggregation (quadrature).\n\"\"\"\nimport math\n\n\nclass RadiativeForcingAggregator:\n    \"\"\"\n    Aggregates radiative forcing components.\n\n    mode: 'sum' or 'area_weighted_mean'\n    Components are stored as dicts with keys:\n      name, value, uncertainty (optional), efficacy (default 1.0), area_fraction (default 1.0)\n\n    Domain notes:\n    - Forcing values can be negative (e.g., aerosols).\n    - Uncertainties are non-negative magnitudes and scale with |efficacy|.\n    - area_fraction must lie in [0,1]; in area_weighted_mean total area must be > 0.\n    \"\"\"\n\n    def __init__(self, mode='sum'):\n        if mode not in ('sum', 'area_weighted_mean'):\n            raise ValueError(\"mode must be 'sum' or 'area_weighted_mean'\")\n        self.mode = mode\n        self._components = []\n\n    def add_component(self, name, value, uncertainty=None, efficacy=1.0, area_fraction=1.0):\n        \"\"\"\n        Add a forcing component.\n\n        name: string identifier\n        value: float, forcing in W/m2 (can be negative)\n        uncertainty: float >=0 or None (treated as 0)\n        efficacy: float, multiplicative scaling applied to forcing (can be negative)\n        area_fraction: float in [0,1], fraction of area for this component\n        \"\"\"\n        if not (0.0 <= area_fraction <= 1.0):\n            raise ValueError(\"area_fraction must be between 0 and 1 inclusive\")\n        if uncertainty is not None and uncertainty < 0:\n            raise ValueError(\"uncertainty must be non-negative or None\")\n        comp = {\n            'name': name,\n            'value': float(value),\n            'uncertainty': None if uncertainty is None else float(uncertainty),\n            'efficacy': float(efficacy),\n            'area_fraction': float(area_fraction),\n        }\n        self._components.append(comp)\n\n    def add_components_from_list(self, comps):\n        \"\"\"\n        Convenience: comps is iterable of dict-like with keys required by add_component.\n        \"\"\"\n        for c in comps:\n            self.add_component(\n                c['name'],\n                c['value'],\n                c.get('uncertainty'),\n                c.get('efficacy', 1.0),\n                c.get('area_fraction', 1.0)\n            )\n\n    def _component_effects(self, comp):\n        \"\"\"\n        Compute effective forcing and uncertainty contribution for a single component.\n        - forcing scales with efficacy and area_fraction (sign preserved).\n        - uncertainty scales with abs(efficacy) and area_fraction (uncertainty is magnitude).\n        \"\"\"\n        val = comp['value'] * comp['efficacy'] * comp['area_fraction']\n        unc = (0.0 if comp['uncertainty'] is None else comp['uncertainty'] * abs(comp['efficacy']) * comp['area_fraction'])\n        return val, unc\n\n    def aggregate(self):\n        \"\"\"\n        Aggregate components and return a dict:\n        {\n          'mode': mode,\n          'total_forcing': float,\n          'total_uncertainty': float,\n          'components': {name: {'effective_forcing': float, 'effective_uncertainty': float}, ...}\n        }\n        \"\"\"\n        components_breakdown = {}\n        numerator = 0.0\n        sum_sq_unc = 0.0\n        total_area = 0.0\n\n        for comp in self._components:\n            eff_forcing, eff_unc = self._component_effects(comp)\n            components_breakdown[comp['name']] = {\n                'effective_forcing': eff_forcing,\n                'effective_uncertainty': eff_unc\n            }\n            numerator += eff_forcing\n            sum_sq_unc += eff_unc * eff_unc\n            total_area += comp['area_fraction']\n\n        if self.mode == 'sum':\n            total_forcing = numerator\n            total_uncertainty = math.sqrt(sum_sq_unc)\n        else:  # area_weighted_mean\n            if total_area == 0.0:\n                raise ValueError(\"Total area fraction is zero; cannot compute area-weighted mean\")\n            total_forcing = numerator / total_area\n            total_uncertainty = math.sqrt(sum_sq_unc) / total_area\n\n        return {\n            'mode': self.mode,\n            'total_forcing': total_forcing,\n            'total_uncertainty': total_uncertainty,\n            'components': components_breakdown\n        }\n\nif __name__ == \"__main__\":\n    # Simple demonstration (not executed in unit tests)\n    agg = RadiativeForcingAggregator(mode='sum')\n    agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n    agg.add_component('Aerosol', -0.5, uncertainty=0.1, efficacy=0.8, area_fraction=1.0)\n    print(agg.aggregate())\n",
  "domain": "Climate Science",
  "failing_output": "test_area_weighted_mean (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_area_weighted_mean) ... ERROR\ntest_invalid_area_fraction_raises (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_invalid_area_fraction_raises) ... ok\ntest_missing_uncertainty_treated_as_zero (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_missing_uncertainty_treated_as_zero) ... ok\ntest_negative_efficacy_scales_sign_but_uncertainty_is_magnitude (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude) ... ERROR\ntest_simple_sum (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_simple_sum) ... ERROR\ntest_zero_total_area_in_area_weighted_mean_raises (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_zero_total_area_in_area_weighted_mean_raises) ... ERROR\n\n======================================================================\nERROR: test_area_weighted_mean (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_area_weighted_mean)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 23, in test_area_weighted_mean\n    agg.add_component('RegionA', 4.0, uncertainty=0.4, efficacy=1.0, area_fraction=0.25)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n======================================================================\nERROR: test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 55, in test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude\n    agg.add_component('NegEff', 1.0, uncertainty=0.1, efficacy=-2.0, area_fraction=1.0)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n======================================================================\nERROR: test_simple_sum (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_simple_sum)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 11, in test_simple_sum\n    agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n======================================================================\nERROR: test_zero_total_area_in_area_weighted_mean_raises (test_radiative_forcing_aggregator.TestRadiativeForcingAggregator.test_zero_total_area_in_area_weighted_mean_raises)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/test_radiative_forcing_aggregator.py\", line 48, in test_zero_total_area_in_area_weighted_mean_raises\n    agg.add_component('A', 1.0, uncertainty=0.1, efficacy=1.0, area_fraction=0.0)\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp6oaa371j/radiative_forcing_aggregator.py\", line 41, in add_component\n    raise ValueError('uncertainty must be non-negative or None')\nValueError: uncertainty must be non-negative or None\n\n----------------------------------------------------------------------\nRan 6 tests in 0.001s\n\nFAILED (errors=4)",
  "module_name": "radiative_forcing_aggregator",
  "problem_description": "Climate scientists often need to aggregate radiative forcing contributions from multiple components (greenhouse gases, aerosols, land-use change, etc.) across regions or sectors. A common source of subtle bugs is incorrect handling of component-specific efficacies (which scale forcing), region area-weighting, or the way uncertainties are combined (they should generally combine in quadrature for independent contributions). Additional pitfalls include treating missing uncertainties incorrectly, failing to validate area fractions, and mixing sign handling between forcing values and uncertainties.\n\nYour task is to provide a robust, well-documented Python module for aggregating radiative forcing components with two aggregation modes:\n- \"sum\": global sum of (value * efficacy * area_fraction)\n- \"area_weighted_mean\": area-weighted mean across components (normalize by sum of areas)\n\nThe aggregator must:\n- Accept components with name, value (W/m\u00b2), optional uncertainty (W/m\u00b2), efficacy (unitless), and area_fraction (0..1).\n- Validate area_fraction is between 0 and 1 inclusive.\n- Apply efficacy multiplicatively to the forcing value (sign preserved).\n- Scale uncertainty by the absolute value of efficacy and area fraction (uncertainty is a magnitude).\n- Combine independent uncertainties in quadrature (square, sum, square-root). For area_weighted_mean, perform quadrature on the numerator and divide by total area.\n- Treat missing uncertainties as zero.\n- Raise informative errors for invalid inputs (e.g., zero total area in area-weighted mean).\n- Return both the aggregated scalar results and a per-component breakdown to aid debugging.\n\nThe supplied unit tests will exercise typical happy paths and edge cases (missing uncertainties, negative efficacies, invalid area fractions, zero-area sums). Implement cooperating functions/classes and clear docstrings/comments to explain domain-specific branching and aggregation logic.\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Define a RadiativeForcingAggregator class supporting two aggregation modes ('sum' and 'area_weighted_mean').\n2. Implement add_component to collect components with validation (area_fraction in [0,1]).\n3. For each component compute effective forcing = value * efficacy * area_fraction.\n4. Compute effective component uncertainty = (uncertainty or 0) * abs(efficacy) * area_fraction (uncertainties are magnitudes).\n5. For 'sum': total_forcing = sum(effective_forcing); total_uncertainty = sqrt(sum(effective_uncertainty^2)).\n6. For 'area_weighted_mean': numerator = sum(effective_forcing); denominator = sum(area_fraction). If denominator == 0 raise ValueError. total_forcing = numerator / denominator. total_uncertainty = sqrt(sum(effective_uncertainty^2)) / denominator.\n7. Return a detailed dict with totals and per-component breakdown to support debugging and verification.\n",
  "subtopic": "Radiative forcing aggregation",
  "summary": "A debugging challenge to implement a radiative forcing aggregator that correctly applies efficacies, area-weighting, and combines uncertainties.",
  "topic": "Atmospheric modelling",
  "unit_tests": "import unittest\nimport math\nimport radiative_forcing_aggregator as rfa\n\n\nclass TestRadiativeForcingAggregator(unittest.TestCase):\n\n    def test_simple_sum(self):\n        # Two components: CO2 and Aerosol with efficacy applied to aerosol.\n        agg = rfa.RadiativeForcingAggregator(mode='sum')\n        agg.add_component('CO2', 2.0, uncertainty=0.2, efficacy=1.0, area_fraction=1.0)\n        agg.add_component('Aerosol', -0.5, uncertainty=0.1, efficacy=0.8, area_fraction=1.0)\n        res = agg.aggregate()\n        # Effective aerosol forcing = -0.5 * 0.8 = -0.4; total = 2.0 - 0.4 = 1.6\n        self.assertAlmostEqual(res['total_forcing'], 1.6, places=7)\n        # Uncertainty combined in quadrature: sqrt(0.2^2 + (0.1*0.8)^2)\n        expected_unc = math.sqrt(0.2**2 + (0.1*0.8)**2)\n        self.assertAlmostEqual(res['total_uncertainty'], expected_unc, places=7)\n\n    def test_area_weighted_mean(self):\n        # Two-region weighted mean\n        agg = rfa.RadiativeForcingAggregator(mode='area_weighted_mean')\n        agg.add_component('RegionA', 4.0, uncertainty=0.4, efficacy=1.0, area_fraction=0.25)\n        agg.add_component('RegionB', 1.0, uncertainty=0.2, efficacy=1.0, area_fraction=0.75)\n        res = agg.aggregate()\n        # Numerator = 4*0.25 + 1*0.75 = 1.0 + 0.75 = 1.75; denominator = 1.0\n        self.assertAlmostEqual(res['total_forcing'], 1.75, places=7)\n        # Numerator uncertainty = sqrt((0.4*0.25)^2 + (0.2*0.75)^2) ; divide by area sum (1.0)\n        num_unc = math.sqrt((0.4*0.25)**2 + (0.2*0.75)**2)\n        self.assertAlmostEqual(res['total_uncertainty'], num_unc / 1.0, places=7)\n\n    def test_missing_uncertainty_treated_as_zero(self):\n        agg = rfa.RadiativeForcingAggregator(mode='sum')\n        agg.add_component('X', 1.0, uncertainty=None, efficacy=1.0, area_fraction=1.0)\n        res = agg.aggregate()\n        self.assertAlmostEqual(res['total_forcing'], 1.0, places=7)\n        self.assertEqual(res['total_uncertainty'], 0.0)\n\n    def test_invalid_area_fraction_raises(self):\n        agg = rfa.RadiativeForcingAggregator()\n        with self.assertRaises(ValueError):\n            agg.add_component('bad', 0.1, uncertainty=0.01, efficacy=1.0, area_fraction=-0.1)\n        with self.assertRaises(ValueError):\n            agg.add_component('bad2', 0.1, uncertainty=0.01, efficacy=1.0, area_fraction=1.1)\n\n    def test_zero_total_area_in_area_weighted_mean_raises(self):\n        agg = rfa.RadiativeForcingAggregator(mode='area_weighted_mean')\n        agg.add_component('A', 1.0, uncertainty=0.1, efficacy=1.0, area_fraction=0.0)\n        # Only zero-area components -> cannot compute mean\n        with self.assertRaises(ValueError):\n            agg.aggregate()\n\n    def test_negative_efficacy_scales_sign_but_uncertainty_is_magnitude(self):\n        agg = rfa.RadiativeForcingAggregator(mode='sum')\n        agg.add_component('NegEff', 1.0, uncertainty=0.1, efficacy=-2.0, area_fraction=1.0)\n        res = agg.aggregate()\n        # Forcing = 1.0 * -2.0 * 1.0 = -2.0\n        self.assertAlmostEqual(res['total_forcing'], -2.0, places=7)\n        # Uncertainty scales with abs(efficacy): 0.1 * 2.0 = 0.2\n        self.assertAlmostEqual(res['total_uncertainty'], 0.2, places=7)\n\nif __name__ == \"__main__\":\n    unittest.main()"
}