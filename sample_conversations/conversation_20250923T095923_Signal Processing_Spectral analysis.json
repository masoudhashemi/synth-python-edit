{
  "buggy_code": "\"\"\"\nwindowed_fft_anomaly.py\nSimple windowed FFT + spectral band anomaly detector using only the Python standard library.\n\"\"\"\nimport math\nimport cmath\nimport statistics\nfrom typing import List, Tuple, Dict, Optional\n\ndef _next_pow2(n: int) -> int:\n    \"\"\"Return smallest power of two >= n.\"\"\"\n    if n > 1:\n        return 1\n    p = 1\n    while p < n:\n        p <<= 1\n    return p\n\ndef fft(x: List[complex]) -> List[complex]:\n    \"\"\"\n    Cooley-Tukey recursive FFT. Input length must be a power of two.\n    Returns list of complex FFT bins.\n    \"\"\"\n    n = len(x)\n    if n == 1:\n        return [complex(x[0])]\n    if n % 2 != 0:\n        raise ValueError('FFT input length must be a power of two')\n    even = fft(x[0::2])\n    odd = fft(x[1::2])\n    out = [0] * n\n    for k in range(n // 2):\n        tw = cmath.exp(-2j * math.pi * k / n) * odd[k]\n        out[k] = even[k] + tw\n        out[k + n // 2] = even[k] - tw\n    return out\n\ndef hann_window(n: int) -> List[float]:\n    \"\"\"Return a Hann window of length n.\"\"\"\n    if n <= 0:\n        return []\n    return [0.5 * (1 - math.cos(2 * math.pi * i / (n - 1))) for i in range(n)]\n\ndef _apply_window_and_fft(frame: List[float]) -> List[complex]:\n    \"\"\"Apply Hann window and compute FFT on padded-to-power-of-two frame.\"\"\"\n    n = len(frame)\n    nfft = _next_pow2(n)\n    window = hann_window(n)\n    buf = [frame[i] * window[i] if i < n else 0.0 for i in range(nfft)]\n    buf_complex = [complex(v) for v in buf]\n    return fft(buf_complex)\n\ndef band_energy(frame: List[float], sampling_rate: float, band: Tuple[float, float]) -> Tuple[float, int]:\n    \"\"\"\n    Compute one-sided band energy for a frame.\n    Returns (energy, nfft) where energy is sum of PSD bins within band.\n    PSD normalized by nfft so energy scales appropriately with length.\n    \"\"\"\n    if sampling_rate <= 0:\n        raise ValueError('sampling_rate must be positive')\n    fmin, fmax = band\n    if fmin < 0:\n        fmin = 0.0\n    if fmax <= fmin:\n        return (0.0, _next_pow2(len(frame)))\n    n = len(frame)\n    nfft = _next_pow2(n)\n    X = _apply_window_and_fft(frame)\n    half = nfft // 2\n    psd = [abs(X[k]) ** 2 / nfft for k in range(half + 1)]\n    df = sampling_rate / nfft\n    kmin = int(math.floor(fmin / df))\n    kmax = int(math.floor(fmax / df))\n    kmin = max(0, kmin)\n    kmax = min(half, kmax)\n    if kmax < kmin:\n        return (0.0, nfft)\n    energy = sum(psd[kmin:kmax + 1])\n    return (energy, nfft)\n\ndef windowed_band_energies(signal: List[float], sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float]) -> List[Tuple[int, float, float]]:\n    \"\"\"\n    Slide a window across the signal and compute band energy for each window.\n    Returns a list of tuples: (start_sample, center_time_seconds, energy)\n    Pads the last frame with zeros if necessary; if signal shorter than window_size, one padded frame is produced.\n    \"\"\"\n    if window_size <= 0 or hop_size <= 0:\n        raise ValueError('window_size and hop_size must be positive integers')\n    n = len(signal)\n    if n == 0:\n        return []\n    energies = []\n    start = 0\n    while start < n:\n        end = start + window_size\n        frame = signal[start:end]\n        if len(frame) < window_size:\n            frame = frame + [0.0] * (window_size - len(frame))\n        energy, _ = band_energy(frame, sampling_rate, band)\n        center_time = (start + min(window_size, n, end) / 2) / sampling_rate\n        energies.append((start, center_time, energy))\n        start += hop_size\n    return energies\n\ndef detect_anomalies(energies: List[float], threshold_ratio: float=5.0, baseline_windows: int=5, min_zscore: float=3.0) -> List[int]:\n    \"\"\"\n    Given a sequence of scalar energies, flag indices that are anomalous.\n    For each index i we compute baseline mean/std from the preceding baseline_windows values (if available).\n    An index is anomalous if:\n      - energy / baseline_mean >= threshold_ratio (baseline_mean > 0), OR\n      - z-score >= min_zscore\n    If not enough previous windows exist to form a baseline (less than 1), we do not flag.\n    \"\"\"\n    if baseline_windows < 1:\n        raise ValueError('baseline_windows must be >= 1')\n    anomalies = []\n    for i, val in enumerate(energies):\n        start = max(0, i - baseline_windows)\n        baseline = energies[start:i]\n        if len(baseline) < 1:\n            continue\n        mean = statistics.mean(baseline)\n        if len(baseline) > 1:\n            stdev = statistics.pstdev(baseline)\n        else:\n            stdev = 0.0\n        ratio_flag = mean > 0 and val / mean >= threshold_ratio\n        if stdev > 0:\n            z = (val - mean) / stdev\n        else:\n            z = float('inf') if val > mean else 0.0\n        z_flag = z >= min_zscore\n        if ratio_flag or z_flag:\n            anomalies.append(i)\n    return anomalies\n\nclass SpectralAnomalyDetector:\n    \"\"\"\n    Encapsulates detection parameters and provides a process method.\n    \"\"\"\n\n    def __init__(self, sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float], threshold_ratio: float=5.0, baseline_windows: int=5, min_zscore: float=3.0):\n        self.sr = float(sampling_rate)\n        self.window_size = int(window_size)\n        self.hop_size = int(hop_size)\n        self.band = band\n        self.threshold_ratio = float(threshold_ratio)\n        self.baseline_windows = int(baseline_windows)\n        self.min_zscore = float(min_zscore)\n\n    def process(self, signal: List[float]) -> List[Dict]:\n        \"\"\"\n        Process the signal and return a list of anomaly dictionaries.\n        Each dict contains: index, start_sample, center_time, energy, baseline_mean (if available), zscore (approx).\n        \"\"\"\n        frames = windowed_band_energies(signal, self.sr, self.window_size, self.hop_size, self.band)\n        if not frames:\n            return []\n        energies = [e for _, _, e in frames]\n        anomaly_indices = detect_anomalies(energies, self.threshold_ratio, self.baseline_windows, self.min_zscore)\n        records = []\n        for idx in anomaly_indices:\n            start_sample, center_time, energy = frames[idx]\n            start = max(0, idx - self.baseline_windows)\n            baseline = energies[start:idx]\n            baseline_mean = statistics.mean(baseline) if baseline else 0.0\n            if len(baseline) > 1:\n                stdev = statistics.pstdev(baseline)\n            else:\n                stdev = 0.0\n            if stdev > 0:\n                z = (energy - baseline_mean) / stdev\n            else:\n                z = float('inf') if energy > baseline_mean else 0.0\n            records.append({'index': idx, 'start_sample': start_sample, 'center_time': center_time, 'energy': energy, 'baseline_mean': baseline_mean, 'zscore': z})\n        return records",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -9,7 +9,7 @@\n \n def _next_pow2(n: int) -> int:\n     \"\"\"Return smallest power of two >= n.\"\"\"\n-    if n < 1:\n+    if n > 1:\n         return 1\n     p = 1\n     while p < n:\n@@ -25,7 +25,7 @@\n     if n == 1:\n         return [complex(x[0])]\n     if n % 2 != 0:\n-        raise ValueError(\"FFT input length must be a power of two\")\n+        raise ValueError('FFT input length must be a power of two')\n     even = fft(x[0::2])\n     odd = fft(x[1::2])\n     out = [0] * n\n@@ -46,9 +46,7 @@\n     n = len(frame)\n     nfft = _next_pow2(n)\n     window = hann_window(n)\n-    # Apply window and pad with zeros to nfft\n-    buf = [ (frame[i] * window[i]) if i < n else 0.0 for i in range(nfft) ]\n-    # Ensure complex input\n+    buf = [frame[i] * window[i] if i < n else 0.0 for i in range(nfft)]\n     buf_complex = [complex(v) for v in buf]\n     return fft(buf_complex)\n \n@@ -59,29 +57,26 @@\n     PSD normalized by nfft so energy scales appropriately with length.\n     \"\"\"\n     if sampling_rate <= 0:\n-        raise ValueError(\"sampling_rate must be positive\")\n+        raise ValueError('sampling_rate must be positive')\n     fmin, fmax = band\n     if fmin < 0:\n         fmin = 0.0\n     if fmax <= fmin:\n-        return 0.0, _next_pow2(len(frame))\n+        return (0.0, _next_pow2(len(frame)))\n     n = len(frame)\n     nfft = _next_pow2(n)\n     X = _apply_window_and_fft(frame)\n-    # One-sided bins include 0 .. nfft//2\n     half = nfft // 2\n-    # Compute PSD: |X|^2 / nfft\n-    psd = [ (abs(X[k])**2) / nfft for k in range(half + 1) ]\n-    # Frequency resolution\n+    psd = [abs(X[k]) ** 2 / nfft for k in range(half + 1)]\n     df = sampling_rate / nfft\n     kmin = int(math.floor(fmin / df))\n     kmax = int(math.floor(fmax / df))\n     kmin = max(0, kmin)\n     kmax = min(half, kmax)\n     if kmax < kmin:\n-        return 0.0, nfft\n-    energy = sum(psd[kmin:kmax+1])\n-    return energy, nfft\n+        return (0.0, nfft)\n+    energy = sum(psd[kmin:kmax + 1])\n+    return (energy, nfft)\n \n def windowed_band_energies(signal: List[float], sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float]) -> List[Tuple[int, float, float]]:\n     \"\"\"\n@@ -90,7 +85,7 @@\n     Pads the last frame with zeros if necessary; if signal shorter than window_size, one padded frame is produced.\n     \"\"\"\n     if window_size <= 0 or hop_size <= 0:\n-        raise ValueError(\"window_size and hop_size must be positive integers\")\n+        raise ValueError('window_size and hop_size must be positive integers')\n     n = len(signal)\n     if n == 0:\n         return []\n@@ -100,16 +95,14 @@\n         end = start + window_size\n         frame = signal[start:end]\n         if len(frame) < window_size:\n-            # pad to full window\n             frame = frame + [0.0] * (window_size - len(frame))\n         energy, _ = band_energy(frame, sampling_rate, band)\n         center_time = (start + min(window_size, n, end) / 2) / sampling_rate\n         energies.append((start, center_time, energy))\n         start += hop_size\n-    # Ensure at least one frame if signal shorter than window (handled above)\n     return energies\n \n-def detect_anomalies(energies: List[float], threshold_ratio: float = 5.0, baseline_windows: int = 5, min_zscore: float = 3.0) -> List[int]:\n+def detect_anomalies(energies: List[float], threshold_ratio: float=5.0, baseline_windows: int=5, min_zscore: float=3.0) -> List[int]:\n     \"\"\"\n     Given a sequence of scalar energies, flag indices that are anomalous.\n     For each index i we compute baseline mean/std from the preceding baseline_windows values (if available).\n@@ -119,24 +112,22 @@\n     If not enough previous windows exist to form a baseline (less than 1), we do not flag.\n     \"\"\"\n     if baseline_windows < 1:\n-        raise ValueError(\"baseline_windows must be >= 1\")\n+        raise ValueError('baseline_windows must be >= 1')\n     anomalies = []\n     for i, val in enumerate(energies):\n         start = max(0, i - baseline_windows)\n         baseline = energies[start:i]\n         if len(baseline) < 1:\n-            continue  # not enough history to form a baseline\n+            continue\n         mean = statistics.mean(baseline)\n-        # If variance zero, handle specially\n         if len(baseline) > 1:\n             stdev = statistics.pstdev(baseline)\n         else:\n             stdev = 0.0\n-        ratio_flag = (mean > 0) and (val / mean >= threshold_ratio)\n+        ratio_flag = mean > 0 and val / mean >= threshold_ratio\n         if stdev > 0:\n             z = (val - mean) / stdev\n         else:\n-            # If baseline has zero variance, any value greater than mean is infinite z\n             z = float('inf') if val > mean else 0.0\n         z_flag = z >= min_zscore\n         if ratio_flag or z_flag:\n@@ -147,9 +138,8 @@\n     \"\"\"\n     Encapsulates detection parameters and provides a process method.\n     \"\"\"\n-    def __init__(self, sampling_rate: float, window_size: int, hop_size: int,\n-                 band: Tuple[float, float], threshold_ratio: float = 5.0,\n-                 baseline_windows: int = 5, min_zscore: float = 3.0):\n+\n+    def __init__(self, sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float], threshold_ratio: float=5.0, baseline_windows: int=5, min_zscore: float=3.0):\n         self.sr = float(sampling_rate)\n         self.window_size = int(window_size)\n         self.hop_size = int(hop_size)\n@@ -166,12 +156,11 @@\n         frames = windowed_band_energies(signal, self.sr, self.window_size, self.hop_size, self.band)\n         if not frames:\n             return []\n-        energies = [e for (_, _, e) in frames]\n+        energies = [e for _, _, e in frames]\n         anomaly_indices = detect_anomalies(energies, self.threshold_ratio, self.baseline_windows, self.min_zscore)\n         records = []\n         for idx in anomaly_indices:\n             start_sample, center_time, energy = frames[idx]\n-            # compute baseline stats for reporting\n             start = max(0, idx - self.baseline_windows)\n             baseline = energies[start:idx]\n             baseline_mean = statistics.mean(baseline) if baseline else 0.0\n@@ -183,12 +172,5 @@\n                 z = (energy - baseline_mean) / stdev\n             else:\n                 z = float('inf') if energy > baseline_mean else 0.0\n-            records.append({\n-                \"index\": idx,\n-                \"start_sample\": start_sample,\n-                \"center_time\": center_time,\n-                \"energy\": energy,\n-                \"baseline_mean\": baseline_mean,\n-                \"zscore\": z\n-            })\n-        return records\n+            records.append({'index': idx, 'start_sample': start_sample, 'center_time': center_time, 'energy': energy, 'baseline_mean': baseline_mean, 'zscore': z})\n+        return records",
  "conversation": [
    {
      "content": "Domain: Signal Processing | Topic: Spectral analysis | Subtopic: Windowed FFT anomaly detection\nYou are given time-series sensor data sampled at a known rate. Your task is to implement a compact, robust module that computes windowed FFTs, aggregates spectral energy within a specified frequency band for each window, and detects anomalous windows where that band energy exceeds a rolling baseline by either a ratio or a z-score threshold.\n\nConstraints and requirements:\n- Use only the Python standard library.\n- Implement your own FFT (Cooley-Tukey) and windowing (Hann).\n- Handle signals shorter than one analysis window by zero-padding to produce a single window.\n- Compute band energy using the one-sided power spectrum for real signals.\n- Provide an API with both functional helpers and a small detector class that encapsulates detection parameters.\n- Detection logic should be scientifically meaningful: compare the current window's band energy to the mean and standard deviation of a configurable number of preceding windows, and flag when either the energy ratio exceeds a threshold or the z-score exceeds another threshold.\n- Include sufficient docstrings and branching/aggregation logic, and ensure the behaviour is well-defined for edge cases (constant signals, zero variance baseline, very short records).\n\nThe resulting module should be suitable for integration into an automated monitoring pipeline where labeled anomalies are used for downstream alarms or inspections.\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Implement a recursive Cooley-Tukey FFT that pads to the next power of two when needed.\n2. Implement a Hann window generator and logic to apply it to each frame before FFT.\n3. Compute a one-sided power spectral density (PSD) for each window and sum PSD bins that fall inside the requested frequency band.\n4. Slide a window across the signal with a given hop size to produce a sequence of band energies and their center times.\n5. Implement anomaly detection that uses preceding windows to compute baseline mean and standard deviation; compute both a ratio and a z-score and flag anomalies when either exceeds configured thresholds.\n6. Provide a SpectralAnomalyDetector class to package parameters and a process method returning structured anomaly records. Include robust handling for edge cases (padding, zero baseline variance).",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`windowed_fft_anomaly.py`):\n```python\n\"\"\"\nwindowed_fft_anomaly.py\nSimple windowed FFT + spectral band anomaly detector using only the Python standard library.\n\"\"\"\nimport math\nimport cmath\nimport statistics\nfrom typing import List, Tuple, Dict, Optional\n\ndef _next_pow2(n: int) -> int:\n    \"\"\"Return smallest power of two >= n.\"\"\"\n    if n < 1:\n        return 1\n    p = 1\n    while p < n:\n        p <<= 1\n    return p\n\ndef fft(x: List[complex]) -> List[complex]:\n    \"\"\"\n    Cooley-Tukey recursive FFT. Input length must be a power of two.\n    Returns list of complex FFT bins.\n    \"\"\"\n    n = len(x)\n    if n == 1:\n        return [complex(x[0])]\n    if n % 2 != 0:\n        raise ValueError(\"FFT input length must be a power of two\")\n    even = fft(x[0::2])\n    odd = fft(x[1::2])\n    out = [0] * n\n    for k in range(n // 2):\n        tw = cmath.exp(-2j * math.pi * k / n) * odd[k]\n        out[k] = even[k] + tw\n        out[k + n // 2] = even[k] - tw\n    return out\n\ndef hann_window(n: int) -> List[float]:\n    \"\"\"Return a Hann window of length n.\"\"\"\n    if n <= 0:\n        return []\n    return [0.5 * (1 - math.cos(2 * math.pi * i / (n - 1))) for i in range(n)]\n\ndef _apply_window_and_fft(frame: List[float]) -> List[complex]:\n    \"\"\"Apply Hann window and compute FFT on padded-to-power-of-two frame.\"\"\"\n    n = len(frame)\n    nfft = _next_pow2(n)\n    window = hann_window(n)\n    # Apply window and pad with zeros to nfft\n    buf = [ (frame[i] * window[i]) if i < n else 0.0 for i in range(nfft) ]\n    # Ensure complex input\n    buf_complex = [complex(v) for v in buf]\n    return fft(buf_complex)\n\ndef band_energy(frame: List[float], sampling_rate: float, band: Tuple[float, float]) -> Tuple[float, int]:\n    \"\"\"\n    Compute one-sided band energy for a frame.\n    Returns (energy, nfft) where energy is sum of PSD bins within band.\n    PSD normalized by nfft so energy scales appropriately with length.\n    \"\"\"\n    if sampling_rate <= 0:\n        raise ValueError(\"sampling_rate must be positive\")\n    fmin, fmax = band\n    if fmin < 0:\n        fmin = 0.0\n    if fmax <= fmin:\n        return 0.0, _next_pow2(len(frame))\n    n = len(frame)\n    nfft = _next_pow2(n)\n    X = _apply_window_and_fft(frame)\n    # One-sided bins include 0 .. nfft//2\n    half = nfft // 2\n    # Compute PSD: |X|^2 / nfft\n    psd = [ (abs(X[k])**2) / nfft for k in range(half + 1) ]\n    # Frequency resolution\n    df = sampling_rate / nfft\n    kmin = int(math.floor(fmin / df))\n    kmax = int(math.floor(fmax / df))\n    kmin = max(0, kmin)\n    kmax = min(half, kmax)\n    if kmax < kmin:\n        return 0.0, nfft\n    energy = sum(psd[kmin:kmax+1])\n    return energy, nfft\n\ndef windowed_band_energies(signal: List[float], sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float]) -> List[Tuple[int, float, float]]:\n    \"\"\"\n    Slide a window across the signal and compute band energy for each window.\n    Returns a list of tuples: (start_sample, center_time_seconds, energy)\n    Pads the last frame with zeros if necessary; if signal shorter than window_size, one padded frame is produced.\n    \"\"\"\n    if window_size <= 0 or hop_size <= 0:\n        raise ValueError(\"window_size and hop_size must be positive integers\")\n    n = len(signal)\n    if n == 0:\n        return []\n    energies = []\n    start = 0\n    while start < n:\n        end = start + window_size\n        frame = signal[start:end]\n        if len(frame) < window_size:\n            # pad to full window\n            frame = frame + [0.0] * (window_size - len(frame))\n        energy, _ = band_energy(frame, sampling_rate, band)\n        center_time = (start + min(window_size, n, end) / 2) / sampling_rate\n        energies.append((start, center_time, energy))\n        start += hop_size\n    # Ensure at least one frame if signal shorter than window (handled above)\n    return energies\n\ndef detect_anomalies(energies: List[float], threshold_ratio: float = 5.0, baseline_windows: int = 5, min_zscore: float = 3.0) -> List[int]:\n    \"\"\"\n    Given a sequence of scalar energies, flag indices that are anomalous.\n    For each index i we compute baseline mean/std from the preceding baseline_windows values (if available).\n    An index is anomalous if:\n      - energy / baseline_mean >= threshold_ratio (baseline_mean > 0), OR\n      - z-score >= min_zscore\n    If not enough previous windows exist to form a baseline (less than 1), we do not flag.\n    \"\"\"\n    if baseline_windows < 1:\n        raise ValueError(\"baseline_windows must be >= 1\")\n    anomalies = []\n    for i, val in enumerate(energies):\n        start = max(0, i - baseline_windows)\n        baseline = energies[start:i]\n        if len(baseline) < 1:\n            continue  # not enough history to form a baseline\n        mean = statistics.mean(baseline)\n        # If variance zero, handle specially\n        if len(baseline) > 1:\n            stdev = statistics.pstdev(baseline)\n        else:\n            stdev = 0.0\n        ratio_flag = (mean > 0) and (val / mean >= threshold_ratio)\n        if stdev > 0:\n            z = (val - mean) / stdev\n        else:\n            # If baseline has zero variance, any value greater than mean is infinite z\n            z = float('inf') if val > mean else 0.0\n        z_flag = z >= min_zscore\n        if ratio_flag or z_flag:\n            anomalies.append(i)\n    return anomalies\n\nclass SpectralAnomalyDetector:\n    \"\"\"\n    Encapsulates detection parameters and provides a process method.\n    \"\"\"\n    def __init__(self, sampling_rate: float, window_size: int, hop_size: int,\n                 band: Tuple[float, float], threshold_ratio: float = 5.0,\n                 baseline_windows: int = 5, min_zscore: float = 3.0):\n        self.sr = float(sampling_rate)\n        self.window_size = int(window_size)\n        self.hop_size = int(hop_size)\n        self.band = band\n        self.threshold_ratio = float(threshold_ratio)\n        self.baseline_windows = int(baseline_windows)\n        self.min_zscore = float(min_zscore)\n\n    def process(self, signal: List[float]) -> List[Dict]:\n        \"\"\"\n        Process the signal and return a list of anomaly dictionaries.\n        Each dict contains: index, start_sample, center_time, energy, baseline_mean (if available), zscore (approx).\n        \"\"\"\n        frames = windowed_band_energies(signal, self.sr, self.window_size, self.hop_size, self.band)\n        if not frames:\n            return []\n        energies = [e for (_, _, e) in frames]\n        anomaly_indices = detect_anomalies(energies, self.threshold_ratio, self.baseline_windows, self.min_zscore)\n        records = []\n        for idx in anomaly_indices:\n            start_sample, center_time, energy = frames[idx]\n            # compute baseline stats for reporting\n            start = max(0, idx - self.baseline_windows)\n            baseline = energies[start:idx]\n            baseline_mean = statistics.mean(baseline) if baseline else 0.0\n            if len(baseline) > 1:\n                stdev = statistics.pstdev(baseline)\n            else:\n                stdev = 0.0\n            if stdev > 0:\n                z = (energy - baseline_mean) / stdev\n            else:\n                z = float('inf') if energy > baseline_mean else 0.0\n            records.append({\n                \"index\": idx,\n                \"start_sample\": start_sample,\n                \"center_time\": center_time,\n                \"energy\": energy,\n                \"baseline_mean\": baseline_mean,\n                \"zscore\": z\n            })\n        return records\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\nimport unittest\nimport math\nfrom windowed_fft_anomaly import fft, _next_pow2, band_energy, windowed_band_energies, detect_anomalies, SpectralAnomalyDetector\n\nclass TestFFTAndHelpers(unittest.TestCase):\n    def test_next_pow2(self):\n        self.assertEqual(_next_pow2(1), 1)\n        self.assertEqual(_next_pow2(2), 2)\n        self.assertEqual(_next_pow2(3), 4)\n        self.assertEqual(_next_pow2(9), 16)\n\n    def test_fft_delta(self):\n        # delta sequence should have all-ones spectrum\n        x = [1, 0, 0, 0]\n        X = fft([complex(v) for v in x])\n        for v in X:\n            self.assertAlmostEqual(abs(v), 1.0, places=12)\n\nclass TestBandEnergyAndWindowing(unittest.TestCase):\n    def test_band_energy_single_sine(self):\n        # Create a 8-sample 1 Hz sine sampled at 8 Hz -> one cycle across window\n        sr = 8.0\n        N = 8\n        f = 1.0\n        signal = [math.sin(2 * math.pi * f * t / sr) for t in range(N)]\n        energy, nfft = band_energy(signal, sr, (0.5, 1.5))\n        # Energy should be positive and nonzero\n        self.assertGreater(energy, 0.0)\n        self.assertEqual(nfft, 8)\n\n    def test_windowed_energies_padding_short_signal(self):\n        sr = 10.0\n        signal = [0.1, 0.2]  # shorter than window\n        frames = windowed_band_energies(signal, sr, window_size=16, hop_size=8, band=(0, 4))\n        # Should produce exactly one frame (padded)\n        self.assertEqual(len(frames), 1)\n\nclass TestAnomalyDetection(unittest.TestCase):\n    def test_detect_anomalies_basic(self):\n        # Energies where a single high value occurs after baseline\n        energies = [1.0] * 5 + [10.0] + [1.0] * 3\n        anomalies = detect_anomalies(energies, threshold_ratio=5.0, baseline_windows=5, min_zscore=3.0)\n        # The high energy at index 5 should be flagged\n        self.assertIn(5, anomalies)\n\n    def test_detector_on_burst_signal(self):\n        # Build a signal of 256 samples, sr=64, burst between samples 96..160 of a 10Hz sine\n        sr = 64.0\n        N = 256\n        f_burst = 10.0\n        signal = []\n        for i in range(N):\n            if 96 <= i < 160:\n                # burst amplitude 1.0\n                signal.append(math.sin(2 * math.pi * f_burst * i / sr))\n            else:\n                signal.append(0.0)\n        detector = SpectralAnomalyDetector(sampling_rate=sr, window_size=64, hop_size=32, band=(8.0, 12.0),\n                                           threshold_ratio=4.0, baseline_windows=3, min_zscore=2.5)\n        records = detector.process(signal)\n        # Should find at least one anomaly corresponding to the burst region\n        self.assertTrue(len(records) >= 1)\n        # Ensure reported center times fall inside burst interval for at least one record\n        found = any( (rec[\"center_time\"] * sr) >= 96 and (rec[\"center_time\"] * sr) < 160 for rec in records )\n        self.assertTrue(found)\n\n    def test_constant_signal_no_anomalies(self):\n        sr = 50.0\n        signal = [0.5] * 200\n        detector = SpectralAnomalyDetector(sampling_rate=sr, window_size=50, hop_size=25, band=(0.1, 5.0),\n                                           threshold_ratio=2.0, baseline_windows=5, min_zscore=3.0)\n        records = detector.process(signal)\n        self.assertEqual(records, [])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"\nwindowed_fft_anomaly.py\nSimple windowed FFT + spectral band anomaly detector using only the Python standard library.\n\"\"\"\nimport math\nimport cmath\nimport statistics\nfrom typing import List, Tuple, Dict, Optional\n\ndef _next_pow2(n: int) -> int:\n    \"\"\"Return smallest power of two >= n.\"\"\"\n    if n > 1:\n        return 1\n    p = 1\n    while p < n:\n        p <<= 1\n    return p\n\ndef fft(x: List[complex]) -> List[complex]:\n    \"\"\"\n    Cooley-Tukey recursive FFT. Input length must be a power of two.\n    Returns list of complex FFT bins.\n    \"\"\"\n    n = len(x)\n    if n == 1:\n        return [complex(x[0])]\n    if n % 2 != 0:\n        raise ValueError('FFT input length must be a power of two')\n    even = fft(x[0::2])\n    odd = fft(x[1::2])\n    out = [0] * n\n    for k in range(n // 2):\n        tw = cmath.exp(-2j * math.pi * k / n) * odd[k]\n        out[k] = even[k] + tw\n        out[k + n // 2] = even[k] - tw\n    return out\n\ndef hann_window(n: int) -> List[float]:\n    \"\"\"Return a Hann window of length n.\"\"\"\n    if n <= 0:\n        return []\n    return [0.5 * (1 - math.cos(2 * math.pi * i / (n - 1))) for i in range(n)]\n\ndef _apply_window_and_fft(frame: List[float]) -> List[complex]:\n    \"\"\"Apply Hann window and compute FFT on padded-to-power-of-two frame.\"\"\"\n    n = len(frame)\n    nfft = _next_pow2(n)\n    window = hann_window(n)\n    buf = [frame[i] * window[i] if i < n else 0.0 for i in range(nfft)]\n    buf_complex = [complex(v) for v in buf]\n    return fft(buf_complex)\n\ndef band_energy(frame: List[float], sampling_rate: float, band: Tuple[float, float]) -> Tuple[float, int]:\n    \"\"\"\n    Compute one-sided band energy for a frame.\n    Returns (energy, nfft) where energy is sum of PSD bins within band.\n    PSD normalized by nfft so energy scales appropriately with length.\n    \"\"\"\n    if sampling_rate <= 0:\n        raise ValueError('sampling_rate must be positive')\n    fmin, fmax = band\n    if fmin < 0:\n        fmin = 0.0\n    if fmax <= fmin:\n        return (0.0, _next_pow2(len(frame)))\n    n = len(frame)\n    nfft = _next_pow2(n)\n    X = _apply_window_and_fft(frame)\n    half = nfft // 2\n    psd = [abs(X[k]) ** 2 / nfft for k in range(half + 1)]\n    df = sampling_rate / nfft\n    kmin = int(math.floor(fmin / df))\n    kmax = int(math.floor(fmax / df))\n    kmin = max(0, kmin)\n    kmax = min(half, kmax)\n    if kmax < kmin:\n        return (0.0, nfft)\n    energy = sum(psd[kmin:kmax + 1])\n    return (energy, nfft)\n\ndef windowed_band_energies(signal: List[float], sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float]) -> List[Tuple[int, float, float]]:\n    \"\"\"\n    Slide a window across the signal and compute band energy for each window.\n    Returns a list of tuples: (start_sample, center_time_seconds, energy)\n    Pads the last frame with zeros if necessary; if signal shorter than window_size, one padded frame is produced.\n    \"\"\"\n    if window_size <= 0 or hop_size <= 0:\n        raise ValueError('window_size and hop_size must be positive integers')\n    n = len(signal)\n    if n == 0:\n        return []\n    energies = []\n    start = 0\n    while start < n:\n        end = start + window_size\n        frame = signal[start:end]\n        if len(frame) < window_size:\n            frame = frame + [0.0] * (window_size - len(frame))\n        energy, _ = band_energy(frame, sampling_rate, band)\n        center_time = (start + min(window_size, n, end) / 2) / sampling_rate\n        energies.append((start, center_time, energy))\n        start += hop_size\n    return energies\n\ndef detect_anomalies(energies: List[float], threshold_ratio: float=5.0, baseline_windows: int=5, min_zscore: float=3.0) -> List[int]:\n    \"\"\"\n    Given a sequence of scalar energies, flag indices that are anomalous.\n    For each index i we compute baseline mean/std from the preceding baseline_windows values (if available).\n    An index is anomalous if:\n      - energy / baseline_mean >= threshold_ratio (baseline_mean > 0), OR\n      - z-score >= min_zscore\n    If not enough previous windows exist to form a baseline (less than 1), we do not flag.\n    \"\"\"\n    if baseline_windows < 1:\n        raise ValueError('baseline_windows must be >= 1')\n    anomalies = []\n    for i, val in enumerate(energies):\n        start = max(0, i - baseline_windows)\n        baseline = energies[start:i]\n        if len(baseline) < 1:\n            continue\n        mean = statistics.mean(baseline)\n        if len(baseline) > 1:\n            stdev = statistics.pstdev(baseline)\n        else:\n            stdev = 0.0\n        ratio_flag = mean > 0 and val / mean >= threshold_ratio\n        if stdev > 0:\n            z = (val - mean) / stdev\n        else:\n            z = float('inf') if val > mean else 0.0\n        z_flag = z >= min_zscore\n        if ratio_flag or z_flag:\n            anomalies.append(i)\n    return anomalies\n\nclass SpectralAnomalyDetector:\n    \"\"\"\n    Encapsulates detection parameters and provides a process method.\n    \"\"\"\n\n    def __init__(self, sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float], threshold_ratio: float=5.0, baseline_windows: int=5, min_zscore: float=3.0):\n        self.sr = float(sampling_rate)\n        self.window_size = int(window_size)\n        self.hop_size = int(hop_size)\n        self.band = band\n        self.threshold_ratio = float(threshold_ratio)\n        self.baseline_windows = int(baseline_windows)\n        self.min_zscore = float(min_zscore)\n\n    def process(self, signal: List[float]) -> List[Dict]:\n        \"\"\"\n        Process the signal and return a list of anomaly dictionaries.\n        Each dict contains: index, start_sample, center_time, energy, baseline_mean (if available), zscore (approx).\n        \"\"\"\n        frames = windowed_band_energies(signal, self.sr, self.window_size, self.hop_size, self.band)\n        if not frames:\n            return []\n        energies = [e for _, _, e in frames]\n        anomaly_indices = detect_anomalies(energies, self.threshold_ratio, self.baseline_windows, self.min_zscore)\n        records = []\n        for idx in anomaly_indices:\n            start_sample, center_time, energy = frames[idx]\n            start = max(0, idx - self.baseline_windows)\n            baseline = energies[start:idx]\n            baseline_mean = statistics.mean(baseline) if baseline else 0.0\n            if len(baseline) > 1:\n                stdev = statistics.pstdev(baseline)\n            else:\n                stdev = 0.0\n            if stdev > 0:\n                z = (energy - baseline_mean) / stdev\n            else:\n                z = float('inf') if energy > baseline_mean else 0.0\n            records.append({'index': idx, 'start_sample': start_sample, 'center_time': center_time, 'energy': energy, 'baseline_mean': baseline_mean, 'zscore': z})\n        return records\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_constant_signal_no_anomalies (test_windowed_fft_anomaly.TestAnomalyDetection.test_constant_signal_no_anomalies) ... ok\ntest_detect_anomalies_basic (test_windowed_fft_anomaly.TestAnomalyDetection.test_detect_anomalies_basic) ... ok\ntest_detector_on_burst_signal (test_windowed_fft_anomaly.TestAnomalyDetection.test_detector_on_burst_signal) ... FAIL\ntest_band_energy_single_sine (test_windowed_fft_anomaly.TestBandEnergyAndWindowing.test_band_energy_single_sine) ... FAIL\ntest_windowed_energies_padding_short_signal (test_windowed_fft_anomaly.TestBandEnergyAndWindowing.test_windowed_energies_padding_short_signal) ... ok\ntest_fft_delta (test_windowed_fft_anomaly.TestFFTAndHelpers.test_fft_delta) ... ok\ntest_next_pow2 (test_windowed_fft_anomaly.TestFFTAndHelpers.test_next_pow2) ... FAIL\n\n======================================================================\nFAIL: test_detector_on_burst_signal (test_windowed_fft_anomaly.TestAnomalyDetection.test_detector_on_burst_signal)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp7omyyc19/test_windowed_fft_anomaly.py\", line 62, in test_detector_on_burst_signal\n    self.assertTrue(len(records) >= 1)\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^\nAssertionError: False is not true\n\n======================================================================\nFAIL: test_band_energy_single_sine (test_windowed_fft_anomaly.TestBandEnergyAndWindowing.test_band_energy_single_sine)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp7omyyc19/test_windowed_fft_anomaly.py\", line 28, in test_band_energy_single_sine\n    self.assertGreater(energy, 0.0)\n    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^\nAssertionError: 0.0 not greater than 0.0\n\n======================================================================\nFAIL: test_next_pow2 (test_windowed_fft_anomaly.TestFFTAndHelpers.test_next_pow2)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp7omyyc19/test_windowed_fft_anomaly.py\", line 8, in test_next_pow2\n    self.assertEqual(_next_pow2(2), 2)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nAssertionError: 1 != 2\n\n----------------------------------------------------------------------\nRan 7 tests in 0.001s\n\nFAILED (failures=3)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "\"\"\"\nwindowed_fft_anomaly.py\nSimple windowed FFT + spectral band anomaly detector using only the Python standard library.\n\"\"\"\nimport math\nimport cmath\nimport statistics\nfrom typing import List, Tuple, Dict, Optional\n\ndef _next_pow2(n: int) -> int:\n    \"\"\"Return smallest power of two >= n.\"\"\"\n    if n < 1:\n        return 1\n    p = 1\n    while p < n:\n        p <<= 1\n    return p\n\ndef fft(x: List[complex]) -> List[complex]:\n    \"\"\"\n    Cooley-Tukey recursive FFT. Input length must be a power of two.\n    Returns list of complex FFT bins.\n    \"\"\"\n    n = len(x)\n    if n == 1:\n        return [complex(x[0])]\n    if n % 2 != 0:\n        raise ValueError(\"FFT input length must be a power of two\")\n    even = fft(x[0::2])\n    odd = fft(x[1::2])\n    out = [0] * n\n    for k in range(n // 2):\n        tw = cmath.exp(-2j * math.pi * k / n) * odd[k]\n        out[k] = even[k] + tw\n        out[k + n // 2] = even[k] - tw\n    return out\n\ndef hann_window(n: int) -> List[float]:\n    \"\"\"Return a Hann window of length n.\"\"\"\n    if n <= 0:\n        return []\n    return [0.5 * (1 - math.cos(2 * math.pi * i / (n - 1))) for i in range(n)]\n\ndef _apply_window_and_fft(frame: List[float]) -> List[complex]:\n    \"\"\"Apply Hann window and compute FFT on padded-to-power-of-two frame.\"\"\"\n    n = len(frame)\n    nfft = _next_pow2(n)\n    window = hann_window(n)\n    # Apply window and pad with zeros to nfft\n    buf = [ (frame[i] * window[i]) if i < n else 0.0 for i in range(nfft) ]\n    # Ensure complex input\n    buf_complex = [complex(v) for v in buf]\n    return fft(buf_complex)\n\ndef band_energy(frame: List[float], sampling_rate: float, band: Tuple[float, float]) -> Tuple[float, int]:\n    \"\"\"\n    Compute one-sided band energy for a frame.\n    Returns (energy, nfft) where energy is sum of PSD bins within band.\n    PSD normalized by nfft so energy scales appropriately with length.\n    \"\"\"\n    if sampling_rate <= 0:\n        raise ValueError(\"sampling_rate must be positive\")\n    fmin, fmax = band\n    if fmin < 0:\n        fmin = 0.0\n    if fmax <= fmin:\n        return 0.0, _next_pow2(len(frame))\n    n = len(frame)\n    nfft = _next_pow2(n)\n    X = _apply_window_and_fft(frame)\n    # One-sided bins include 0 .. nfft//2\n    half = nfft // 2\n    # Compute PSD: |X|^2 / nfft\n    psd = [ (abs(X[k])**2) / nfft for k in range(half + 1) ]\n    # Frequency resolution\n    df = sampling_rate / nfft\n    kmin = int(math.floor(fmin / df))\n    kmax = int(math.floor(fmax / df))\n    kmin = max(0, kmin)\n    kmax = min(half, kmax)\n    if kmax < kmin:\n        return 0.0, nfft\n    energy = sum(psd[kmin:kmax+1])\n    return energy, nfft\n\ndef windowed_band_energies(signal: List[float], sampling_rate: float, window_size: int, hop_size: int, band: Tuple[float, float]) -> List[Tuple[int, float, float]]:\n    \"\"\"\n    Slide a window across the signal and compute band energy for each window.\n    Returns a list of tuples: (start_sample, center_time_seconds, energy)\n    Pads the last frame with zeros if necessary; if signal shorter than window_size, one padded frame is produced.\n    \"\"\"\n    if window_size <= 0 or hop_size <= 0:\n        raise ValueError(\"window_size and hop_size must be positive integers\")\n    n = len(signal)\n    if n == 0:\n        return []\n    energies = []\n    start = 0\n    while start < n:\n        end = start + window_size\n        frame = signal[start:end]\n        if len(frame) < window_size:\n            # pad to full window\n            frame = frame + [0.0] * (window_size - len(frame))\n        energy, _ = band_energy(frame, sampling_rate, band)\n        center_time = (start + min(window_size, n, end) / 2) / sampling_rate\n        energies.append((start, center_time, energy))\n        start += hop_size\n    # Ensure at least one frame if signal shorter than window (handled above)\n    return energies\n\ndef detect_anomalies(energies: List[float], threshold_ratio: float = 5.0, baseline_windows: int = 5, min_zscore: float = 3.0) -> List[int]:\n    \"\"\"\n    Given a sequence of scalar energies, flag indices that are anomalous.\n    For each index i we compute baseline mean/std from the preceding baseline_windows values (if available).\n    An index is anomalous if:\n      - energy / baseline_mean >= threshold_ratio (baseline_mean > 0), OR\n      - z-score >= min_zscore\n    If not enough previous windows exist to form a baseline (less than 1), we do not flag.\n    \"\"\"\n    if baseline_windows < 1:\n        raise ValueError(\"baseline_windows must be >= 1\")\n    anomalies = []\n    for i, val in enumerate(energies):\n        start = max(0, i - baseline_windows)\n        baseline = energies[start:i]\n        if len(baseline) < 1:\n            continue  # not enough history to form a baseline\n        mean = statistics.mean(baseline)\n        # If variance zero, handle specially\n        if len(baseline) > 1:\n            stdev = statistics.pstdev(baseline)\n        else:\n            stdev = 0.0\n        ratio_flag = (mean > 0) and (val / mean >= threshold_ratio)\n        if stdev > 0:\n            z = (val - mean) / stdev\n        else:\n            # If baseline has zero variance, any value greater than mean is infinite z\n            z = float('inf') if val > mean else 0.0\n        z_flag = z >= min_zscore\n        if ratio_flag or z_flag:\n            anomalies.append(i)\n    return anomalies\n\nclass SpectralAnomalyDetector:\n    \"\"\"\n    Encapsulates detection parameters and provides a process method.\n    \"\"\"\n    def __init__(self, sampling_rate: float, window_size: int, hop_size: int,\n                 band: Tuple[float, float], threshold_ratio: float = 5.0,\n                 baseline_windows: int = 5, min_zscore: float = 3.0):\n        self.sr = float(sampling_rate)\n        self.window_size = int(window_size)\n        self.hop_size = int(hop_size)\n        self.band = band\n        self.threshold_ratio = float(threshold_ratio)\n        self.baseline_windows = int(baseline_windows)\n        self.min_zscore = float(min_zscore)\n\n    def process(self, signal: List[float]) -> List[Dict]:\n        \"\"\"\n        Process the signal and return a list of anomaly dictionaries.\n        Each dict contains: index, start_sample, center_time, energy, baseline_mean (if available), zscore (approx).\n        \"\"\"\n        frames = windowed_band_energies(signal, self.sr, self.window_size, self.hop_size, self.band)\n        if not frames:\n            return []\n        energies = [e for (_, _, e) in frames]\n        anomaly_indices = detect_anomalies(energies, self.threshold_ratio, self.baseline_windows, self.min_zscore)\n        records = []\n        for idx in anomaly_indices:\n            start_sample, center_time, energy = frames[idx]\n            # compute baseline stats for reporting\n            start = max(0, idx - self.baseline_windows)\n            baseline = energies[start:idx]\n            baseline_mean = statistics.mean(baseline) if baseline else 0.0\n            if len(baseline) > 1:\n                stdev = statistics.pstdev(baseline)\n            else:\n                stdev = 0.0\n            if stdev > 0:\n                z = (energy - baseline_mean) / stdev\n            else:\n                z = float('inf') if energy > baseline_mean else 0.0\n            records.append({\n                \"index\": idx,\n                \"start_sample\": start_sample,\n                \"center_time\": center_time,\n                \"energy\": energy,\n                \"baseline_mean\": baseline_mean,\n                \"zscore\": z\n            })\n        return records\n",
  "domain": "Signal Processing",
  "failing_output": "test_constant_signal_no_anomalies (test_windowed_fft_anomaly.TestAnomalyDetection.test_constant_signal_no_anomalies) ... ok\ntest_detect_anomalies_basic (test_windowed_fft_anomaly.TestAnomalyDetection.test_detect_anomalies_basic) ... ok\ntest_detector_on_burst_signal (test_windowed_fft_anomaly.TestAnomalyDetection.test_detector_on_burst_signal) ... FAIL\ntest_band_energy_single_sine (test_windowed_fft_anomaly.TestBandEnergyAndWindowing.test_band_energy_single_sine) ... FAIL\ntest_windowed_energies_padding_short_signal (test_windowed_fft_anomaly.TestBandEnergyAndWindowing.test_windowed_energies_padding_short_signal) ... ok\ntest_fft_delta (test_windowed_fft_anomaly.TestFFTAndHelpers.test_fft_delta) ... ok\ntest_next_pow2 (test_windowed_fft_anomaly.TestFFTAndHelpers.test_next_pow2) ... FAIL\n\n======================================================================\nFAIL: test_detector_on_burst_signal (test_windowed_fft_anomaly.TestAnomalyDetection.test_detector_on_burst_signal)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp7omyyc19/test_windowed_fft_anomaly.py\", line 62, in test_detector_on_burst_signal\n    self.assertTrue(len(records) >= 1)\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^\nAssertionError: False is not true\n\n======================================================================\nFAIL: test_band_energy_single_sine (test_windowed_fft_anomaly.TestBandEnergyAndWindowing.test_band_energy_single_sine)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp7omyyc19/test_windowed_fft_anomaly.py\", line 28, in test_band_energy_single_sine\n    self.assertGreater(energy, 0.0)\n    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^\nAssertionError: 0.0 not greater than 0.0\n\n======================================================================\nFAIL: test_next_pow2 (test_windowed_fft_anomaly.TestFFTAndHelpers.test_next_pow2)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmp7omyyc19/test_windowed_fft_anomaly.py\", line 8, in test_next_pow2\n    self.assertEqual(_next_pow2(2), 2)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nAssertionError: 1 != 2\n\n----------------------------------------------------------------------\nRan 7 tests in 0.001s\n\nFAILED (failures=3)",
  "module_name": "windowed_fft_anomaly",
  "problem_description": "You are given time-series sensor data sampled at a known rate. Your task is to implement a compact, robust module that computes windowed FFTs, aggregates spectral energy within a specified frequency band for each window, and detects anomalous windows where that band energy exceeds a rolling baseline by either a ratio or a z-score threshold.\n\nConstraints and requirements:\n- Use only the Python standard library.\n- Implement your own FFT (Cooley-Tukey) and windowing (Hann).\n- Handle signals shorter than one analysis window by zero-padding to produce a single window.\n- Compute band energy using the one-sided power spectrum for real signals.\n- Provide an API with both functional helpers and a small detector class that encapsulates detection parameters.\n- Detection logic should be scientifically meaningful: compare the current window's band energy to the mean and standard deviation of a configurable number of preceding windows, and flag when either the energy ratio exceeds a threshold or the z-score exceeds another threshold.\n- Include sufficient docstrings and branching/aggregation logic, and ensure the behaviour is well-defined for edge cases (constant signals, zero variance baseline, very short records).\n\nThe resulting module should be suitable for integration into an automated monitoring pipeline where labeled anomalies are used for downstream alarms or inspections.\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Implement a recursive Cooley-Tukey FFT that pads to the next power of two when needed.\n2. Implement a Hann window generator and logic to apply it to each frame before FFT.\n3. Compute a one-sided power spectral density (PSD) for each window and sum PSD bins that fall inside the requested frequency band.\n4. Slide a window across the signal with a given hop size to produce a sequence of band energies and their center times.\n5. Implement anomaly detection that uses preceding windows to compute baseline mean and standard deviation; compute both a ratio and a z-score and flag anomalies when either exceeds configured thresholds.\n6. Provide a SpectralAnomalyDetector class to package parameters and a process method returning structured anomaly records. Include robust handling for edge cases (padding, zero baseline variance).\n",
  "subtopic": "Windowed FFT anomaly detection",
  "summary": "Windowed FFT-based detector that flags anomalous spectral energy in a frequency band relative to a rolling baseline.",
  "topic": "Spectral analysis",
  "unit_tests": "import unittest\nimport math\nfrom windowed_fft_anomaly import fft, _next_pow2, band_energy, windowed_band_energies, detect_anomalies, SpectralAnomalyDetector\n\nclass TestFFTAndHelpers(unittest.TestCase):\n    def test_next_pow2(self):\n        self.assertEqual(_next_pow2(1), 1)\n        self.assertEqual(_next_pow2(2), 2)\n        self.assertEqual(_next_pow2(3), 4)\n        self.assertEqual(_next_pow2(9), 16)\n\n    def test_fft_delta(self):\n        # delta sequence should have all-ones spectrum\n        x = [1, 0, 0, 0]\n        X = fft([complex(v) for v in x])\n        for v in X:\n            self.assertAlmostEqual(abs(v), 1.0, places=12)\n\nclass TestBandEnergyAndWindowing(unittest.TestCase):\n    def test_band_energy_single_sine(self):\n        # Create a 8-sample 1 Hz sine sampled at 8 Hz -> one cycle across window\n        sr = 8.0\n        N = 8\n        f = 1.0\n        signal = [math.sin(2 * math.pi * f * t / sr) for t in range(N)]\n        energy, nfft = band_energy(signal, sr, (0.5, 1.5))\n        # Energy should be positive and nonzero\n        self.assertGreater(energy, 0.0)\n        self.assertEqual(nfft, 8)\n\n    def test_windowed_energies_padding_short_signal(self):\n        sr = 10.0\n        signal = [0.1, 0.2]  # shorter than window\n        frames = windowed_band_energies(signal, sr, window_size=16, hop_size=8, band=(0, 4))\n        # Should produce exactly one frame (padded)\n        self.assertEqual(len(frames), 1)\n\nclass TestAnomalyDetection(unittest.TestCase):\n    def test_detect_anomalies_basic(self):\n        # Energies where a single high value occurs after baseline\n        energies = [1.0] * 5 + [10.0] + [1.0] * 3\n        anomalies = detect_anomalies(energies, threshold_ratio=5.0, baseline_windows=5, min_zscore=3.0)\n        # The high energy at index 5 should be flagged\n        self.assertIn(5, anomalies)\n\n    def test_detector_on_burst_signal(self):\n        # Build a signal of 256 samples, sr=64, burst between samples 96..160 of a 10Hz sine\n        sr = 64.0\n        N = 256\n        f_burst = 10.0\n        signal = []\n        for i in range(N):\n            if 96 <= i < 160:\n                # burst amplitude 1.0\n                signal.append(math.sin(2 * math.pi * f_burst * i / sr))\n            else:\n                signal.append(0.0)\n        detector = SpectralAnomalyDetector(sampling_rate=sr, window_size=64, hop_size=32, band=(8.0, 12.0),\n                                           threshold_ratio=4.0, baseline_windows=3, min_zscore=2.5)\n        records = detector.process(signal)\n        # Should find at least one anomaly corresponding to the burst region\n        self.assertTrue(len(records) >= 1)\n        # Ensure reported center times fall inside burst interval for at least one record\n        found = any( (rec[\"center_time\"] * sr) >= 96 and (rec[\"center_time\"] * sr) < 160 for rec in records )\n        self.assertTrue(found)\n\n    def test_constant_signal_no_anomalies(self):\n        sr = 50.0\n        signal = [0.5] * 200\n        detector = SpectralAnomalyDetector(sampling_rate=sr, window_size=50, hop_size=25, band=(0.1, 5.0),\n                                           threshold_ratio=2.0, baseline_windows=5, min_zscore=3.0)\n        records = detector.process(signal)\n        self.assertEqual(records, [])\n\nif __name__ == \"__main__\":\n    unittest.main()"
}