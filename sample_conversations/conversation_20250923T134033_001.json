{
  "buggy_code": "\"\"\"\nTools to compute steady states of linearized gene regulatory networks:\nSolve A x = -b for steady-state x. Uses RREF (pure Python) to handle singular and underdetermined systems.\n\"\"\"\nfrom typing import List, Tuple\nEPS = 1e-12\n\nclass InconsistentSystemError(Exception):\n    \"\"\"Raised when the linear system A x = -b has no solution.\"\"\"\n    pass\n\ndef _to_float_matrix(A: List[List[float]], b: List[float]) -> List[List[float]]:\n    \"\"\"Build augmented matrix [A | b] as floats.\"\"\"\n    return [[float(v) for v in row] + [float(bi)] for row, bi in zip(A, b)]\n\ndef _rref_augmented(A: List[List[float]], b: List[float]) -> Tuple[List[List[float]], List[int]]:\n    \"\"\"\n    Compute RREF of augmented matrix [A | b].\n    Returns (rref_matrix, pivot_columns) where pivot_columns lists pivot column indices (0..n-1) in order by row.\n    \"\"\"\n    m = _to_float_matrix(A, b)\n    rows = len(m)\n    if rows == 0:\n        return (m, [])\n    cols = len(m[0]) - 1\n    pivot_row = 0\n    pivot_cols = []\n    for col in range(cols):\n        sel = max(range(pivot_row, rows), key=lambda r: abs(m[r][col])) if pivot_row > rows else None\n        if sel is None or abs(m[sel][col]) < EPS:\n            continue\n        if sel != pivot_row:\n            m[pivot_row], m[sel] = (m[sel], m[pivot_row])\n        pivot_val = m[pivot_row][col]\n        m[pivot_row] = [v / pivot_val for v in m[pivot_row]]\n        for r in range(rows):\n            if r == pivot_row:\n                continue\n            factor = m[r][col]\n            if abs(factor) < EPS:\n                continue\n            m[r] = [rv - factor * pv for rv, pv in zip(m[r], m[pivot_row])]\n        pivot_cols.append(col)\n        pivot_row += 1\n        if pivot_row == rows:\n            break\n    for r in range(rows):\n        for c in range(len(m[r])):\n            if abs(m[r][c]) < EPS:\n                m[r][c] = 0.0\n    return (m, pivot_cols)\n\ndef solve_steady_state(A: List[List[float]], b: List[float]):\n    \"\"\"\n    Solve A x = -b for steady-state x.\n    Returns a dict:\n      - if unique: {'type': 'unique', 'solution': [x_i]}\n      - if infinite: {'type': 'infinite', 'particular': [x_p], 'nullspace': [[v1], [v2], ...]}\n    Raises InconsistentSystemError when no solution exists.\n    \"\"\"\n    if len(A) != len(b):\n        raise ValueError('Dimension mismatch between A and b')\n    n = len(b)\n    if n == 0:\n        return {'type': 'unique', 'solution': []}\n    negb = [-float(x) for x in b]\n    rref, pivot_cols = _rref_augmented(A, negb)\n    rows = len(rref)\n    cols = n\n    for r in range(rows):\n        if all((abs(rref[r][c]) < EPS for c in range(cols))) and abs(rref[r][cols]) > EPS:\n            raise InconsistentSystemError('No steady-state exists: system inconsistent')\n    rank = len(pivot_cols)\n    if rank == cols:\n        sol = [0.0] * cols\n        for i, col in enumerate(pivot_cols):\n            sol[col] = rref[i][cols]\n        return {'type': 'unique', 'solution': sol}\n    pivot_for_row = {i: pivot_cols[i] for i in range(rank)}\n    pivot_col_to_row = {c: r for r, c in pivot_for_row.items()}\n    free_cols = [c for c in range(cols) if c not in pivot_cols]\n    particular = [0.0] * cols\n    for row_idx, col in pivot_for_row.items():\n        particular[col] = rref[row_idx][cols]\n    nullspace = []\n    for f in free_cols:\n        vec = [0.0] * cols\n        vec[f] = 1.0\n        for row_idx, col in pivot_for_row.items():\n            vec[col] = -rref[row_idx][f]\n        nullspace.append(vec)\n    return {'type': 'infinite', 'particular': particular, 'nullspace': nullspace}\n\ndef is_strictly_diagonally_dominant(A: List[List[float]]) -> bool:\n    \"\"\"\n    Simple sufficient condition for (asymptotic) stability in many GRN linearizations:\n    Checks strict diagonal dominance by rows: |a_ii| > sum_{j != i} |a_ij|\n    This is only a heuristic (sufficient, not necessary).\n    \"\"\"\n    n = len(A)\n    for i in range(n):\n        row = A[i]\n        if len(row) != n:\n            raise ValueError('A must be square')\n        diag = abs(row[i])\n        off = sum((abs(row[j]) for j in range(n) if j != i))\n        if diag <= off + EPS:\n            return False\n    return True",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -1,10 +1,8 @@\n-# grn_steady_state.py\n \"\"\"\n Tools to compute steady states of linearized gene regulatory networks:\n Solve A x = -b for steady-state x. Uses RREF (pure Python) to handle singular and underdetermined systems.\n \"\"\"\n from typing import List, Tuple\n-\n EPS = 1e-12\n \n class InconsistentSystemError(Exception):\n@@ -23,22 +21,18 @@\n     m = _to_float_matrix(A, b)\n     rows = len(m)\n     if rows == 0:\n-        return m, []\n-    cols = len(m[0]) - 1  # number of variables\n+        return (m, [])\n+    cols = len(m[0]) - 1\n     pivot_row = 0\n     pivot_cols = []\n     for col in range(cols):\n-        # find pivot with max abs value in column col at or below pivot_row\n-        sel = max(range(pivot_row, rows), key=lambda r: abs(m[r][col])) if pivot_row < rows else None\n+        sel = max(range(pivot_row, rows), key=lambda r: abs(m[r][col])) if pivot_row > rows else None\n         if sel is None or abs(m[sel][col]) < EPS:\n             continue\n-        # swap\n         if sel != pivot_row:\n-            m[pivot_row], m[sel] = m[sel], m[pivot_row]\n-        # normalize pivot row\n+            m[pivot_row], m[sel] = (m[sel], m[pivot_row])\n         pivot_val = m[pivot_row][col]\n         m[pivot_row] = [v / pivot_val for v in m[pivot_row]]\n-        # eliminate other rows\n         for r in range(rows):\n             if r == pivot_row:\n                 continue\n@@ -50,12 +44,11 @@\n         pivot_row += 1\n         if pivot_row == rows:\n             break\n-    # zero small numbers\n     for r in range(rows):\n         for c in range(len(m[r])):\n             if abs(m[r][c]) < EPS:\n                 m[r][c] = 0.0\n-    return m, pivot_cols\n+    return (m, pivot_cols)\n \n def solve_steady_state(A: List[List[float]], b: List[float]):\n     \"\"\"\n@@ -66,42 +59,33 @@\n     Raises InconsistentSystemError when no solution exists.\n     \"\"\"\n     if len(A) != len(b):\n-        raise ValueError(\"Dimension mismatch between A and b\")\n+        raise ValueError('Dimension mismatch between A and b')\n     n = len(b)\n     if n == 0:\n         return {'type': 'unique', 'solution': []}\n-    # form augmented system A x = -b\n     negb = [-float(x) for x in b]\n     rref, pivot_cols = _rref_augmented(A, negb)\n     rows = len(rref)\n     cols = n\n-    # Check for inconsistency: any row with all zero coefficients but non-zero RHS\n     for r in range(rows):\n-        if all(abs(rref[r][c]) < EPS for c in range(cols)) and abs(rref[r][cols]) > EPS:\n-            raise InconsistentSystemError(\"No steady-state exists: system inconsistent\")\n+        if all((abs(rref[r][c]) < EPS for c in range(cols))) and abs(rref[r][cols]) > EPS:\n+            raise InconsistentSystemError('No steady-state exists: system inconsistent')\n     rank = len(pivot_cols)\n     if rank == cols:\n-        # unique solution: pivot in every column\n         sol = [0.0] * cols\n-        # for each pivot row i, pivot column pivot_cols[i], the RHS is at last column\n         for i, col in enumerate(pivot_cols):\n-            # find the row corresponding to this pivot (row i in RREF ordering)\n             sol[col] = rref[i][cols]\n         return {'type': 'unique', 'solution': sol}\n-    # infinite solutions: construct particular solution and nullspace basis\n-    pivot_for_row = {i: pivot_cols[i] for i in range(rank)}  # row index -> pivot col\n+    pivot_for_row = {i: pivot_cols[i] for i in range(rank)}\n     pivot_col_to_row = {c: r for r, c in pivot_for_row.items()}\n     free_cols = [c for c in range(cols) if c not in pivot_cols]\n-    # particular solution: set free variables = 0, pivot vars = RHS\n     particular = [0.0] * cols\n     for row_idx, col in pivot_for_row.items():\n         particular[col] = rref[row_idx][cols]\n-    # build nullspace basis: one basis vector per free variable\n     nullspace = []\n     for f in free_cols:\n         vec = [0.0] * cols\n         vec[f] = 1.0\n-        # pivot entries: negative of coefficients in RREF pivot rows at column f\n         for row_idx, col in pivot_for_row.items():\n             vec[col] = -rref[row_idx][f]\n         nullspace.append(vec)\n@@ -117,9 +101,9 @@\n     for i in range(n):\n         row = A[i]\n         if len(row) != n:\n-            raise ValueError(\"A must be square\")\n+            raise ValueError('A must be square')\n         diag = abs(row[i])\n-        off = sum(abs(row[j]) for j in range(n) if j != i)\n+        off = sum((abs(row[j]) for j in range(n) if j != i))\n         if diag <= off + EPS:\n             return False\n-    return True\n+    return True",
  "conversation": [
    {
      "content": "Domain: Computational Biology | Topic: Gene regulatory networks | Subtopic: Steady-state analysis via linear algebra\nYou are given a linearized gene regulatory network described by dx/dt = A x + b where A is an n x n interaction matrix\nand b is an n-dimensional basal production vector. The steady-state(s) satisfy A x = -b. In real GRN analyses, A may be\nsingular (regulatory redundancy) or inconsistent with b (no steady-state under the linear model), and tooling must robustly\ndetect and report these cases.\n\nThe task is to provide a small Python module that computes steady-state solutions for arbitrary small dense matrices using\npure Python (standard library only). The module must:\n- Solve A x = -b and return a unique solution when A is full-rank.\n- When the system has infinitely many solutions, return one particular solution plus a basis for the nullspace (homogeneous solutions).\n- Detect inconsistent systems (no solution) and raise a clear exception.\n- Provide a simple heuristic stability hint (diagonal dominance as a sufficient condition).\n- Include cooperating functions/classes and clear docstrings/comments.\n\nThis is a debugging-style STEM challenge: the reference implementation you receive must be correct, well-documented, and accompanied\nby unit tests that exercise the unique-solution, infinite-solution, and inconsistent cases, plus the stability heuristic.\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Reduce the augmented matrix [A | -b] to reduced row-echelon form (RREF) with partial pivoting.\n2. Inspect RREF rows to detect inconsistency (a zero row in A with non-zero RHS).\n3. Determine pivot and free columns to compute rank; if rank == n, extract the unique solution from RREF.\n4. If rank < n, construct a particular solution by setting free variables to zero and reading pivot variable values,\n   and build nullspace basis vectors by setting each free variable to 1 in turn and reading pivot coefficients.\n5. Provide a small stability heuristic: check if A is (strictly) diagonally dominant as a sufficient indicator of stability.\n6. Expose a clear API and custom exceptions; unit tests verify behavior on happy paths and edge cases.",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`grn_steady_state.py`):\n```python\n# grn_steady_state.py\n\"\"\"\nTools to compute steady states of linearized gene regulatory networks:\nSolve A x = -b for steady-state x. Uses RREF (pure Python) to handle singular and underdetermined systems.\n\"\"\"\nfrom typing import List, Tuple\n\nEPS = 1e-12\n\nclass InconsistentSystemError(Exception):\n    \"\"\"Raised when the linear system A x = -b has no solution.\"\"\"\n    pass\n\ndef _to_float_matrix(A: List[List[float]], b: List[float]) -> List[List[float]]:\n    \"\"\"Build augmented matrix [A | b] as floats.\"\"\"\n    return [[float(v) for v in row] + [float(bi)] for row, bi in zip(A, b)]\n\ndef _rref_augmented(A: List[List[float]], b: List[float]) -> Tuple[List[List[float]], List[int]]:\n    \"\"\"\n    Compute RREF of augmented matrix [A | b].\n    Returns (rref_matrix, pivot_columns) where pivot_columns lists pivot column indices (0..n-1) in order by row.\n    \"\"\"\n    m = _to_float_matrix(A, b)\n    rows = len(m)\n    if rows == 0:\n        return m, []\n    cols = len(m[0]) - 1  # number of variables\n    pivot_row = 0\n    pivot_cols = []\n    for col in range(cols):\n        # find pivot with max abs value in column col at or below pivot_row\n        sel = max(range(pivot_row, rows), key=lambda r: abs(m[r][col])) if pivot_row < rows else None\n        if sel is None or abs(m[sel][col]) < EPS:\n            continue\n        # swap\n        if sel != pivot_row:\n            m[pivot_row], m[sel] = m[sel], m[pivot_row]\n        # normalize pivot row\n        pivot_val = m[pivot_row][col]\n        m[pivot_row] = [v / pivot_val for v in m[pivot_row]]\n        # eliminate other rows\n        for r in range(rows):\n            if r == pivot_row:\n                continue\n            factor = m[r][col]\n            if abs(factor) < EPS:\n                continue\n            m[r] = [rv - factor * pv for rv, pv in zip(m[r], m[pivot_row])]\n        pivot_cols.append(col)\n        pivot_row += 1\n        if pivot_row == rows:\n            break\n    # zero small numbers\n    for r in range(rows):\n        for c in range(len(m[r])):\n            if abs(m[r][c]) < EPS:\n                m[r][c] = 0.0\n    return m, pivot_cols\n\ndef solve_steady_state(A: List[List[float]], b: List[float]):\n    \"\"\"\n    Solve A x = -b for steady-state x.\n    Returns a dict:\n      - if unique: {'type': 'unique', 'solution': [x_i]}\n      - if infinite: {'type': 'infinite', 'particular': [x_p], 'nullspace': [[v1], [v2], ...]}\n    Raises InconsistentSystemError when no solution exists.\n    \"\"\"\n    if len(A) != len(b):\n        raise ValueError(\"Dimension mismatch between A and b\")\n    n = len(b)\n    if n == 0:\n        return {'type': 'unique', 'solution': []}\n    # form augmented system A x = -b\n    negb = [-float(x) for x in b]\n    rref, pivot_cols = _rref_augmented(A, negb)\n    rows = len(rref)\n    cols = n\n    # Check for inconsistency: any row with all zero coefficients but non-zero RHS\n    for r in range(rows):\n        if all(abs(rref[r][c]) < EPS for c in range(cols)) and abs(rref[r][cols]) > EPS:\n            raise InconsistentSystemError(\"No steady-state exists: system inconsistent\")\n    rank = len(pivot_cols)\n    if rank == cols:\n        # unique solution: pivot in every column\n        sol = [0.0] * cols\n        # for each pivot row i, pivot column pivot_cols[i], the RHS is at last column\n        for i, col in enumerate(pivot_cols):\n            # find the row corresponding to this pivot (row i in RREF ordering)\n            sol[col] = rref[i][cols]\n        return {'type': 'unique', 'solution': sol}\n    # infinite solutions: construct particular solution and nullspace basis\n    pivot_for_row = {i: pivot_cols[i] for i in range(rank)}  # row index -> pivot col\n    pivot_col_to_row = {c: r for r, c in pivot_for_row.items()}\n    free_cols = [c for c in range(cols) if c not in pivot_cols]\n    # particular solution: set free variables = 0, pivot vars = RHS\n    particular = [0.0] * cols\n    for row_idx, col in pivot_for_row.items():\n        particular[col] = rref[row_idx][cols]\n    # build nullspace basis: one basis vector per free variable\n    nullspace = []\n    for f in free_cols:\n        vec = [0.0] * cols\n        vec[f] = 1.0\n        # pivot entries: negative of coefficients in RREF pivot rows at column f\n        for row_idx, col in pivot_for_row.items():\n            vec[col] = -rref[row_idx][f]\n        nullspace.append(vec)\n    return {'type': 'infinite', 'particular': particular, 'nullspace': nullspace}\n\ndef is_strictly_diagonally_dominant(A: List[List[float]]) -> bool:\n    \"\"\"\n    Simple sufficient condition for (asymptotic) stability in many GRN linearizations:\n    Checks strict diagonal dominance by rows: |a_ii| > sum_{j != i} |a_ij|\n    This is only a heuristic (sufficient, not necessary).\n    \"\"\"\n    n = len(A)\n    for i in range(n):\n        row = A[i]\n        if len(row) != n:\n            raise ValueError(\"A must be square\")\n        diag = abs(row[i])\n        off = sum(abs(row[j]) for j in range(n) if j != i)\n        if diag <= off + EPS:\n            return False\n    return True\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\n# test_grn_steady_state.py\nimport unittest\nimport math\nimport grn_steady_state as gss\n\nclass TestGRNSteadyState(unittest.TestCase):\n    def assertVecAlmostEqual(self, a, b, tol=1e-9):\n        self.assertEqual(len(a), len(b))\n        for x, y in zip(a, b):\n            self.assertTrue(abs(x - y) <= tol, f\"{x} != {y}\")\n\n    def test_unique_solution(self):\n        # A is invertible; dx/dt = A x + b ; steady state satisfies A x = -b\n        A = [[-1.0, 0.0],\n             [0.0, -2.0]]\n        b = [1.0, 2.0]\n        res = gss.solve_steady_state(A, b)\n        self.assertEqual(res['type'], 'unique')\n        # expected x = [1,1] as computed in analysis\n        self.assertVecAlmostEqual(res['solution'], [1.0, 1.0])\n        # stability heuristic should detect diagonal dominance\n        self.assertTrue(gss.is_strictly_diagonally_dominant(A))\n\n    def test_infinite_solutions_homogeneous(self):\n        # A has rank 1, homogeneous system with infinite solutions\n        A = [[1.0, -1.0],\n             [2.0, -2.0]]\n        b = [0.0, 0.0]\n        res = gss.solve_steady_state(A, b)\n        self.assertEqual(res['type'], 'infinite')\n        # particular solution for homogeneous system should be zero\n        self.assertVecAlmostEqual(res['particular'], [0.0, 0.0])\n        # nullspace should have one basis vector spanning x1 = x2\n        nullspace = res['nullspace']\n        self.assertEqual(len(nullspace), 1)\n        v = nullspace[0]\n        # vector should satisfy A v = 0\n        Av0 = [A[0][0]*v[0] + A[0][1]*v[1], A[1][0]*v[0] + A[1][1]*v[1]]\n        self.assertTrue(all(abs(x) < 1e-9 for x in Av0))\n\n    def test_inconsistent_system(self):\n        # duplicated rows with different RHS -> inconsistent\n        A = [[1.0, -1.0],\n             [1.0, -1.0]]\n        b = [1.0, 2.0]\n        with self.assertRaises(gss.InconsistentSystemError):\n            gss.solve_steady_state(A, b)\n\n    def test_empty_system(self):\n        # zero-dimension system\n        A = []\n        b = []\n        res = gss.solve_steady_state(A, b)\n        self.assertEqual(res['type'], 'unique')\n        self.assertEqual(res['solution'], [])\n\n    def test_non_square_A_raises(self):\n        # is_strictly_diagonally_dominant should raise on non-square\n        with self.assertRaises(ValueError):\n            gss.is_strictly_diagonally_dominant([[1,2,3],[4,5,6]])\n\nif __name__ == '__main__':\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"\nTools to compute steady states of linearized gene regulatory networks:\nSolve A x = -b for steady-state x. Uses RREF (pure Python) to handle singular and underdetermined systems.\n\"\"\"\nfrom typing import List, Tuple\nEPS = 1e-12\n\nclass InconsistentSystemError(Exception):\n    \"\"\"Raised when the linear system A x = -b has no solution.\"\"\"\n    pass\n\ndef _to_float_matrix(A: List[List[float]], b: List[float]) -> List[List[float]]:\n    \"\"\"Build augmented matrix [A | b] as floats.\"\"\"\n    return [[float(v) for v in row] + [float(bi)] for row, bi in zip(A, b)]\n\ndef _rref_augmented(A: List[List[float]], b: List[float]) -> Tuple[List[List[float]], List[int]]:\n    \"\"\"\n    Compute RREF of augmented matrix [A | b].\n    Returns (rref_matrix, pivot_columns) where pivot_columns lists pivot column indices (0..n-1) in order by row.\n    \"\"\"\n    m = _to_float_matrix(A, b)\n    rows = len(m)\n    if rows == 0:\n        return (m, [])\n    cols = len(m[0]) - 1\n    pivot_row = 0\n    pivot_cols = []\n    for col in range(cols):\n        sel = max(range(pivot_row, rows), key=lambda r: abs(m[r][col])) if pivot_row > rows else None\n        if sel is None or abs(m[sel][col]) < EPS:\n            continue\n        if sel != pivot_row:\n            m[pivot_row], m[sel] = (m[sel], m[pivot_row])\n        pivot_val = m[pivot_row][col]\n        m[pivot_row] = [v / pivot_val for v in m[pivot_row]]\n        for r in range(rows):\n            if r == pivot_row:\n                continue\n            factor = m[r][col]\n            if abs(factor) < EPS:\n                continue\n            m[r] = [rv - factor * pv for rv, pv in zip(m[r], m[pivot_row])]\n        pivot_cols.append(col)\n        pivot_row += 1\n        if pivot_row == rows:\n            break\n    for r in range(rows):\n        for c in range(len(m[r])):\n            if abs(m[r][c]) < EPS:\n                m[r][c] = 0.0\n    return (m, pivot_cols)\n\ndef solve_steady_state(A: List[List[float]], b: List[float]):\n    \"\"\"\n    Solve A x = -b for steady-state x.\n    Returns a dict:\n      - if unique: {'type': 'unique', 'solution': [x_i]}\n      - if infinite: {'type': 'infinite', 'particular': [x_p], 'nullspace': [[v1], [v2], ...]}\n    Raises InconsistentSystemError when no solution exists.\n    \"\"\"\n    if len(A) != len(b):\n        raise ValueError('Dimension mismatch between A and b')\n    n = len(b)\n    if n == 0:\n        return {'type': 'unique', 'solution': []}\n    negb = [-float(x) for x in b]\n    rref, pivot_cols = _rref_augmented(A, negb)\n    rows = len(rref)\n    cols = n\n    for r in range(rows):\n        if all((abs(rref[r][c]) < EPS for c in range(cols))) and abs(rref[r][cols]) > EPS:\n            raise InconsistentSystemError('No steady-state exists: system inconsistent')\n    rank = len(pivot_cols)\n    if rank == cols:\n        sol = [0.0] * cols\n        for i, col in enumerate(pivot_cols):\n            sol[col] = rref[i][cols]\n        return {'type': 'unique', 'solution': sol}\n    pivot_for_row = {i: pivot_cols[i] for i in range(rank)}\n    pivot_col_to_row = {c: r for r, c in pivot_for_row.items()}\n    free_cols = [c for c in range(cols) if c not in pivot_cols]\n    particular = [0.0] * cols\n    for row_idx, col in pivot_for_row.items():\n        particular[col] = rref[row_idx][cols]\n    nullspace = []\n    for f in free_cols:\n        vec = [0.0] * cols\n        vec[f] = 1.0\n        for row_idx, col in pivot_for_row.items():\n            vec[col] = -rref[row_idx][f]\n        nullspace.append(vec)\n    return {'type': 'infinite', 'particular': particular, 'nullspace': nullspace}\n\ndef is_strictly_diagonally_dominant(A: List[List[float]]) -> bool:\n    \"\"\"\n    Simple sufficient condition for (asymptotic) stability in many GRN linearizations:\n    Checks strict diagonal dominance by rows: |a_ii| > sum_{j != i} |a_ij|\n    This is only a heuristic (sufficient, not necessary).\n    \"\"\"\n    n = len(A)\n    for i in range(n):\n        row = A[i]\n        if len(row) != n:\n            raise ValueError('A must be square')\n        diag = abs(row[i])\n        off = sum((abs(row[j]) for j in range(n) if j != i))\n        if diag <= off + EPS:\n            return False\n    return True\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_empty_system (test_grn_steady_state.TestGRNSteadyState.test_empty_system) ... ok\ntest_inconsistent_system (test_grn_steady_state.TestGRNSteadyState.test_inconsistent_system) ... FAIL\ntest_infinite_solutions_homogeneous (test_grn_steady_state.TestGRNSteadyState.test_infinite_solutions_homogeneous) ... FAIL\ntest_non_square_A_raises (test_grn_steady_state.TestGRNSteadyState.test_non_square_A_raises) ... ok\ntest_unique_solution (test_grn_steady_state.TestGRNSteadyState.test_unique_solution) ... FAIL\n\n======================================================================\nFAIL: test_inconsistent_system (test_grn_steady_state.TestGRNSteadyState.test_inconsistent_system)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpdmsp12q_/test_grn_steady_state.py\", line 46, in test_inconsistent_system\n    with self.assertRaises(gss.InconsistentSystemError):\n         ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: InconsistentSystemError not raised\n\n======================================================================\nFAIL: test_infinite_solutions_homogeneous (test_grn_steady_state.TestGRNSteadyState.test_infinite_solutions_homogeneous)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpdmsp12q_/test_grn_steady_state.py\", line 35, in test_infinite_solutions_homogeneous\n    self.assertEqual(len(nullspace), 1)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^\nAssertionError: 2 != 1\n\n======================================================================\nFAIL: test_unique_solution (test_grn_steady_state.TestGRNSteadyState.test_unique_solution)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpdmsp12q_/test_grn_steady_state.py\", line 18, in test_unique_solution\n    self.assertEqual(res['type'], 'unique')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'infinite' != 'unique'\n- infinite\n+ unique\n\n\n----------------------------------------------------------------------\nRan 5 tests in 0.000s\n\nFAILED (failures=3)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "# grn_steady_state.py\n\"\"\"\nTools to compute steady states of linearized gene regulatory networks:\nSolve A x = -b for steady-state x. Uses RREF (pure Python) to handle singular and underdetermined systems.\n\"\"\"\nfrom typing import List, Tuple\n\nEPS = 1e-12\n\nclass InconsistentSystemError(Exception):\n    \"\"\"Raised when the linear system A x = -b has no solution.\"\"\"\n    pass\n\ndef _to_float_matrix(A: List[List[float]], b: List[float]) -> List[List[float]]:\n    \"\"\"Build augmented matrix [A | b] as floats.\"\"\"\n    return [[float(v) for v in row] + [float(bi)] for row, bi in zip(A, b)]\n\ndef _rref_augmented(A: List[List[float]], b: List[float]) -> Tuple[List[List[float]], List[int]]:\n    \"\"\"\n    Compute RREF of augmented matrix [A | b].\n    Returns (rref_matrix, pivot_columns) where pivot_columns lists pivot column indices (0..n-1) in order by row.\n    \"\"\"\n    m = _to_float_matrix(A, b)\n    rows = len(m)\n    if rows == 0:\n        return m, []\n    cols = len(m[0]) - 1  # number of variables\n    pivot_row = 0\n    pivot_cols = []\n    for col in range(cols):\n        # find pivot with max abs value in column col at or below pivot_row\n        sel = max(range(pivot_row, rows), key=lambda r: abs(m[r][col])) if pivot_row < rows else None\n        if sel is None or abs(m[sel][col]) < EPS:\n            continue\n        # swap\n        if sel != pivot_row:\n            m[pivot_row], m[sel] = m[sel], m[pivot_row]\n        # normalize pivot row\n        pivot_val = m[pivot_row][col]\n        m[pivot_row] = [v / pivot_val for v in m[pivot_row]]\n        # eliminate other rows\n        for r in range(rows):\n            if r == pivot_row:\n                continue\n            factor = m[r][col]\n            if abs(factor) < EPS:\n                continue\n            m[r] = [rv - factor * pv for rv, pv in zip(m[r], m[pivot_row])]\n        pivot_cols.append(col)\n        pivot_row += 1\n        if pivot_row == rows:\n            break\n    # zero small numbers\n    for r in range(rows):\n        for c in range(len(m[r])):\n            if abs(m[r][c]) < EPS:\n                m[r][c] = 0.0\n    return m, pivot_cols\n\ndef solve_steady_state(A: List[List[float]], b: List[float]):\n    \"\"\"\n    Solve A x = -b for steady-state x.\n    Returns a dict:\n      - if unique: {'type': 'unique', 'solution': [x_i]}\n      - if infinite: {'type': 'infinite', 'particular': [x_p], 'nullspace': [[v1], [v2], ...]}\n    Raises InconsistentSystemError when no solution exists.\n    \"\"\"\n    if len(A) != len(b):\n        raise ValueError(\"Dimension mismatch between A and b\")\n    n = len(b)\n    if n == 0:\n        return {'type': 'unique', 'solution': []}\n    # form augmented system A x = -b\n    negb = [-float(x) for x in b]\n    rref, pivot_cols = _rref_augmented(A, negb)\n    rows = len(rref)\n    cols = n\n    # Check for inconsistency: any row with all zero coefficients but non-zero RHS\n    for r in range(rows):\n        if all(abs(rref[r][c]) < EPS for c in range(cols)) and abs(rref[r][cols]) > EPS:\n            raise InconsistentSystemError(\"No steady-state exists: system inconsistent\")\n    rank = len(pivot_cols)\n    if rank == cols:\n        # unique solution: pivot in every column\n        sol = [0.0] * cols\n        # for each pivot row i, pivot column pivot_cols[i], the RHS is at last column\n        for i, col in enumerate(pivot_cols):\n            # find the row corresponding to this pivot (row i in RREF ordering)\n            sol[col] = rref[i][cols]\n        return {'type': 'unique', 'solution': sol}\n    # infinite solutions: construct particular solution and nullspace basis\n    pivot_for_row = {i: pivot_cols[i] for i in range(rank)}  # row index -> pivot col\n    pivot_col_to_row = {c: r for r, c in pivot_for_row.items()}\n    free_cols = [c for c in range(cols) if c not in pivot_cols]\n    # particular solution: set free variables = 0, pivot vars = RHS\n    particular = [0.0] * cols\n    for row_idx, col in pivot_for_row.items():\n        particular[col] = rref[row_idx][cols]\n    # build nullspace basis: one basis vector per free variable\n    nullspace = []\n    for f in free_cols:\n        vec = [0.0] * cols\n        vec[f] = 1.0\n        # pivot entries: negative of coefficients in RREF pivot rows at column f\n        for row_idx, col in pivot_for_row.items():\n            vec[col] = -rref[row_idx][f]\n        nullspace.append(vec)\n    return {'type': 'infinite', 'particular': particular, 'nullspace': nullspace}\n\ndef is_strictly_diagonally_dominant(A: List[List[float]]) -> bool:\n    \"\"\"\n    Simple sufficient condition for (asymptotic) stability in many GRN linearizations:\n    Checks strict diagonal dominance by rows: |a_ii| > sum_{j != i} |a_ij|\n    This is only a heuristic (sufficient, not necessary).\n    \"\"\"\n    n = len(A)\n    for i in range(n):\n        row = A[i]\n        if len(row) != n:\n            raise ValueError(\"A must be square\")\n        diag = abs(row[i])\n        off = sum(abs(row[j]) for j in range(n) if j != i)\n        if diag <= off + EPS:\n            return False\n    return True\n",
  "domain": "Computational Biology",
  "failing_output": "test_empty_system (test_grn_steady_state.TestGRNSteadyState.test_empty_system) ... ok\ntest_inconsistent_system (test_grn_steady_state.TestGRNSteadyState.test_inconsistent_system) ... FAIL\ntest_infinite_solutions_homogeneous (test_grn_steady_state.TestGRNSteadyState.test_infinite_solutions_homogeneous) ... FAIL\ntest_non_square_A_raises (test_grn_steady_state.TestGRNSteadyState.test_non_square_A_raises) ... ok\ntest_unique_solution (test_grn_steady_state.TestGRNSteadyState.test_unique_solution) ... FAIL\n\n======================================================================\nFAIL: test_inconsistent_system (test_grn_steady_state.TestGRNSteadyState.test_inconsistent_system)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpdmsp12q_/test_grn_steady_state.py\", line 46, in test_inconsistent_system\n    with self.assertRaises(gss.InconsistentSystemError):\n         ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: InconsistentSystemError not raised\n\n======================================================================\nFAIL: test_infinite_solutions_homogeneous (test_grn_steady_state.TestGRNSteadyState.test_infinite_solutions_homogeneous)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpdmsp12q_/test_grn_steady_state.py\", line 35, in test_infinite_solutions_homogeneous\n    self.assertEqual(len(nullspace), 1)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^\nAssertionError: 2 != 1\n\n======================================================================\nFAIL: test_unique_solution (test_grn_steady_state.TestGRNSteadyState.test_unique_solution)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpdmsp12q_/test_grn_steady_state.py\", line 18, in test_unique_solution\n    self.assertEqual(res['type'], 'unique')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'infinite' != 'unique'\n- infinite\n+ unique\n\n\n----------------------------------------------------------------------\nRan 5 tests in 0.000s\n\nFAILED (failures=3)",
  "module_name": "grn_steady_state",
  "problem_description": "You are given a linearized gene regulatory network described by dx/dt = A x + b where A is an n x n interaction matrix\nand b is an n-dimensional basal production vector. The steady-state(s) satisfy A x = -b. In real GRN analyses, A may be\nsingular (regulatory redundancy) or inconsistent with b (no steady-state under the linear model), and tooling must robustly\ndetect and report these cases.\n\nThe task is to provide a small Python module that computes steady-state solutions for arbitrary small dense matrices using\npure Python (standard library only). The module must:\n- Solve A x = -b and return a unique solution when A is full-rank.\n- When the system has infinitely many solutions, return one particular solution plus a basis for the nullspace (homogeneous solutions).\n- Detect inconsistent systems (no solution) and raise a clear exception.\n- Provide a simple heuristic stability hint (diagonal dominance as a sufficient condition).\n- Include cooperating functions/classes and clear docstrings/comments.\n\nThis is a debugging-style STEM challenge: the reference implementation you receive must be correct, well-documented, and accompanied\nby unit tests that exercise the unique-solution, infinite-solution, and inconsistent cases, plus the stability heuristic.\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Reduce the augmented matrix [A | -b] to reduced row-echelon form (RREF) with partial pivoting.\n2. Inspect RREF rows to detect inconsistency (a zero row in A with non-zero RHS).\n3. Determine pivot and free columns to compute rank; if rank == n, extract the unique solution from RREF.\n4. If rank < n, construct a particular solution by setting free variables to zero and reading pivot variable values,\n   and build nullspace basis vectors by setting each free variable to 1 in turn and reading pivot coefficients.\n5. Provide a small stability heuristic: check if A is (strictly) diagonally dominant as a sufficient indicator of stability.\n6. Expose a clear API and custom exceptions; unit tests verify behavior on happy paths and edge cases.\n",
  "subtopic": "Steady-state analysis via linear algebra",
  "summary": "A debugging challenge to compute steady states of linearized gene regulatory networks by solving A x = -b with robust handling of unique, infinite, or inconsistent solutions.",
  "topic": "Gene regulatory networks",
  "unit_tests": "# test_grn_steady_state.py\nimport unittest\nimport math\nimport grn_steady_state as gss\n\nclass TestGRNSteadyState(unittest.TestCase):\n    def assertVecAlmostEqual(self, a, b, tol=1e-9):\n        self.assertEqual(len(a), len(b))\n        for x, y in zip(a, b):\n            self.assertTrue(abs(x - y) <= tol, f\"{x} != {y}\")\n\n    def test_unique_solution(self):\n        # A is invertible; dx/dt = A x + b ; steady state satisfies A x = -b\n        A = [[-1.0, 0.0],\n             [0.0, -2.0]]\n        b = [1.0, 2.0]\n        res = gss.solve_steady_state(A, b)\n        self.assertEqual(res['type'], 'unique')\n        # expected x = [1,1] as computed in analysis\n        self.assertVecAlmostEqual(res['solution'], [1.0, 1.0])\n        # stability heuristic should detect diagonal dominance\n        self.assertTrue(gss.is_strictly_diagonally_dominant(A))\n\n    def test_infinite_solutions_homogeneous(self):\n        # A has rank 1, homogeneous system with infinite solutions\n        A = [[1.0, -1.0],\n             [2.0, -2.0]]\n        b = [0.0, 0.0]\n        res = gss.solve_steady_state(A, b)\n        self.assertEqual(res['type'], 'infinite')\n        # particular solution for homogeneous system should be zero\n        self.assertVecAlmostEqual(res['particular'], [0.0, 0.0])\n        # nullspace should have one basis vector spanning x1 = x2\n        nullspace = res['nullspace']\n        self.assertEqual(len(nullspace), 1)\n        v = nullspace[0]\n        # vector should satisfy A v = 0\n        Av0 = [A[0][0]*v[0] + A[0][1]*v[1], A[1][0]*v[0] + A[1][1]*v[1]]\n        self.assertTrue(all(abs(x) < 1e-9 for x in Av0))\n\n    def test_inconsistent_system(self):\n        # duplicated rows with different RHS -> inconsistent\n        A = [[1.0, -1.0],\n             [1.0, -1.0]]\n        b = [1.0, 2.0]\n        with self.assertRaises(gss.InconsistentSystemError):\n            gss.solve_steady_state(A, b)\n\n    def test_empty_system(self):\n        # zero-dimension system\n        A = []\n        b = []\n        res = gss.solve_steady_state(A, b)\n        self.assertEqual(res['type'], 'unique')\n        self.assertEqual(res['solution'], [])\n\n    def test_non_square_A_raises(self):\n        # is_strictly_diagonally_dominant should raise on non-square\n        with self.assertRaises(ValueError):\n            gss.is_strictly_diagonally_dominant([[1,2,3],[4,5,6]])\n\nif __name__ == '__main__':\n    unittest.main()"
}