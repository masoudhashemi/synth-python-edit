{
  "buggy_code": "\"\"\"\n1D constant-velocity Kalman fusion module.\nState: [position, velocity]\nProvides: predict(dt), update(measurement), aggregate_and_update(measurements), run_sequence.\n\"\"\"\nfrom typing import List, Dict, Sequence\n\ndef _dot(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef _outer(a, b):\n    return [[a[0] * b[0], a[0] * b[1]], [a[1] * b[0], a[1] * b[1]]]\n\ndef _mat_sub(A, B):\n    return [[A[0][0] - B[0][0], A[0][1] - B[0][1]], [A[1][0] - B[1][0], A[1][1] - B[1][1]]]\n\nclass KalmanFilter1D:\n\n    def __init__(self, x0=None, P0=None, accel_variance=1.0, gating_threshold=9.0, min_R=0.0001, max_R=1000000.0):\n        self.x = x0[:] if x0 is not None else [0.0, 0.0]\n        self.P = [row[:] for row in (P0 if P0 is not None else [[1.0, 0.0], [0.0, 1.0]])]\n        self.accel_variance = float(accel_variance)\n        self.gating_threshold = float(gating_threshold)\n        self.min_R = float(min_R)\n        self.max_R = float(max_R)\n\n    def predict(self, dt):\n        F = [[1.0, dt], [0.0, 1.0]]\n        x0 = self.x[:]\n        self.x[0] = F[0][0] * x0[0] + F[0][1] * x0[1]\n        self.x[1] = F[1][0] * x0[0] + F[1][1] * x0[1]\n        q11 = dt ** 4 / 4.0 * self.accel_variance\n        q12 = dt ** 3 / 2.0 * self.accel_variance\n        q22 = dt ** 2 * self.accel_variance\n        Q = [[q11, q12], [q12, q22]]\n        P = self.P\n        FP = [[F[0][0] * P[0][0] + F[0][1] * P[1][0], F[0][0] * P[0][1] + F[0][1] * P[1][1]], [F[1][0] * P[0][0] + F[1][1] * P[1][0], F[1][0] * P[0][1] + F[1][1] * P[1][1]]]\n        FPFt = [[FP[0][0] * F[0][0] + FP[0][1] * F[0][1], FP[0][0] * F[1][0] + FP[0][1] * F[1][1]], [FP[1][0] * F[0][0] + FP[1][1] * F[0][1], FP[1][0] * F[1][0] + FP[1][1] * F[1][1]]]\n        self.P = [[FPFt[0][0] + Q[0][0], FPFt[0][1] + Q[0][1]], [FPFt[1][0] + Q[1][0], FPFt[1][1] + Q[1][1]]]\n\n    def _clamp_R(self, R):\n        Rclamped = max(self.min_R, float(R))\n        return Rclamped\n\n    def update(self, measurement: Dict):\n        \"\"\"\n        measurement: dict with keys:\n          - 'type': 'position' or 'velocity'\n          - 'z': measurement value (float)\n          - 'R': measurement variance (float)\n        Returns True if the measurement was applied, False if skipped.\n        \"\"\"\n        mtype = measurement.get('type')\n        z = float(measurement.get('z'))\n        R = float(measurement.get('R'))\n        R = self._clamp_R(R)\n        if R < self.max_R:\n            return False\n        if mtype == 'position':\n            H = [1.0, 0.0]\n        elif mtype == 'velocity':\n            H = [0.0, 1.0]\n        else:\n            raise ValueError('unknown measurement type')\n        y_pred = _dot(H, self.x)\n        innovation = z - y_pred\n        HP = [H[0] * self.P[0][0] + H[1] * self.P[1][0], H[0] * self.P[0][1] + H[1] * self.P[1][1]]\n        S = H[0] * HP[0] + H[1] * HP[1] + R\n        if S <= 0.0:\n            S = self.min_R\n        d2 = innovation * innovation / S\n        if d2 > self.gating_threshold:\n            return False\n        K = [HP[0] / S, HP[1] / S]\n        self.x[0] += K[0] * innovation\n        self.x[1] += K[1] * innovation\n        KP = _outer(K, HP)\n        self.P = _mat_sub(self.P, KP)\n        self.P[0][1] = self.P[1][0] = 0.5 * (self.P[0][1] + self.P[1][0])\n        self.P[0][0] = max(self.P[0][0], 0.0)\n        self.P[1][1] = max(self.P[1][1], 0.0)\n        return True\n\n    def aggregate_and_update(self, measurements: Sequence[Dict]):\n        \"\"\"\n        Aggregates multiple measurements (same timestamp) by type using inverse-variance weighting,\n        then applies an update per measurement type in a deterministic order: position then velocity.\n        \"\"\"\n        if not measurements:\n            return []\n        groups = {}\n        for m in measurements:\n            mtype = m['type']\n            z = float(m['z'])\n            R = max(self.min_R, float(m['R']))\n            if R > self.max_R:\n                continue\n            w = 1.0 / R\n            if mtype not in groups:\n                groups[mtype] = {'num': 0.0, 'den': 0.0}\n            groups[mtype]['num'] += z * w\n            groups[mtype]['den'] += w\n        applied = []\n        for mtype in ('position', 'velocity'):\n            if mtype in groups and groups[mtype]['den'] > 0.0:\n                z_agg = groups[mtype]['num'] / groups[mtype]['den']\n                R_agg = 1.0 / groups[mtype]['den']\n                m = {'type': mtype, 'z': z_agg, 'R': R_agg}\n                ok = self.update(m)\n                applied.append((m, ok))\n        return applied\n\n    def run_sequence(self, steps: Sequence):\n        \"\"\"\n        steps: sequence of (dt, measurements) where measurements is a list of measurement dicts.\n        Returns final state x and P.\n        \"\"\"\n        for dt, measurements in steps:\n            if dt is not None and dt > 0.0:\n                self.predict(dt)\n            self.aggregate_and_update(measurements or [])\n        return (self.x[:], [row[:] for row in self.P])",
  "code_diff": "--- correct.py\n+++ buggy.py\n@@ -1,4 +1,3 @@\n-# kalman_fusion_1d.py\n \"\"\"\n 1D constant-velocity Kalman fusion module.\n State: [position, velocity]\n@@ -7,26 +6,18 @@\n from typing import List, Dict, Sequence\n \n def _dot(a, b):\n-    return a[0]*b[0] + a[1]*b[1]\n+    return a[0] * b[0] + a[1] * b[1]\n \n def _outer(a, b):\n-    # outer product of 2-vector a and 2-vector b -> 2x2\n-    return [[a[0]*b[0], a[0]*b[1]],\n-            [a[1]*b[0], a[1]*b[1]]]\n+    return [[a[0] * b[0], a[0] * b[1]], [a[1] * b[0], a[1] * b[1]]]\n \n def _mat_sub(A, B):\n-    return [[A[0][0]-B[0][0], A[0][1]-B[0][1]],\n-            [A[1][0]-B[1][0], A[1][1]-B[1][1]]]\n+    return [[A[0][0] - B[0][0], A[0][1] - B[0][1]], [A[1][0] - B[1][0], A[1][1] - B[1][1]]]\n \n class KalmanFilter1D:\n-    def __init__(self, x0=None, P0=None,\n-                 accel_variance=1.0,\n-                 gating_threshold=9.0,\n-                 min_R=1e-4,\n-                 max_R=1e6):\n-        # state vector [pos, vel]\n+\n+    def __init__(self, x0=None, P0=None, accel_variance=1.0, gating_threshold=9.0, min_R=0.0001, max_R=1000000.0):\n         self.x = x0[:] if x0 is not None else [0.0, 0.0]\n-        # covariance 2x2\n         self.P = [row[:] for row in (P0 if P0 is not None else [[1.0, 0.0], [0.0, 1.0]])]\n         self.accel_variance = float(accel_variance)\n         self.gating_threshold = float(gating_threshold)\n@@ -34,34 +25,20 @@\n         self.max_R = float(max_R)\n \n     def predict(self, dt):\n-        # State transition F = [[1, dt], [0,1]]\n         F = [[1.0, dt], [0.0, 1.0]]\n-        # x = F x\n         x0 = self.x[:]\n-        self.x[0] = F[0][0]*x0[0] + F[0][1]*x0[1]\n-        self.x[1] = F[1][0]*x0[0] + F[1][1]*x0[1]\n-        # Process noise Q for constant acceleration model\n-        q11 = (dt**4)/4.0 * self.accel_variance\n-        q12 = (dt**3)/2.0 * self.accel_variance\n-        q22 = (dt**2) * self.accel_variance\n+        self.x[0] = F[0][0] * x0[0] + F[0][1] * x0[1]\n+        self.x[1] = F[1][0] * x0[0] + F[1][1] * x0[1]\n+        q11 = dt ** 4 / 4.0 * self.accel_variance\n+        q12 = dt ** 3 / 2.0 * self.accel_variance\n+        q22 = dt ** 2 * self.accel_variance\n         Q = [[q11, q12], [q12, q22]]\n-        # P = F P F^T + Q (compute explicitly for 2x2)\n         P = self.P\n-        # F P\n-        FP = [[F[0][0]*P[0][0] + F[0][1]*P[1][0],\n-               F[0][0]*P[0][1] + F[0][1]*P[1][1]],\n-              [F[1][0]*P[0][0] + F[1][1]*P[1][0],\n-               F[1][0]*P[0][1] + F[1][1]*P[1][1]]]\n-        # F P F^T\n-        FPFt = [[FP[0][0]*F[0][0] + FP[0][1]*F[0][1],\n-                 FP[0][0]*F[1][0] + FP[0][1]*F[1][1]],\n-                [FP[1][0]*F[0][0] + FP[1][1]*F[0][1],\n-                 FP[1][0]*F[1][0] + FP[1][1]*F[1][1]]]\n-        self.P = [[FPFt[0][0] + Q[0][0], FPFt[0][1] + Q[0][1]],\n-                  [FPFt[1][0] + Q[1][0], FPFt[1][1] + Q[1][1]]]\n+        FP = [[F[0][0] * P[0][0] + F[0][1] * P[1][0], F[0][0] * P[0][1] + F[0][1] * P[1][1]], [F[1][0] * P[0][0] + F[1][1] * P[1][0], F[1][0] * P[0][1] + F[1][1] * P[1][1]]]\n+        FPFt = [[FP[0][0] * F[0][0] + FP[0][1] * F[0][1], FP[0][0] * F[1][0] + FP[0][1] * F[1][1]], [FP[1][0] * F[0][0] + FP[1][1] * F[0][1], FP[1][0] * F[1][0] + FP[1][1] * F[1][1]]]\n+        self.P = [[FPFt[0][0] + Q[0][0], FPFt[0][1] + Q[0][1]], [FPFt[1][0] + Q[1][0], FPFt[1][1] + Q[1][1]]]\n \n     def _clamp_R(self, R):\n-        # Prevent degenerate covariances\n         Rclamped = max(self.min_R, float(R))\n         return Rclamped\n \n@@ -77,42 +54,29 @@\n         z = float(measurement.get('z'))\n         R = float(measurement.get('R'))\n         R = self._clamp_R(R)\n-        if R > self.max_R:\n-            # Sensor reported enormous uncertainty; skip\n+        if R < self.max_R:\n             return False\n-        # Define H row vector for measurement\n         if mtype == 'position':\n             H = [1.0, 0.0]\n         elif mtype == 'velocity':\n             H = [0.0, 1.0]\n         else:\n-            raise ValueError(\"unknown measurement type\")\n-        # Predicted measurement y = H x\n+            raise ValueError('unknown measurement type')\n         y_pred = _dot(H, self.x)\n         innovation = z - y_pred\n-        # S = H P H^T + R (scalar)\n-        # H P is 1x2 row vector\n-        HP = [H[0]*self.P[0][0] + H[1]*self.P[1][0],\n-              H[0]*self.P[0][1] + H[1]*self.P[1][1]]\n-        S = H[0]*HP[0] + H[1]*HP[1] + R\n-        # Mahalanobis gating (scalar)\n-        # Protect against tiny S\n+        HP = [H[0] * self.P[0][0] + H[1] * self.P[1][0], H[0] * self.P[0][1] + H[1] * self.P[1][1]]\n+        S = H[0] * HP[0] + H[1] * HP[1] + R\n         if S <= 0.0:\n             S = self.min_R\n-        d2 = (innovation*innovation) / S\n+        d2 = innovation * innovation / S\n         if d2 > self.gating_threshold:\n             return False\n-        # Kalman gain K = P H^T / S => 2x1 vector\n-        K = [HP[0]/S, HP[1]/S]\n-        # State update x = x + K * innovation\n-        self.x[0] += K[0]*innovation\n-        self.x[1] += K[1]*innovation\n-        # Covariance update P = P - K * (H * P)\n-        # Compute H*P (row vector) as HP computed above\n-        KP = _outer(K, HP)  # 2x2\n+        K = [HP[0] / S, HP[1] / S]\n+        self.x[0] += K[0] * innovation\n+        self.x[1] += K[1] * innovation\n+        KP = _outer(K, HP)\n         self.P = _mat_sub(self.P, KP)\n-        # Ensure symmetry and non-negative diagonal (simple safeguard)\n-        self.P[0][1] = self.P[1][0] = 0.5*(self.P[0][1] + self.P[1][0])\n+        self.P[0][1] = self.P[1][0] = 0.5 * (self.P[0][1] + self.P[1][0])\n         self.P[0][0] = max(self.P[0][0], 0.0)\n         self.P[1][1] = max(self.P[1][1], 0.0)\n         return True\n@@ -130,20 +94,16 @@\n             z = float(m['z'])\n             R = max(self.min_R, float(m['R']))\n             if R > self.max_R:\n-                # Skip this measurement entirely\n                 continue\n-            # accumulate weights w = 1/R\n             w = 1.0 / R\n             if mtype not in groups:\n                 groups[mtype] = {'num': 0.0, 'den': 0.0}\n             groups[mtype]['num'] += z * w\n             groups[mtype]['den'] += w\n         applied = []\n-        # deterministic order\n         for mtype in ('position', 'velocity'):\n             if mtype in groups and groups[mtype]['den'] > 0.0:\n                 z_agg = groups[mtype]['num'] / groups[mtype]['den']\n-                # equivalent aggregated variance\n                 R_agg = 1.0 / groups[mtype]['den']\n                 m = {'type': mtype, 'z': z_agg, 'R': R_agg}\n                 ok = self.update(m)\n@@ -158,6 +118,5 @@\n         for dt, measurements in steps:\n             if dt is not None and dt > 0.0:\n                 self.predict(dt)\n-            # aggregate and update\n             self.aggregate_and_update(measurements or [])\n-        return self.x[:], [row[:] for row in self.P]\n+        return (self.x[:], [row[:] for row in self.P])",
  "conversation": [
    {
      "content": "Domain: Control Systems | Topic: State estimation | Subtopic: Kalman filtering for sensor fusion\nYou are given a small sensor-fusion Kalman filter for a 1D constant-velocity plant. The system state is [position, velocity]. Two sensor channels are available: position and velocity. In a realistic deployment sensors may produce:\n- multiple measurements at the same timestamp from different sensors,\n- degenerate reported covariances (zero or extremely large),\n- outliers that should be gated away using a Mahalanobis distance test.\n\nThe goal is to implement a compact, correct, and debuggable Kalman filter module that:\n- performs prediction with process noise derived from an acceleration variance,\n- accepts measurements of type 'position' or 'velocity' and updates the state,\n- aggregates multiple measurements at the same timestamp of the same type using inverse-variance weighting,\n- clamps extreme covariance values, and skips measurements whose covariance exceeds a configured maximum,\n- uses scalar Mahalanobis gating to reject outliers,\n- exposes a utility to run a sequence of predict/update steps.\n\nThe debugging challenge is to reason about numerical edge cases (zero R, very large R), the correct small-matrix update algebra for scalar measurements, and proper ordering/aggregation of simultaneous measurements. The module must be correct and robust enough to be used in tests that validate both normal convergence and edge-case behavior.\n",
      "role": "architect"
    },
    {
      "content": "Solution strategy:\n1. Represent the 2-element state and 2x2 covariance with simple Python lists for clarity and deterministic performance.\n2. Implement predict(dt) with constant-velocity F and continuous-time process noise discretized for constant acceleration noise.\n3. Implement a scalar-measurement Kalman update that computes innovation, scalar S, Kalman gain K (2x1), and updates state and covariance using the formula P := P - K * (H * P) (which is algebraically stable for scalar measurements).\n4. Clamp measurement covariance into [min_R, max_R] bounds; skip if R > max_R.\n5. Compute Mahalanobis distance d2 = innovation^2 / S and skip updates when d2 > gating_threshold.\n6. Provide an aggregation routine that merges multiple measurements of the same type at one timestamp by inverse-variance weighted averaging.\n7. Offer a run_sequence utility to process a list of (dt, measurements) steps so tests can simulate time series interactions.",
      "role": "planner"
    },
    {
      "content": "Correct implementation (`kalman_fusion_1d.py`):\n```python\n# kalman_fusion_1d.py\n\"\"\"\n1D constant-velocity Kalman fusion module.\nState: [position, velocity]\nProvides: predict(dt), update(measurement), aggregate_and_update(measurements), run_sequence.\n\"\"\"\nfrom typing import List, Dict, Sequence\n\ndef _dot(a, b):\n    return a[0]*b[0] + a[1]*b[1]\n\ndef _outer(a, b):\n    # outer product of 2-vector a and 2-vector b -> 2x2\n    return [[a[0]*b[0], a[0]*b[1]],\n            [a[1]*b[0], a[1]*b[1]]]\n\ndef _mat_sub(A, B):\n    return [[A[0][0]-B[0][0], A[0][1]-B[0][1]],\n            [A[1][0]-B[1][0], A[1][1]-B[1][1]]]\n\nclass KalmanFilter1D:\n    def __init__(self, x0=None, P0=None,\n                 accel_variance=1.0,\n                 gating_threshold=9.0,\n                 min_R=1e-4,\n                 max_R=1e6):\n        # state vector [pos, vel]\n        self.x = x0[:] if x0 is not None else [0.0, 0.0]\n        # covariance 2x2\n        self.P = [row[:] for row in (P0 if P0 is not None else [[1.0, 0.0], [0.0, 1.0]])]\n        self.accel_variance = float(accel_variance)\n        self.gating_threshold = float(gating_threshold)\n        self.min_R = float(min_R)\n        self.max_R = float(max_R)\n\n    def predict(self, dt):\n        # State transition F = [[1, dt], [0,1]]\n        F = [[1.0, dt], [0.0, 1.0]]\n        # x = F x\n        x0 = self.x[:]\n        self.x[0] = F[0][0]*x0[0] + F[0][1]*x0[1]\n        self.x[1] = F[1][0]*x0[0] + F[1][1]*x0[1]\n        # Process noise Q for constant acceleration model\n        q11 = (dt**4)/4.0 * self.accel_variance\n        q12 = (dt**3)/2.0 * self.accel_variance\n        q22 = (dt**2) * self.accel_variance\n        Q = [[q11, q12], [q12, q22]]\n        # P = F P F^T + Q (compute explicitly for 2x2)\n        P = self.P\n        # F P\n        FP = [[F[0][0]*P[0][0] + F[0][1]*P[1][0],\n               F[0][0]*P[0][1] + F[0][1]*P[1][1]],\n              [F[1][0]*P[0][0] + F[1][1]*P[1][0],\n               F[1][0]*P[0][1] + F[1][1]*P[1][1]]]\n        # F P F^T\n        FPFt = [[FP[0][0]*F[0][0] + FP[0][1]*F[0][1],\n                 FP[0][0]*F[1][0] + FP[0][1]*F[1][1]],\n                [FP[1][0]*F[0][0] + FP[1][1]*F[0][1],\n                 FP[1][0]*F[1][0] + FP[1][1]*F[1][1]]]\n        self.P = [[FPFt[0][0] + Q[0][0], FPFt[0][1] + Q[0][1]],\n                  [FPFt[1][0] + Q[1][0], FPFt[1][1] + Q[1][1]]]\n\n    def _clamp_R(self, R):\n        # Prevent degenerate covariances\n        Rclamped = max(self.min_R, float(R))\n        return Rclamped\n\n    def update(self, measurement: Dict):\n        \"\"\"\n        measurement: dict with keys:\n          - 'type': 'position' or 'velocity'\n          - 'z': measurement value (float)\n          - 'R': measurement variance (float)\n        Returns True if the measurement was applied, False if skipped.\n        \"\"\"\n        mtype = measurement.get('type')\n        z = float(measurement.get('z'))\n        R = float(measurement.get('R'))\n        R = self._clamp_R(R)\n        if R > self.max_R:\n            # Sensor reported enormous uncertainty; skip\n            return False\n        # Define H row vector for measurement\n        if mtype == 'position':\n            H = [1.0, 0.0]\n        elif mtype == 'velocity':\n            H = [0.0, 1.0]\n        else:\n            raise ValueError(\"unknown measurement type\")\n        # Predicted measurement y = H x\n        y_pred = _dot(H, self.x)\n        innovation = z - y_pred\n        # S = H P H^T + R (scalar)\n        # H P is 1x2 row vector\n        HP = [H[0]*self.P[0][0] + H[1]*self.P[1][0],\n              H[0]*self.P[0][1] + H[1]*self.P[1][1]]\n        S = H[0]*HP[0] + H[1]*HP[1] + R\n        # Mahalanobis gating (scalar)\n        # Protect against tiny S\n        if S <= 0.0:\n            S = self.min_R\n        d2 = (innovation*innovation) / S\n        if d2 > self.gating_threshold:\n            return False\n        # Kalman gain K = P H^T / S => 2x1 vector\n        K = [HP[0]/S, HP[1]/S]\n        # State update x = x + K * innovation\n        self.x[0] += K[0]*innovation\n        self.x[1] += K[1]*innovation\n        # Covariance update P = P - K * (H * P)\n        # Compute H*P (row vector) as HP computed above\n        KP = _outer(K, HP)  # 2x2\n        self.P = _mat_sub(self.P, KP)\n        # Ensure symmetry and non-negative diagonal (simple safeguard)\n        self.P[0][1] = self.P[1][0] = 0.5*(self.P[0][1] + self.P[1][0])\n        self.P[0][0] = max(self.P[0][0], 0.0)\n        self.P[1][1] = max(self.P[1][1], 0.0)\n        return True\n\n    def aggregate_and_update(self, measurements: Sequence[Dict]):\n        \"\"\"\n        Aggregates multiple measurements (same timestamp) by type using inverse-variance weighting,\n        then applies an update per measurement type in a deterministic order: position then velocity.\n        \"\"\"\n        if not measurements:\n            return []\n        groups = {}\n        for m in measurements:\n            mtype = m['type']\n            z = float(m['z'])\n            R = max(self.min_R, float(m['R']))\n            if R > self.max_R:\n                # Skip this measurement entirely\n                continue\n            # accumulate weights w = 1/R\n            w = 1.0 / R\n            if mtype not in groups:\n                groups[mtype] = {'num': 0.0, 'den': 0.0}\n            groups[mtype]['num'] += z * w\n            groups[mtype]['den'] += w\n        applied = []\n        # deterministic order\n        for mtype in ('position', 'velocity'):\n            if mtype in groups and groups[mtype]['den'] > 0.0:\n                z_agg = groups[mtype]['num'] / groups[mtype]['den']\n                # equivalent aggregated variance\n                R_agg = 1.0 / groups[mtype]['den']\n                m = {'type': mtype, 'z': z_agg, 'R': R_agg}\n                ok = self.update(m)\n                applied.append((m, ok))\n        return applied\n\n    def run_sequence(self, steps: Sequence):\n        \"\"\"\n        steps: sequence of (dt, measurements) where measurements is a list of measurement dicts.\n        Returns final state x and P.\n        \"\"\"\n        for dt, measurements in steps:\n            if dt is not None and dt > 0.0:\n                self.predict(dt)\n            # aggregate and update\n            self.aggregate_and_update(measurements or [])\n        return self.x[:], [row[:] for row in self.P]\n```",
      "role": "developer"
    },
    {
      "content": "Validation assets for the feature:\nUnit tests:\n```python\n# test_kalman_fusion_1d.py\nimport unittest\nfrom kalman_fusion_1d import KalmanFilter1D\n\nclass TestKalmanFusion1D(unittest.TestCase):\n    def test_convergence_position_measurements(self):\n        # True motion: constant velocity 2.0 m/s, start pos 0\n        kf = KalmanFilter1D(x0=[0.0, 0.0], P0=[[10.0, 0.0], [0.0, 10.0]], accel_variance=0.1)\n        steps = []\n        dt = 1.0\n        true_vel = 2.0\n        # produce position measurements every dt with small noise (deterministic here)\n        for i in range(6):\n            t = (i+1)*dt\n            pos_meas = {'type': 'position', 'z': true_vel * t, 'R': 0.5}\n            steps.append((dt, [pos_meas]))\n        x_final, P_final = kf.run_sequence(steps)\n        # Expect velocity to be close to 2.0 and position close to 12.0 (at t=6)\n        self.assertAlmostEqual(x_final[1], true_vel, places=1)\n        self.assertAlmostEqual(x_final[0], true_vel*6, places=1)\n\n    def test_outlier_is_gated(self):\n        kf = KalmanFilter1D(x0=[0.0, 1.0], P0=[[1.0, 0.0], [0.0, 1.0]], accel_variance=0.01, gating_threshold=9.0)\n        # normal measurement\n        kf.predict(1.0)\n        ok1 = kf.update({'type': 'position', 'z': 1.0, 'R': 0.1})\n        self.assertTrue(ok1)\n        # outlier far away\n        ok_out = kf.update({'type': 'position', 'z': 100.0, 'R': 0.1})\n        self.assertFalse(ok_out)\n        # after gating, subsequent reasonable measurement still accepted\n        ok2 = kf.update({'type': 'position', 'z': 2.0, 'R': 0.1})\n        self.assertTrue(ok2)\n\n    def test_zero_covariance_is_clamped_and_used(self):\n        kf = KalmanFilter1D(x0=[0.0, 0.0], P0=[[1.0, 0.0],[0.0,1.0]], min_R=1e-3)\n        kf.predict(1.0)\n        # Provide a measurement with R=0: should be clamped to min_R and applied\n        ok = kf.update({'type': 'position', 'z': 2.0, 'R': 0.0})\n        self.assertTrue(ok)\n        # state position should move toward 2.0\n        self.assertGreater(kf.x[0], 0.0)\n\n    def test_large_covariance_is_skipped(self):\n        kf = KalmanFilter1D(x0=[0.0, 0.0], P0=[[0.5,0.0],[0.0,0.5]], max_R=10.0)\n        kf.predict(0.5)\n        # measurement with R bigger than max_R should be skipped\n        ok = kf.update({'type': 'velocity', 'z': 5.0, 'R': 1e9})\n        self.assertFalse(ok)\n        # no change to velocity beyond predict's effect (predict doesn't change velocity here except F* x)\n        # velocity should remain unchanged by update (predict didn't change vel for dt=0.5 since initial vel 0)\n        self.assertAlmostEqual(kf.x[1], 0.0, places=6)\n\nif __name__ == '__main__':\n    unittest.main()\n```\nTest runner:\n```python\nimport sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```",
      "role": "qa"
    },
    {
      "content": "Injected defect version:\n```python\n\"\"\"\n1D constant-velocity Kalman fusion module.\nState: [position, velocity]\nProvides: predict(dt), update(measurement), aggregate_and_update(measurements), run_sequence.\n\"\"\"\nfrom typing import List, Dict, Sequence\n\ndef _dot(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef _outer(a, b):\n    return [[a[0] * b[0], a[0] * b[1]], [a[1] * b[0], a[1] * b[1]]]\n\ndef _mat_sub(A, B):\n    return [[A[0][0] - B[0][0], A[0][1] - B[0][1]], [A[1][0] - B[1][0], A[1][1] - B[1][1]]]\n\nclass KalmanFilter1D:\n\n    def __init__(self, x0=None, P0=None, accel_variance=1.0, gating_threshold=9.0, min_R=0.0001, max_R=1000000.0):\n        self.x = x0[:] if x0 is not None else [0.0, 0.0]\n        self.P = [row[:] for row in (P0 if P0 is not None else [[1.0, 0.0], [0.0, 1.0]])]\n        self.accel_variance = float(accel_variance)\n        self.gating_threshold = float(gating_threshold)\n        self.min_R = float(min_R)\n        self.max_R = float(max_R)\n\n    def predict(self, dt):\n        F = [[1.0, dt], [0.0, 1.0]]\n        x0 = self.x[:]\n        self.x[0] = F[0][0] * x0[0] + F[0][1] * x0[1]\n        self.x[1] = F[1][0] * x0[0] + F[1][1] * x0[1]\n        q11 = dt ** 4 / 4.0 * self.accel_variance\n        q12 = dt ** 3 / 2.0 * self.accel_variance\n        q22 = dt ** 2 * self.accel_variance\n        Q = [[q11, q12], [q12, q22]]\n        P = self.P\n        FP = [[F[0][0] * P[0][0] + F[0][1] * P[1][0], F[0][0] * P[0][1] + F[0][1] * P[1][1]], [F[1][0] * P[0][0] + F[1][1] * P[1][0], F[1][0] * P[0][1] + F[1][1] * P[1][1]]]\n        FPFt = [[FP[0][0] * F[0][0] + FP[0][1] * F[0][1], FP[0][0] * F[1][0] + FP[0][1] * F[1][1]], [FP[1][0] * F[0][0] + FP[1][1] * F[0][1], FP[1][0] * F[1][0] + FP[1][1] * F[1][1]]]\n        self.P = [[FPFt[0][0] + Q[0][0], FPFt[0][1] + Q[0][1]], [FPFt[1][0] + Q[1][0], FPFt[1][1] + Q[1][1]]]\n\n    def _clamp_R(self, R):\n        Rclamped = max(self.min_R, float(R))\n        return Rclamped\n\n    def update(self, measurement: Dict):\n        \"\"\"\n        measurement: dict with keys:\n          - 'type': 'position' or 'velocity'\n          - 'z': measurement value (float)\n          - 'R': measurement variance (float)\n        Returns True if the measurement was applied, False if skipped.\n        \"\"\"\n        mtype = measurement.get('type')\n        z = float(measurement.get('z'))\n        R = float(measurement.get('R'))\n        R = self._clamp_R(R)\n        if R < self.max_R:\n            return False\n        if mtype == 'position':\n            H = [1.0, 0.0]\n        elif mtype == 'velocity':\n            H = [0.0, 1.0]\n        else:\n            raise ValueError('unknown measurement type')\n        y_pred = _dot(H, self.x)\n        innovation = z - y_pred\n        HP = [H[0] * self.P[0][0] + H[1] * self.P[1][0], H[0] * self.P[0][1] + H[1] * self.P[1][1]]\n        S = H[0] * HP[0] + H[1] * HP[1] + R\n        if S <= 0.0:\n            S = self.min_R\n        d2 = innovation * innovation / S\n        if d2 > self.gating_threshold:\n            return False\n        K = [HP[0] / S, HP[1] / S]\n        self.x[0] += K[0] * innovation\n        self.x[1] += K[1] * innovation\n        KP = _outer(K, HP)\n        self.P = _mat_sub(self.P, KP)\n        self.P[0][1] = self.P[1][0] = 0.5 * (self.P[0][1] + self.P[1][0])\n        self.P[0][0] = max(self.P[0][0], 0.0)\n        self.P[1][1] = max(self.P[1][1], 0.0)\n        return True\n\n    def aggregate_and_update(self, measurements: Sequence[Dict]):\n        \"\"\"\n        Aggregates multiple measurements (same timestamp) by type using inverse-variance weighting,\n        then applies an update per measurement type in a deterministic order: position then velocity.\n        \"\"\"\n        if not measurements:\n            return []\n        groups = {}\n        for m in measurements:\n            mtype = m['type']\n            z = float(m['z'])\n            R = max(self.min_R, float(m['R']))\n            if R > self.max_R:\n                continue\n            w = 1.0 / R\n            if mtype not in groups:\n                groups[mtype] = {'num': 0.0, 'den': 0.0}\n            groups[mtype]['num'] += z * w\n            groups[mtype]['den'] += w\n        applied = []\n        for mtype in ('position', 'velocity'):\n            if mtype in groups and groups[mtype]['den'] > 0.0:\n                z_agg = groups[mtype]['num'] / groups[mtype]['den']\n                R_agg = 1.0 / groups[mtype]['den']\n                m = {'type': mtype, 'z': z_agg, 'R': R_agg}\n                ok = self.update(m)\n                applied.append((m, ok))\n        return applied\n\n    def run_sequence(self, steps: Sequence):\n        \"\"\"\n        steps: sequence of (dt, measurements) where measurements is a list of measurement dicts.\n        Returns final state x and P.\n        \"\"\"\n        for dt, measurements in steps:\n            if dt is not None and dt > 0.0:\n                self.predict(dt)\n            self.aggregate_and_update(measurements or [])\n        return (self.x[:], [row[:] for row in self.P])\n```",
      "role": "developer"
    },
    {
      "content": "Test suite failure trace:\n```\ntest_convergence_position_measurements (test_kalman_fusion_1d.TestKalmanFusion1D.test_convergence_position_measurements) ... FAIL\ntest_large_covariance_is_skipped (test_kalman_fusion_1d.TestKalmanFusion1D.test_large_covariance_is_skipped) ... FAIL\ntest_outlier_is_gated (test_kalman_fusion_1d.TestKalmanFusion1D.test_outlier_is_gated) ... FAIL\ntest_zero_covariance_is_clamped_and_used (test_kalman_fusion_1d.TestKalmanFusion1D.test_zero_covariance_is_clamped_and_used) ... FAIL\n\n======================================================================\nFAIL: test_convergence_position_measurements (test_kalman_fusion_1d.TestKalmanFusion1D.test_convergence_position_measurements)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 19, in test_convergence_position_measurements\n    self.assertAlmostEqual(x_final[1], true_vel, places=1)\n    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.0 != 2.0 within 1 places (2.0 difference)\n\n======================================================================\nFAIL: test_large_covariance_is_skipped (test_kalman_fusion_1d.TestKalmanFusion1D.test_large_covariance_is_skipped)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 49, in test_large_covariance_is_skipped\n    self.assertFalse(ok)\n    ~~~~~~~~~~~~~~~~^^^^\nAssertionError: True is not false\n\n======================================================================\nFAIL: test_outlier_is_gated (test_kalman_fusion_1d.TestKalmanFusion1D.test_outlier_is_gated)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 27, in test_outlier_is_gated\n    self.assertTrue(ok1)\n    ~~~~~~~~~~~~~~~^^^^^\nAssertionError: False is not true\n\n======================================================================\nFAIL: test_zero_covariance_is_clamped_and_used (test_kalman_fusion_1d.TestKalmanFusion1D.test_zero_covariance_is_clamped_and_used)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 40, in test_zero_covariance_is_clamped_and_used\n    self.assertTrue(ok)\n    ~~~~~~~~~~~~~~~^^^^\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 4 tests in 0.000s\n\nFAILED (failures=4)\n```",
      "role": "qa"
    },
    {
      "content": "Restored the original implementation so all unit tests pass again.",
      "role": "developer"
    }
  ],
  "correct_code": "# kalman_fusion_1d.py\n\"\"\"\n1D constant-velocity Kalman fusion module.\nState: [position, velocity]\nProvides: predict(dt), update(measurement), aggregate_and_update(measurements), run_sequence.\n\"\"\"\nfrom typing import List, Dict, Sequence\n\ndef _dot(a, b):\n    return a[0]*b[0] + a[1]*b[1]\n\ndef _outer(a, b):\n    # outer product of 2-vector a and 2-vector b -> 2x2\n    return [[a[0]*b[0], a[0]*b[1]],\n            [a[1]*b[0], a[1]*b[1]]]\n\ndef _mat_sub(A, B):\n    return [[A[0][0]-B[0][0], A[0][1]-B[0][1]],\n            [A[1][0]-B[1][0], A[1][1]-B[1][1]]]\n\nclass KalmanFilter1D:\n    def __init__(self, x0=None, P0=None,\n                 accel_variance=1.0,\n                 gating_threshold=9.0,\n                 min_R=1e-4,\n                 max_R=1e6):\n        # state vector [pos, vel]\n        self.x = x0[:] if x0 is not None else [0.0, 0.0]\n        # covariance 2x2\n        self.P = [row[:] for row in (P0 if P0 is not None else [[1.0, 0.0], [0.0, 1.0]])]\n        self.accel_variance = float(accel_variance)\n        self.gating_threshold = float(gating_threshold)\n        self.min_R = float(min_R)\n        self.max_R = float(max_R)\n\n    def predict(self, dt):\n        # State transition F = [[1, dt], [0,1]]\n        F = [[1.0, dt], [0.0, 1.0]]\n        # x = F x\n        x0 = self.x[:]\n        self.x[0] = F[0][0]*x0[0] + F[0][1]*x0[1]\n        self.x[1] = F[1][0]*x0[0] + F[1][1]*x0[1]\n        # Process noise Q for constant acceleration model\n        q11 = (dt**4)/4.0 * self.accel_variance\n        q12 = (dt**3)/2.0 * self.accel_variance\n        q22 = (dt**2) * self.accel_variance\n        Q = [[q11, q12], [q12, q22]]\n        # P = F P F^T + Q (compute explicitly for 2x2)\n        P = self.P\n        # F P\n        FP = [[F[0][0]*P[0][0] + F[0][1]*P[1][0],\n               F[0][0]*P[0][1] + F[0][1]*P[1][1]],\n              [F[1][0]*P[0][0] + F[1][1]*P[1][0],\n               F[1][0]*P[0][1] + F[1][1]*P[1][1]]]\n        # F P F^T\n        FPFt = [[FP[0][0]*F[0][0] + FP[0][1]*F[0][1],\n                 FP[0][0]*F[1][0] + FP[0][1]*F[1][1]],\n                [FP[1][0]*F[0][0] + FP[1][1]*F[0][1],\n                 FP[1][0]*F[1][0] + FP[1][1]*F[1][1]]]\n        self.P = [[FPFt[0][0] + Q[0][0], FPFt[0][1] + Q[0][1]],\n                  [FPFt[1][0] + Q[1][0], FPFt[1][1] + Q[1][1]]]\n\n    def _clamp_R(self, R):\n        # Prevent degenerate covariances\n        Rclamped = max(self.min_R, float(R))\n        return Rclamped\n\n    def update(self, measurement: Dict):\n        \"\"\"\n        measurement: dict with keys:\n          - 'type': 'position' or 'velocity'\n          - 'z': measurement value (float)\n          - 'R': measurement variance (float)\n        Returns True if the measurement was applied, False if skipped.\n        \"\"\"\n        mtype = measurement.get('type')\n        z = float(measurement.get('z'))\n        R = float(measurement.get('R'))\n        R = self._clamp_R(R)\n        if R > self.max_R:\n            # Sensor reported enormous uncertainty; skip\n            return False\n        # Define H row vector for measurement\n        if mtype == 'position':\n            H = [1.0, 0.0]\n        elif mtype == 'velocity':\n            H = [0.0, 1.0]\n        else:\n            raise ValueError(\"unknown measurement type\")\n        # Predicted measurement y = H x\n        y_pred = _dot(H, self.x)\n        innovation = z - y_pred\n        # S = H P H^T + R (scalar)\n        # H P is 1x2 row vector\n        HP = [H[0]*self.P[0][0] + H[1]*self.P[1][0],\n              H[0]*self.P[0][1] + H[1]*self.P[1][1]]\n        S = H[0]*HP[0] + H[1]*HP[1] + R\n        # Mahalanobis gating (scalar)\n        # Protect against tiny S\n        if S <= 0.0:\n            S = self.min_R\n        d2 = (innovation*innovation) / S\n        if d2 > self.gating_threshold:\n            return False\n        # Kalman gain K = P H^T / S => 2x1 vector\n        K = [HP[0]/S, HP[1]/S]\n        # State update x = x + K * innovation\n        self.x[0] += K[0]*innovation\n        self.x[1] += K[1]*innovation\n        # Covariance update P = P - K * (H * P)\n        # Compute H*P (row vector) as HP computed above\n        KP = _outer(K, HP)  # 2x2\n        self.P = _mat_sub(self.P, KP)\n        # Ensure symmetry and non-negative diagonal (simple safeguard)\n        self.P[0][1] = self.P[1][0] = 0.5*(self.P[0][1] + self.P[1][0])\n        self.P[0][0] = max(self.P[0][0], 0.0)\n        self.P[1][1] = max(self.P[1][1], 0.0)\n        return True\n\n    def aggregate_and_update(self, measurements: Sequence[Dict]):\n        \"\"\"\n        Aggregates multiple measurements (same timestamp) by type using inverse-variance weighting,\n        then applies an update per measurement type in a deterministic order: position then velocity.\n        \"\"\"\n        if not measurements:\n            return []\n        groups = {}\n        for m in measurements:\n            mtype = m['type']\n            z = float(m['z'])\n            R = max(self.min_R, float(m['R']))\n            if R > self.max_R:\n                # Skip this measurement entirely\n                continue\n            # accumulate weights w = 1/R\n            w = 1.0 / R\n            if mtype not in groups:\n                groups[mtype] = {'num': 0.0, 'den': 0.0}\n            groups[mtype]['num'] += z * w\n            groups[mtype]['den'] += w\n        applied = []\n        # deterministic order\n        for mtype in ('position', 'velocity'):\n            if mtype in groups and groups[mtype]['den'] > 0.0:\n                z_agg = groups[mtype]['num'] / groups[mtype]['den']\n                # equivalent aggregated variance\n                R_agg = 1.0 / groups[mtype]['den']\n                m = {'type': mtype, 'z': z_agg, 'R': R_agg}\n                ok = self.update(m)\n                applied.append((m, ok))\n        return applied\n\n    def run_sequence(self, steps: Sequence):\n        \"\"\"\n        steps: sequence of (dt, measurements) where measurements is a list of measurement dicts.\n        Returns final state x and P.\n        \"\"\"\n        for dt, measurements in steps:\n            if dt is not None and dt > 0.0:\n                self.predict(dt)\n            # aggregate and update\n            self.aggregate_and_update(measurements or [])\n        return self.x[:], [row[:] for row in self.P]\n",
  "domain": "Control Systems",
  "failing_output": "test_convergence_position_measurements (test_kalman_fusion_1d.TestKalmanFusion1D.test_convergence_position_measurements) ... FAIL\ntest_large_covariance_is_skipped (test_kalman_fusion_1d.TestKalmanFusion1D.test_large_covariance_is_skipped) ... FAIL\ntest_outlier_is_gated (test_kalman_fusion_1d.TestKalmanFusion1D.test_outlier_is_gated) ... FAIL\ntest_zero_covariance_is_clamped_and_used (test_kalman_fusion_1d.TestKalmanFusion1D.test_zero_covariance_is_clamped_and_used) ... FAIL\n\n======================================================================\nFAIL: test_convergence_position_measurements (test_kalman_fusion_1d.TestKalmanFusion1D.test_convergence_position_measurements)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 19, in test_convergence_position_measurements\n    self.assertAlmostEqual(x_final[1], true_vel, places=1)\n    ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 0.0 != 2.0 within 1 places (2.0 difference)\n\n======================================================================\nFAIL: test_large_covariance_is_skipped (test_kalman_fusion_1d.TestKalmanFusion1D.test_large_covariance_is_skipped)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 49, in test_large_covariance_is_skipped\n    self.assertFalse(ok)\n    ~~~~~~~~~~~~~~~~^^^^\nAssertionError: True is not false\n\n======================================================================\nFAIL: test_outlier_is_gated (test_kalman_fusion_1d.TestKalmanFusion1D.test_outlier_is_gated)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 27, in test_outlier_is_gated\n    self.assertTrue(ok1)\n    ~~~~~~~~~~~~~~~^^^^^\nAssertionError: False is not true\n\n======================================================================\nFAIL: test_zero_covariance_is_clamped_and_used (test_kalman_fusion_1d.TestKalmanFusion1D.test_zero_covariance_is_clamped_and_used)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/private/var/folders/zp/bbktq6x94hz_t85nvqs8b4w00000gn/T/tmpwullk9_s/test_kalman_fusion_1d.py\", line 40, in test_zero_covariance_is_clamped_and_used\n    self.assertTrue(ok)\n    ~~~~~~~~~~~~~~~^^^^\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 4 tests in 0.000s\n\nFAILED (failures=4)",
  "module_name": "kalman_fusion_1d",
  "problem_description": "You are given a small sensor-fusion Kalman filter for a 1D constant-velocity plant. The system state is [position, velocity]. Two sensor channels are available: position and velocity. In a realistic deployment sensors may produce:\n- multiple measurements at the same timestamp from different sensors,\n- degenerate reported covariances (zero or extremely large),\n- outliers that should be gated away using a Mahalanobis distance test.\n\nThe goal is to implement a compact, correct, and debuggable Kalman filter module that:\n- performs prediction with process noise derived from an acceleration variance,\n- accepts measurements of type 'position' or 'velocity' and updates the state,\n- aggregates multiple measurements at the same timestamp of the same type using inverse-variance weighting,\n- clamps extreme covariance values, and skips measurements whose covariance exceeds a configured maximum,\n- uses scalar Mahalanobis gating to reject outliers,\n- exposes a utility to run a sequence of predict/update steps.\n\nThe debugging challenge is to reason about numerical edge cases (zero R, very large R), the correct small-matrix update algebra for scalar measurements, and proper ordering/aggregation of simultaneous measurements. The module must be correct and robust enough to be used in tests that validate both normal convergence and edge-case behavior.\n",
  "runner_code": "import sys\nimport unittest\n\n\ndef main() -> int:\n    suite = unittest.defaultTestLoader.discover(\".\", pattern=\"test_*.py\")\n    result = unittest.TextTestRunner(verbosity=2).run(suite)\n    return 0 if result.wasSuccessful() else 1\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n",
  "solution_outline": "1. Represent the 2-element state and 2x2 covariance with simple Python lists for clarity and deterministic performance.\n2. Implement predict(dt) with constant-velocity F and continuous-time process noise discretized for constant acceleration noise.\n3. Implement a scalar-measurement Kalman update that computes innovation, scalar S, Kalman gain K (2x1), and updates state and covariance using the formula P := P - K * (H * P) (which is algebraically stable for scalar measurements).\n4. Clamp measurement covariance into [min_R, max_R] bounds; skip if R > max_R.\n5. Compute Mahalanobis distance d2 = innovation^2 / S and skip updates when d2 > gating_threshold.\n6. Provide an aggregation routine that merges multiple measurements of the same type at one timestamp by inverse-variance weighted averaging.\n7. Offer a run_sequence utility to process a list of (dt, measurements) steps so tests can simulate time series interactions.\n",
  "subtopic": "Kalman filtering for sensor fusion",
  "summary": "A 1D constant-velocity Kalman filter module that fuses position and velocity sensors with gating, aggregation, and robustness to degenerate covariances.",
  "topic": "State estimation",
  "unit_tests": "# test_kalman_fusion_1d.py\nimport unittest\nfrom kalman_fusion_1d import KalmanFilter1D\n\nclass TestKalmanFusion1D(unittest.TestCase):\n    def test_convergence_position_measurements(self):\n        # True motion: constant velocity 2.0 m/s, start pos 0\n        kf = KalmanFilter1D(x0=[0.0, 0.0], P0=[[10.0, 0.0], [0.0, 10.0]], accel_variance=0.1)\n        steps = []\n        dt = 1.0\n        true_vel = 2.0\n        # produce position measurements every dt with small noise (deterministic here)\n        for i in range(6):\n            t = (i+1)*dt\n            pos_meas = {'type': 'position', 'z': true_vel * t, 'R': 0.5}\n            steps.append((dt, [pos_meas]))\n        x_final, P_final = kf.run_sequence(steps)\n        # Expect velocity to be close to 2.0 and position close to 12.0 (at t=6)\n        self.assertAlmostEqual(x_final[1], true_vel, places=1)\n        self.assertAlmostEqual(x_final[0], true_vel*6, places=1)\n\n    def test_outlier_is_gated(self):\n        kf = KalmanFilter1D(x0=[0.0, 1.0], P0=[[1.0, 0.0], [0.0, 1.0]], accel_variance=0.01, gating_threshold=9.0)\n        # normal measurement\n        kf.predict(1.0)\n        ok1 = kf.update({'type': 'position', 'z': 1.0, 'R': 0.1})\n        self.assertTrue(ok1)\n        # outlier far away\n        ok_out = kf.update({'type': 'position', 'z': 100.0, 'R': 0.1})\n        self.assertFalse(ok_out)\n        # after gating, subsequent reasonable measurement still accepted\n        ok2 = kf.update({'type': 'position', 'z': 2.0, 'R': 0.1})\n        self.assertTrue(ok2)\n\n    def test_zero_covariance_is_clamped_and_used(self):\n        kf = KalmanFilter1D(x0=[0.0, 0.0], P0=[[1.0, 0.0],[0.0,1.0]], min_R=1e-3)\n        kf.predict(1.0)\n        # Provide a measurement with R=0: should be clamped to min_R and applied\n        ok = kf.update({'type': 'position', 'z': 2.0, 'R': 0.0})\n        self.assertTrue(ok)\n        # state position should move toward 2.0\n        self.assertGreater(kf.x[0], 0.0)\n\n    def test_large_covariance_is_skipped(self):\n        kf = KalmanFilter1D(x0=[0.0, 0.0], P0=[[0.5,0.0],[0.0,0.5]], max_R=10.0)\n        kf.predict(0.5)\n        # measurement with R bigger than max_R should be skipped\n        ok = kf.update({'type': 'velocity', 'z': 5.0, 'R': 1e9})\n        self.assertFalse(ok)\n        # no change to velocity beyond predict's effect (predict doesn't change velocity here except F* x)\n        # velocity should remain unchanged by update (predict didn't change vel for dt=0.5 since initial vel 0)\n        self.assertAlmostEqual(kf.x[1], 0.0, places=6)\n\nif __name__ == '__main__':\n    unittest.main()"
}